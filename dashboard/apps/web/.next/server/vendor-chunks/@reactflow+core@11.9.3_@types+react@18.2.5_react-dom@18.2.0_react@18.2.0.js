"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reactflow+core@11.9.3_@types+react@18.2.5_react-dom@18.2.0_react@18.2.0";
exports.ids = ["vendor-chunks/@reactflow+core@11.9.3_@types+react@18.2.5_react-dom@18.2.0_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@reactflow+core@11.9.3_@types+react@18.2.5_react-dom@18.2.0_react@18.2.0/node_modules/@reactflow/core/dist/esm/index.mjs":
/*!*********************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@reactflow+core@11.9.3_@types+react@18.2.5_react-dom@18.2.0_react@18.2.0/node_modules/@reactflow/core/dist/esm/index.mjs ***!
  \*********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText$1),\n/* harmony export */   Handle: () => (/* binding */ Handle$1),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ReactFlow: () => (/* binding */ ReactFlow),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getMarkerEnd: () => (/* binding */ getMarkerEnd),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getRectOfNodes: () => (/* binding */ getRectOfNodes),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getTransformForBounds: () => (/* binding */ getTransformForBounds),\n/* harmony export */   handleParentExpand: () => (/* binding */ handleParentExpand),\n/* harmony export */   internalsSymbol: () => (/* binding */ internalsSymbol),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   updateEdge: () => (/* binding */ updateEdge),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useGetPointerPosition: () => (/* binding */ useGetPointerPosition),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@13.5.5_@babel+core@7.23.2_react-dom@18.2.0_react@18.2.0_sass@1.63.6/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/../../node_modules/.pnpm/classcat@5.0.4/node_modules/classcat/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/../../node_modules/.pnpm/zustand@4.4.3_@types+react@18.2.5_react@18.2.0/node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/../../node_modules/.pnpm/zustand@4.4.3_@types+react@18.2.5_react@18.2.0/node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/../../node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ \"(ssr)/../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ \"(ssr)/../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-drag */ \"(ssr)/../../node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/.pnpm/next@13.5.5_@babel+core@7.23.2_react-dom@18.2.0_react@18.2.0_sass@1.63.6/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n\n\n\n\nconst StoreContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (sourceHandle, edge) => `Couldn't create edge for ${!sourceHandle ? 'source' : 'target'} handle id: \"${!sourceHandle ? edge.sourceHandle : edge.targetHandle}\", edge id: ${edge.id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n};\n\nconst zustandErrorMessage = errorMessages['error001']();\nfunction useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_4__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\nconst useStoreApi = () => {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        getState: store.getState,\n        setState: store.setState,\n        subscribe: store.subscribe,\n        destroy: store.destroy,\n    }), [store]);\n};\n\nconst selector$g = (s) => (s.userSelectionActive ? 'none' : 'all');\nfunction Panel({ position, children, className, style, ...rest }) {\n    const pointerEvents = useStore(selector$g);\n    const positionClasses = `${position}`.split('-');\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(['react-flow__panel', className, ...positionClasses]), style: { ...style, pointerEvents }, ...rest }, children));\n}\n\nfunction Attribution({ proOptions, position = 'bottom-right' }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Panel, { position: position, className: \"react-flow__attribution\", \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { href: \"https://reactflow.dev\", target: \"_blank\", rel: \"noopener noreferrer\", \"aria-label\": \"React Flow attribution\" }, \"React Flow\")));\n}\n\nconst EdgeText = ({ x, y, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [2, 4], labelBgBorderRadius = 2, children, className, ...rest }) => {\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({ x: 0, y: 0, width: 0, height: 0 });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(['react-flow__edge-textwrapper', className]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (edgeRef.current) {\n            const textBbox = edgeRef.current.getBBox();\n            setEdgeTextBbox({\n                x: textBbox.x,\n                y: textBbox.y,\n                width: textBbox.width,\n                height: textBbox.height,\n            });\n        }\n    }, [label]);\n    if (typeof label === 'undefined' || !label) {\n        return null;\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`, className: edgeTextClasses, visibility: edgeTextBbox.width ? 'visible' : 'hidden', ...rest },\n        labelShowBg && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", { width: edgeTextBbox.width + 2 * labelBgPadding[0], x: -labelBgPadding[0], y: -labelBgPadding[1], height: edgeTextBbox.height + 2 * labelBgPadding[1], className: \"react-flow__edge-textbg\", style: labelBgStyle, rx: labelBgBorderRadius, ry: labelBgBorderRadius })),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"text\", { className: \"react-flow__edge-text\", y: edgeTextBbox.height / 2, dy: \"0.3em\", ref: edgeRef, style: labelStyle }, label),\n        children));\n};\nvar EdgeText$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeText);\n\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0]),\n    y: clamp(position.y, extent[0][1], extent[1][1]),\n});\n// returns a number between 0 and 1 that represents the velocity of the movement\n// when the mouse is close to the edge of the canvas\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, 50) / 50;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, 50) / 50;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds) => {\n    const xMovement = calcAutoPanVelocity(pos.x, 35, bounds.width - 35) * 20;\n    const yMovement = calcAutoPanVelocity(pos.y, 35, bounds.height - 35) * 20;\n    return [xMovement, yMovement];\n};\nconst getHostForElement = (element) => element.getRootNode?.() || window?.document;\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node) => ({\n    ...(node.positionAbsolute || { x: 0, y: 0 }),\n    width: node.width || 0,\n    height: node.height || 0,\n});\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\nconst internalsSymbol = Symbol.for('internals');\n// used for a11y key board controls for nodes and edges\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst isReactKeyboardEvent = (event) => 'nativeEvent' in event;\nfunction isInputDOMNode(event) {\n    const kbEvent = isReactKeyboardEvent(event) ? event.nativeEvent : event;\n    // using composed path for handling shadow dom\n    const target = (kbEvent.composedPath?.()?.[0] || event.target);\n    const isInput = ['INPUT', 'SELECT', 'TEXTAREA'].includes(target?.nodeName) || target?.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target?.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouseTriggered = isMouseEvent(event);\n    const evtX = isMouseTriggered ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouseTriggered ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\n\nconst BaseEdge = ({ id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth = 20, }) => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { id: id, style: style, d: path, fill: \"none\", className: \"react-flow__edge-path\", markerEnd: markerEnd, markerStart: markerStart }),\n        interactionWidth && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: path, fill: \"none\", strokeOpacity: 0, strokeWidth: interactionWidth, className: \"react-flow__edge-interaction\" })),\n        label && isNumeric(labelX) && isNumeric(labelY) ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeText$1, { x: labelX, y: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius })) : null));\n};\nBaseEdge.displayName = 'BaseEdge';\n\nconst getMarkerEnd = (markerType, markerEndId) => {\n    if (typeof markerEndId !== 'undefined' && markerEndId) {\n        return `url(#${markerEndId})`;\n    }\n    return typeof markerType !== 'undefined' ? `url(#react-flow__${markerType})` : 'none';\n};\nfunction getMouseHandler$1(id, getState, handler) {\n    return handler === undefined\n        ? handler\n        : (event) => {\n            const edge = getState().edges.find((e) => e.id === id);\n            if (edge) {\n                handler(event, { ...edge });\n            }\n        };\n}\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    // cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n    // https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\n\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\n\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\n\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === Position.Left || pos === Position.Right) {\n        return [0.5 * (x1 + x2), y1];\n    }\n    return [x1, 0.5 * (y1 + y2)];\n}\nfunction getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\nconst SimpleBezierEdge = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth, }) => {\n    const [path, labelX, labelY] = getSimpleBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, { path: path, labelX: labelX, labelY: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, style: style, markerEnd: markerEnd, markerStart: markerStart, interactionWidth: interactionWidth }));\n});\nSimpleBezierEdge.displayName = 'SimpleBezierEdge';\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n// ith this function we try to mimic a orthogonal edge routing behaviour\n// It's not as good as a real orthogonal edge routing but it's faster and good enough as a default for step and smooth step edges\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        centerX = center.x || defaultCenterX;\n        centerY = center.y || defaultCenterY;\n        //    --->\n        //    |\n        // >---\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        //    |\n        //  ---\n        //  |\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\nconst SmoothStepEdge = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth, }) => {\n    const [path, labelX, labelY] = getSmoothStepPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n        borderRadius: pathOptions?.borderRadius,\n        offset: pathOptions?.offset,\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, { path: path, labelX: labelX, labelY: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, style: style, markerEnd: markerEnd, markerStart: markerStart, interactionWidth: interactionWidth }));\n});\nSmoothStepEdge.displayName = 'SmoothStepEdge';\n\nconst StepEdge = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((props) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(SmoothStepEdge, { ...props, pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ borderRadius: 0, offset: props.pathOptions?.offset }), [props.pathOptions?.offset]) })));\nStepEdge.displayName = 'StepEdge';\n\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\nconst StraightEdge = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth, }) => {\n    const [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY });\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, { path: path, labelX: labelX, labelY: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, style: style, markerEnd: markerEnd, markerStart: markerStart, interactionWidth: interactionWidth }));\n});\nStraightEdge.displayName = 'StraightEdge';\n\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\nconst BezierEdge = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth, }) => {\n    const [path, labelX, labelY] = getBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n        curvature: pathOptions?.curvature,\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, { path: path, labelX: labelX, labelY: labelY, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, style: style, markerEnd: markerEnd, markerStart: markerStart, interactionWidth: interactionWidth }));\n});\nBezierEdge.displayName = 'BezierEdge';\n\nconst NodeIdContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\nconst useNodeId = () => {\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NodeIdContext);\n    return nodeId;\n};\n\nconst isEdge = (element) => 'id' in element && 'source' in element && 'target' in element;\nconst isNode = (element) => 'id' in element && !('source' in element) && !('target' in element);\nconst getOutgoers = (node, nodes, edges) => {\n    if (!isNode(node)) {\n        return [];\n    }\n    const outgoerIds = edges.filter((e) => e.source === node.id).map((e) => e.target);\n    return nodes.filter((n) => outgoerIds.includes(n.id));\n};\nconst getIncomers = (node, nodes, edges) => {\n    if (!isNode(node)) {\n        return [];\n    }\n    const incomersIds = edges.filter((e) => e.target === node.id).map((e) => e.source);\n    return nodes.filter((n) => incomersIds.includes(n.id));\n};\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `reactflow__edge-${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst getMarkerId = (marker, rfId) => {\n    if (typeof marker === 'undefined') {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = rfId ? `${rfId}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n};\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdge(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    return edges.concat(edge);\n};\nconst updateEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdgeId);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid, [snapX, snapY]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    if (snapToGrid) {\n        return {\n            x: snapX * Math.round(position.x / snapX),\n            y: snapY * Math.round(position.y / snapY),\n        };\n    }\n    return position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    if (!node) {\n        return {\n            x: 0,\n            y: 0,\n            positionAbsolute: {\n                x: 0,\n                y: 0,\n            },\n        };\n    }\n    const offsetX = (node.width ?? 0) * nodeOrigin[0];\n    const offsetY = (node.height ?? 0) * nodeOrigin[1];\n    const position = {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n    return {\n        ...position,\n        positionAbsolute: node.positionAbsolute\n            ? {\n                x: node.positionAbsolute.x - offsetX,\n                y: node.positionAbsolute.y - offsetY,\n            }\n            : position,\n    };\n};\nconst getRectOfNodes = (nodes, nodeOrigin = [0, 0]) => {\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, node) => {\n        const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;\n        return getBoundsOfBoxes(currBox, rectToBox({\n            x,\n            y,\n            width: node.width || 0,\n            height: node.height || 0,\n        }));\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodeInternals, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false, nodeOrigin = [0, 0]) => {\n    const paneRect = {\n        x: (rect.x - tx) / tScale,\n        y: (rect.y - ty) / tScale,\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    nodeInternals.forEach((node) => {\n        const { width, height, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            return false;\n        }\n        const { positionAbsolute } = getNodePositionWithOrigin(node, nodeOrigin);\n        const nodeRect = {\n            x: positionAbsolute.x,\n            y: positionAbsolute.y,\n            width: width || 0,\n            height: height || 0,\n        };\n        const overlappingArea = getOverlappingArea(paneRect, nodeRect);\n        const notInitialized = typeof width === 'undefined' || typeof height === 'undefined' || width === null || height === null;\n        const partiallyVisible = partially && overlappingArea > 0;\n        const area = (width || 0) * (height || 0);\n        const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    });\n    return visibleNodes;\n};\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = nodes.map((node) => node.id);\n    return edges.filter((edge) => nodeIds.includes(edge.source) || nodeIds.includes(edge.target));\n};\nconst getTransformForBounds = (bounds, width, height, minZoom, maxZoom, padding = 0.1) => {\n    const xZoom = width / (bounds.width * (1 + padding));\n    const yZoom = height / (bounds.height * (1 + padding));\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    return [x, y, clampedZoom];\n};\nconst getD3Transition = (selection, duration = 0) => {\n    return selection.transition().duration(duration);\n};\n\n// this functions collects all handles and adds an absolute position\n// so that we can later find the closest handle to the mouse position\nfunction getHandles(node, handleBounds, type, currentHandle) {\n    return (handleBounds[type] || []).reduce((res, h) => {\n        if (`${node.id}-${h.id}-${type}` !== currentHandle) {\n            res.push({\n                id: h.id || null,\n                type,\n                nodeId: node.id,\n                x: (node.positionAbsolute?.x ?? 0) + h.x + h.width / 2,\n                y: (node.positionAbsolute?.y ?? 0) + h.y + h.height / 2,\n            });\n        }\n        return res;\n    }, []);\n}\nfunction getClosestHandle(event, doc, pos, connectionRadius, handles, validator) {\n    // we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n    // because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n    const { x, y } = getEventPosition(event);\n    const domNodes = doc.elementsFromPoint(x, y);\n    const handleBelow = domNodes.find((el) => el.classList.contains('react-flow__handle'));\n    if (handleBelow) {\n        const handleNodeId = handleBelow.getAttribute('data-nodeid');\n        if (handleNodeId) {\n            const handleType = getHandleType(undefined, handleBelow);\n            const handleId = handleBelow.getAttribute('data-handleid');\n            const validHandleResult = validator({ nodeId: handleNodeId, id: handleId, type: handleType });\n            if (validHandleResult) {\n                return {\n                    handle: {\n                        id: handleId,\n                        type: handleType,\n                        nodeId: handleNodeId,\n                        x: pos.x,\n                        y: pos.y,\n                    },\n                    validHandleResult,\n                };\n            }\n        }\n    }\n    // if we couldn't find a handle below the mouse cursor we look for the closest distance based on the connectionRadius\n    let closestHandles = [];\n    let minDistance = Infinity;\n    handles.forEach((handle) => {\n        const distance = Math.sqrt((handle.x - pos.x) ** 2 + (handle.y - pos.y) ** 2);\n        if (distance <= connectionRadius) {\n            const validHandleResult = validator(handle);\n            if (distance <= minDistance) {\n                if (distance < minDistance) {\n                    closestHandles = [{ handle, validHandleResult }];\n                }\n                else if (distance === minDistance) {\n                    // when multiple handles are on the same distance we collect all of them\n                    closestHandles.push({\n                        handle,\n                        validHandleResult,\n                    });\n                }\n                minDistance = distance;\n            }\n        }\n    });\n    if (!closestHandles.length) {\n        return { handle: null, validHandleResult: defaultResult() };\n    }\n    if (closestHandles.length === 1) {\n        return closestHandles[0];\n    }\n    const hasValidHandle = closestHandles.some(({ validHandleResult }) => validHandleResult.isValid);\n    const hasTargetHandle = closestHandles.some(({ handle }) => handle.type === 'target');\n    // if multiple handles are layouted on top of each other we prefer the one with type = target and the one that is valid\n    return (closestHandles.find(({ handle, validHandleResult }) => hasTargetHandle ? handle.type === 'target' : (hasValidHandle ? validHandleResult.isValid : true)) || closestHandles[0]);\n}\nconst nullConnection = { source: null, target: null, sourceHandle: null, targetHandle: null };\nconst defaultResult = () => ({\n    handleDomNode: null,\n    isValid: false,\n    connection: nullConnection,\n    endHandle: null,\n});\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(handle, connectionMode, fromNodeId, fromHandleId, fromType, isValidConnection, doc) {\n    const isTarget = fromType === 'target';\n    const handleToCheck = doc.querySelector(`.react-flow__handle[data-id=\"${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`);\n    const result = {\n        ...defaultResult(),\n        handleDomNode: handleToCheck,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        if (isValid) {\n            result.endHandle = {\n                nodeId: handleNodeId,\n                handleId,\n                type: handleType,\n            };\n            result.isValid = isValidConnection(connection);\n        }\n    }\n    return result;\n}\nfunction getHandleLookup({ nodes, nodeId, handleId, handleType }) {\n    return nodes.reduce((res, node) => {\n        if (node[internalsSymbol]) {\n            const { handleBounds } = node[internalsSymbol];\n            let sourceHandles = [];\n            let targetHandles = [];\n            if (handleBounds) {\n                sourceHandles = getHandles(node, handleBounds, 'source', `${nodeId}-${handleId}-${handleType}`);\n                targetHandles = getHandles(node, handleBounds, 'target', `${nodeId}-${handleId}-${handleType}`);\n            }\n            res.push(...sourceHandles, ...targetHandles);\n        }\n        return res;\n    }, []);\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction resetRecentHandle(handleDomNode) {\n    handleDomNode?.classList.remove('valid', 'connecting', 'react-flow__handle-valid', 'react-flow__handle-connecting');\n}\nfunction getConnectionStatus(isInsideConnectionRadius, isHandleValid) {\n    let connectionStatus = null;\n    if (isHandleValid) {\n        connectionStatus = 'valid';\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        connectionStatus = 'invalid';\n    }\n    return connectionStatus;\n}\n\nfunction handlePointerDown({ event, handleId, nodeId, onConnect, isTarget, getState, setState, isValidConnection, edgeUpdaterType, onEdgeUpdateEnd, }) {\n    // when react-flow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    const { connectionMode, domNode, autoPanOnConnect, connectionRadius, onConnectStart, panBy, getNodes, cancelConnection, } = getState();\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const clickedHandle = doc?.elementFromPoint(x, y);\n    const handleType = getHandleType(edgeUpdaterType, clickedHandle);\n    const containerBounds = domNode?.getBoundingClientRect();\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    let prevActiveHandle;\n    let connectionPosition = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let handleDomNode = null;\n    const handleLookup = getHandleLookup({\n        nodes: getNodes(),\n        nodeId,\n        handleId,\n        handleType,\n    });\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    const autoPan = () => {\n        if (!autoPanOnConnect) {\n            return;\n        }\n        const [xMovement, yMovement] = calcAutoPan(connectionPosition, containerBounds);\n        panBy({ x: xMovement, y: yMovement });\n        autoPanId = requestAnimationFrame(autoPan);\n    };\n    setState({\n        connectionPosition,\n        connectionStatus: null,\n        // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle\n        connectionNodeId: nodeId,\n        connectionHandleId: handleId,\n        connectionHandleType: handleType,\n        connectionStartHandle: {\n            nodeId,\n            handleId,\n            type: handleType,\n        },\n        connectionEndHandle: null,\n    });\n    onConnectStart?.(event, { nodeId, handleId, handleType });\n    function onPointerMove(event) {\n        const { transform } = getState();\n        connectionPosition = getEventPosition(event, containerBounds);\n        const { handle, validHandleResult } = getClosestHandle(event, doc, pointToRendererPoint(connectionPosition, transform, false, [1, 1]), connectionRadius, handleLookup, (handle) => isValidHandle(handle, connectionMode, nodeId, handleId, isTarget ? 'target' : 'source', isValidConnection, doc));\n        closestHandle = handle;\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        handleDomNode = validHandleResult.handleDomNode;\n        connection = validHandleResult.connection;\n        isValid = validHandleResult.isValid;\n        setState({\n            connectionPosition: closestHandle && isValid\n                ? rendererPointToPoint({\n                    x: closestHandle.x,\n                    y: closestHandle.y,\n                }, transform)\n                : connectionPosition,\n            connectionStatus: getConnectionStatus(!!closestHandle, isValid),\n            connectionEndHandle: validHandleResult.endHandle,\n        });\n        if (!closestHandle && !isValid && !handleDomNode) {\n            return resetRecentHandle(prevActiveHandle);\n        }\n        if (connection.source !== connection.target && handleDomNode) {\n            resetRecentHandle(prevActiveHandle);\n            prevActiveHandle = handleDomNode;\n            // @todo: remove the old class names \"react-flow__handle-\" in the next major version\n            handleDomNode.classList.add('connecting', 'react-flow__handle-connecting');\n            handleDomNode.classList.toggle('valid', isValid);\n            handleDomNode.classList.toggle('react-flow__handle-valid', isValid);\n        }\n    }\n    function onPointerUp(event) {\n        if ((closestHandle || handleDomNode) && connection && isValid) {\n            onConnect?.(connection);\n        }\n        // it's important to get a fresh reference from the store here\n        // in order to get the latest state of onConnectEnd\n        getState().onConnectEnd?.(event);\n        if (edgeUpdaterType) {\n            onEdgeUpdateEnd?.(event);\n        }\n        resetRecentHandle(prevActiveHandle);\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        handleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n\nconst alwaysValid = () => true;\nconst selector$f = (s) => ({\n    connectionStartHandle: s.connectionStartHandle,\n    connectOnClick: s.connectOnClick,\n    noPanClassName: s.noPanClassName,\n});\nconst connectingSelector = (nodeId, handleId, type) => (state) => {\n    const { connectionStartHandle: startHandle, connectionEndHandle: endHandle, connectionClickStartHandle: clickHandle, } = state;\n    return {\n        connecting: (startHandle?.nodeId === nodeId && startHandle?.handleId === handleId && startHandle?.type === type) ||\n            (endHandle?.nodeId === nodeId && endHandle?.handleId === handleId && endHandle?.type === type),\n        clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.handleId === handleId && clickHandle?.type === type,\n    };\n};\nconst Handle = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ type = 'source', position = Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) => {\n    const handleId = id || null;\n    const isTarget = type === 'target';\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const { connecting, clickConnecting } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.('010', errorMessages['error010']());\n    }\n    const onConnectExtended = (params) => {\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params,\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges(addEdge(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event) => {\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = isMouseEvent(event);\n        if (isConnectableStart && ((isMouseTriggered && event.button === 0) || !isMouseTriggered)) {\n            handlePointerDown({\n                event,\n                handleId,\n                nodeId,\n                onConnect: onConnectExtended,\n                isTarget,\n                getState: store.getState,\n                setState: store.setState,\n                isValidConnection: isValidConnection || store.getState().isValidConnection || alwaysValid,\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        }\n        else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event) => {\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, } = store.getState();\n        if (!nodeId || (!connectionClickStartHandle && !isConnectableStart)) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event, { nodeId, handleId, handleType: type });\n            store.setState({ connectionClickStartHandle: { nodeId, type, handleId } });\n            return;\n        }\n        const doc = getHostForElement(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore || alwaysValid;\n        const { connection, isValid } = isValidHandle({\n            nodeId,\n            id: handleId,\n            type,\n        }, connectionMode, connectionClickStartHandle.nodeId, connectionClickStartHandle.handleId || null, connectionClickStartHandle.type, isValidConnectionHandler, doc);\n        if (isValid) {\n            onConnectExtended(connection);\n        }\n        onClickConnectEnd?.(event);\n        store.setState({ connectionClickStartHandle: null });\n    };\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { \"data-handleid\": handleId, \"data-nodeid\": nodeId, \"data-handlepos\": position, \"data-id\": `${nodeId}-${handleId}-${type}`, className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__handle',\n            `react-flow__handle-${position}`,\n            'nodrag',\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                connecting: clickConnecting,\n                // this class is used to style the handle when the user is connecting\n                connectionindicator: isConnectable && ((isConnectableStart && !connecting) || (isConnectableEnd && connecting)),\n            },\n        ]), onMouseDown: onPointerDown, onTouchStart: onPointerDown, onClick: connectOnClick ? onClick : undefined, ref: ref, ...rest }, children));\n});\nHandle.displayName = 'Handle';\nvar Handle$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Handle);\n\nconst DefaultNode = ({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom, }) => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, { type: \"target\", position: targetPosition, isConnectable: isConnectable }),\n        data?.label,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, { type: \"source\", position: sourcePosition, isConnectable: isConnectable })));\n};\nDefaultNode.displayName = 'DefaultNode';\nvar DefaultNode$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(DefaultNode);\n\nconst InputNode = ({ data, isConnectable, sourcePosition = Position.Bottom }) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n    data?.label,\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, { type: \"source\", position: sourcePosition, isConnectable: isConnectable })));\nInputNode.displayName = 'InputNode';\nvar InputNode$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(InputNode);\n\nconst OutputNode = ({ data, isConnectable, targetPosition = Position.Top }) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, { type: \"target\", position: targetPosition, isConnectable: isConnectable }),\n    data?.label));\nOutputNode.displayName = 'OutputNode';\nvar OutputNode$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(OutputNode);\n\nconst GroupNode = () => null;\nGroupNode.displayName = 'GroupNode';\n\nconst selector$e = (s) => ({\n    selectedNodes: s.getNodes().filter((n) => n.selected),\n    selectedEdges: s.edges.filter((e) => e.selected),\n});\nconst selectId = (obj) => obj.id;\nfunction areEqual(a, b) {\n    return ((0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) &&\n        (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId)));\n}\n// This is just a helper component for calling the onSelectionChange listener.\n// @TODO: Now that we have the onNodesChange and on EdgesChange listeners, do we still need this component?\nconst SelectionListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ onSelectionChange }) => {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$e, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const params = { nodes: selectedNodes, edges: selectedEdges };\n        onSelectionChange?.(params);\n        store.getState().onSelectionChange?.(params);\n    }, [selectedNodes, selectedEdges, onSelectionChange]);\n    return null;\n});\nSelectionListener.displayName = 'SelectionListener';\nconst changeSelector = (s) => !!s.onSelectionChange;\nfunction Wrapper$1({ onSelectionChange }) {\n    const storeHasSelectionChange = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChange) {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SelectionListener, { onSelectionChange: onSelectionChange });\n    }\n    return null;\n}\n\nconst selector$d = (s) => ({\n    setNodes: s.setNodes,\n    setEdges: s.setEdges,\n    setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n    setMinZoom: s.setMinZoom,\n    setMaxZoom: s.setMaxZoom,\n    setTranslateExtent: s.setTranslateExtent,\n    setNodeExtent: s.setNodeExtent,\n    reset: s.reset,\n});\nfunction useStoreUpdater(value, setStoreState) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (typeof value !== 'undefined') {\n            setStoreState(value);\n        }\n    }, [value]);\n}\n// updates with values in store that don't have a dedicated setter function\nfunction useDirectStoreUpdater(key, value, setState) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (typeof value !== 'undefined') {\n            setState({ [key]: value });\n        }\n    }, [value]);\n}\nconst StoreUpdater = ({ nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesUpdatable, elevateNodesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, elementsSelectable, connectionMode, snapGrid, snapToGrid, translateExtent, connectOnClick, defaultEdgeOptions, fitView, fitViewOptions, onNodesDelete, onEdgesDelete, onNodeDrag, onNodeDragStart, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, onError, connectionRadius, isValidConnection, nodeDragThreshold, }) => {\n    const { setNodes, setEdges, setDefaultNodesAndEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, } = useStore(selector$d, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const edgesWithDefaults = defaultEdges?.map((e) => ({ ...e, ...defaultEdgeOptions }));\n        setDefaultNodesAndEdges(defaultNodes, edgesWithDefaults);\n        return () => {\n            reset();\n        };\n    }, []);\n    useDirectStoreUpdater('defaultEdgeOptions', defaultEdgeOptions, store.setState);\n    useDirectStoreUpdater('connectionMode', connectionMode, store.setState);\n    useDirectStoreUpdater('onConnect', onConnect, store.setState);\n    useDirectStoreUpdater('onConnectStart', onConnectStart, store.setState);\n    useDirectStoreUpdater('onConnectEnd', onConnectEnd, store.setState);\n    useDirectStoreUpdater('onClickConnectStart', onClickConnectStart, store.setState);\n    useDirectStoreUpdater('onClickConnectEnd', onClickConnectEnd, store.setState);\n    useDirectStoreUpdater('nodesDraggable', nodesDraggable, store.setState);\n    useDirectStoreUpdater('nodesConnectable', nodesConnectable, store.setState);\n    useDirectStoreUpdater('nodesFocusable', nodesFocusable, store.setState);\n    useDirectStoreUpdater('edgesFocusable', edgesFocusable, store.setState);\n    useDirectStoreUpdater('edgesUpdatable', edgesUpdatable, store.setState);\n    useDirectStoreUpdater('elementsSelectable', elementsSelectable, store.setState);\n    useDirectStoreUpdater('elevateNodesOnSelect', elevateNodesOnSelect, store.setState);\n    useDirectStoreUpdater('snapToGrid', snapToGrid, store.setState);\n    useDirectStoreUpdater('snapGrid', snapGrid, store.setState);\n    useDirectStoreUpdater('onNodesChange', onNodesChange, store.setState);\n    useDirectStoreUpdater('onEdgesChange', onEdgesChange, store.setState);\n    useDirectStoreUpdater('connectOnClick', connectOnClick, store.setState);\n    useDirectStoreUpdater('fitViewOnInit', fitView, store.setState);\n    useDirectStoreUpdater('fitViewOnInitOptions', fitViewOptions, store.setState);\n    useDirectStoreUpdater('onNodesDelete', onNodesDelete, store.setState);\n    useDirectStoreUpdater('onEdgesDelete', onEdgesDelete, store.setState);\n    useDirectStoreUpdater('onNodeDrag', onNodeDrag, store.setState);\n    useDirectStoreUpdater('onNodeDragStart', onNodeDragStart, store.setState);\n    useDirectStoreUpdater('onNodeDragStop', onNodeDragStop, store.setState);\n    useDirectStoreUpdater('onSelectionDrag', onSelectionDrag, store.setState);\n    useDirectStoreUpdater('onSelectionDragStart', onSelectionDragStart, store.setState);\n    useDirectStoreUpdater('onSelectionDragStop', onSelectionDragStop, store.setState);\n    useDirectStoreUpdater('noPanClassName', noPanClassName, store.setState);\n    useDirectStoreUpdater('nodeOrigin', nodeOrigin, store.setState);\n    useDirectStoreUpdater('rfId', rfId, store.setState);\n    useDirectStoreUpdater('autoPanOnConnect', autoPanOnConnect, store.setState);\n    useDirectStoreUpdater('autoPanOnNodeDrag', autoPanOnNodeDrag, store.setState);\n    useDirectStoreUpdater('onError', onError, store.setState);\n    useDirectStoreUpdater('connectionRadius', connectionRadius, store.setState);\n    useDirectStoreUpdater('isValidConnection', isValidConnection, store.setState);\n    useDirectStoreUpdater('nodeDragThreshold', nodeDragThreshold, store.setState);\n    useStoreUpdater(nodes, setNodes);\n    useStoreUpdater(edges, setEdges);\n    useStoreUpdater(minZoom, setMinZoom);\n    useStoreUpdater(maxZoom, setMaxZoom);\n    useStoreUpdater(translateExtent, setTranslateExtent);\n    useStoreUpdater(nodeExtent, setNodeExtent);\n    return null;\n};\n\nconst style = { display: 'none' };\nconst ariaLiveStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: 'hidden',\n    clip: 'rect(0px, 0px, 0px, 0px)',\n    clipPath: 'inset(100%)',\n};\nconst ARIA_NODE_DESC_KEY = 'react-flow__node-desc';\nconst ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';\nconst ARIA_LIVE_MESSAGE = 'react-flow__aria-live';\nconst selector$c = (s) => s.ariaLiveMessage;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(selector$c);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: `${ARIA_LIVE_MESSAGE}-${rfId}`, \"aria-live\": \"assertive\", \"aria-atomic\": \"true\", style: ariaLiveStyle }, ariaLiveMessage));\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: `${ARIA_NODE_DESC_KEY}-${rfId}`, style: style },\n            \"Press enter or space to select a node.\",\n            !disableKeyboardA11y && 'You can then use the arrow keys to move the node around.',\n            \" Press delete to remove it and escape to cancel.\",\n            ' '),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: `${ARIA_EDGE_DESC_KEY}-${rfId}`, style: style }, \"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.\"),\n        !disableKeyboardA11y && react__WEBPACK_IMPORTED_MODULE_0__.createElement(AriaLiveMessage, { rfId: rfId })));\n}\n\n// the keycode can be a string 'a' or an array of strings ['a', 'a+d']\n// a string means a single key 'a' or a combination when '+' is used 'a+d'\n// an array means different possibilities. Explainer: ['a', 'd+s'] here the\n// user can use the single key 'a' or the combination 'd' + 's'\nvar useKeyPress = (keyCode = null, options = { actInsideInputWithModifier: true }) => {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Set([]));\n    // keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n    // keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n    // used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n    // we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n    // and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n    // we can't find it in the list of keysToWatch.\n    const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (keyCode !== null) {\n            const keyCodeArr = Array.isArray(keyCode) ? keyCode : [keyCode];\n            const keys = keyCodeArr.filter((kc) => typeof kc === 'string').map((kc) => kc.split('+'));\n            const keysFlat = keys.reduce((res, item) => res.concat(...item), []);\n            return [keys, keysFlat];\n        }\n        return [[], []];\n    }, [keyCode]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const doc = typeof document !== 'undefined' ? document : null;\n        const target = options?.target || doc;\n        if (keyCode !== null) {\n            const downHandler = (event) => {\n                modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;\n                const preventAction = (!modifierPressed.current || (modifierPressed.current && !options.actInsideInputWithModifier)) &&\n                    isInputDOMNode(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                pressedKeys.current.add(event[keyOrCode]);\n                if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                    event.preventDefault();\n                    setKeyPressed(true);\n                }\n            };\n            const upHandler = (event) => {\n                const preventAction = (!modifierPressed.current || (modifierPressed.current && !options.actInsideInputWithModifier)) &&\n                    isInputDOMNode(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                    setKeyPressed(false);\n                    pressedKeys.current.clear();\n                }\n                else {\n                    pressedKeys.current.delete(event[keyOrCode]);\n                }\n                // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                if (event.key === 'Meta') {\n                    pressedKeys.current.clear();\n                }\n                modifierPressed.current = false;\n            };\n            const resetHandler = () => {\n                pressedKeys.current.clear();\n                setKeyPressed(false);\n            };\n            target?.addEventListener('keydown', downHandler);\n            target?.addEventListener('keyup', upHandler);\n            window.addEventListener('blur', resetHandler);\n            return () => {\n                target?.removeEventListener('keydown', downHandler);\n                target?.removeEventListener('keyup', upHandler);\n                window.removeEventListener('blur', resetHandler);\n            };\n        }\n    }, [keyCode, setKeyPressed]);\n    return keyPressed;\n};\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return (keyCodes\n        // we only want to compare same sizes of keyCode definitions\n        // and pressed keys. When the user specified 'Meta' as a key somewhere\n        // this would also be truthy without this filter when user presses 'Meta' + 'r'\n        .filter((keys) => isUp || keys.length === pressedKeys.size)\n        // since we want to support multiple possibilities only one of the\n        // combinations need to be part of the pressed keys\n        .some((keys) => keys.every((k) => pressedKeys.has(k))));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? 'code' : 'key';\n}\n\nfunction calculateXYZPosition(node, nodeInternals, result, nodeOrigin) {\n    if (!node.parentNode) {\n        return result;\n    }\n    const parentNode = nodeInternals.get(node.parentNode);\n    const parentNodePosition = getNodePositionWithOrigin(parentNode, nodeOrigin);\n    return calculateXYZPosition(parentNode, nodeInternals, {\n        x: (result.x ?? 0) + parentNodePosition.x,\n        y: (result.y ?? 0) + parentNodePosition.y,\n        z: (parentNode[internalsSymbol]?.z ?? 0) > (result.z ?? 0) ? parentNode[internalsSymbol]?.z ?? 0 : result.z ?? 0,\n    }, nodeOrigin);\n}\nfunction updateAbsoluteNodePositions(nodeInternals, nodeOrigin, parentNodes) {\n    nodeInternals.forEach((node) => {\n        if (node.parentNode && !nodeInternals.has(node.parentNode)) {\n            throw new Error(`Parent node ${node.parentNode} not found`);\n        }\n        if (node.parentNode || parentNodes?.[node.id]) {\n            const { x, y, z } = calculateXYZPosition(node, nodeInternals, {\n                ...node.position,\n                z: node[internalsSymbol]?.z ?? 0,\n            }, nodeOrigin);\n            node.positionAbsolute = {\n                x,\n                y,\n            };\n            node[internalsSymbol].z = z;\n            if (parentNodes?.[node.id]) {\n                node[internalsSymbol].isParent = true;\n            }\n        }\n    });\n}\nfunction createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) {\n    const nextNodeInternals = new Map();\n    const parentNodes = {};\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    nodes.forEach((node) => {\n        const z = (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n        const currInternals = nodeInternals.get(node.id);\n        const internals = {\n            width: currInternals?.width,\n            height: currInternals?.height,\n            ...node,\n            positionAbsolute: {\n                x: node.position.x,\n                y: node.position.y,\n            },\n        };\n        if (node.parentNode) {\n            internals.parentNode = node.parentNode;\n            parentNodes[node.parentNode] = true;\n        }\n        Object.defineProperty(internals, internalsSymbol, {\n            enumerable: false,\n            value: {\n                handleBounds: currInternals?.[internalsSymbol]?.handleBounds,\n                z,\n            },\n        });\n        nextNodeInternals.set(node.id, internals);\n    });\n    updateAbsoluteNodePositions(nextNodeInternals, nodeOrigin, parentNodes);\n    return nextNodeInternals;\n}\nfunction fitView(get, options = {}) {\n    const { getNodes, width, height, minZoom, maxZoom, d3Zoom, d3Selection, fitViewOnInitDone, fitViewOnInit, nodeOrigin, } = get();\n    const isInitialFitView = options.initial && !fitViewOnInitDone && fitViewOnInit;\n    const d3initialized = d3Zoom && d3Selection;\n    if (d3initialized && (isInitialFitView || !options.initial)) {\n        const nodes = getNodes().filter((n) => {\n            const isVisible = options.includeHiddenNodes ? n.width && n.height : !n.hidden;\n            if (options.nodes?.length) {\n                return isVisible && options.nodes.some((optionNode) => optionNode.id === n.id);\n            }\n            return isVisible;\n        });\n        const nodesInitialized = nodes.every((n) => n.width && n.height);\n        if (nodes.length > 0 && nodesInitialized) {\n            const bounds = getRectOfNodes(nodes, nodeOrigin);\n            const [x, y, zoom] = getTransformForBounds(bounds, width, height, options.minZoom ?? minZoom, options.maxZoom ?? maxZoom, options.padding ?? 0.1);\n            const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(x, y).scale(zoom);\n            if (typeof options.duration === 'number' && options.duration > 0) {\n                d3Zoom.transform(getD3Transition(d3Selection, options.duration), nextTransform);\n            }\n            else {\n                d3Zoom.transform(d3Selection, nextTransform);\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction handleControlledNodeSelectionChange(nodeChanges, nodeInternals) {\n    nodeChanges.forEach((change) => {\n        const node = nodeInternals.get(change.id);\n        if (node) {\n            nodeInternals.set(node.id, {\n                ...node,\n                [internalsSymbol]: node[internalsSymbol],\n                selected: change.selected,\n            });\n        }\n    });\n    return new Map(nodeInternals);\n}\nfunction handleControlledEdgeSelectionChange(edgeChanges, edges) {\n    return edges.map((e) => {\n        const change = edgeChanges.find((change) => change.id === e.id);\n        if (change) {\n            e.selected = change.selected;\n        }\n        return e;\n    });\n}\nfunction updateNodesAndEdgesSelections({ changedNodes, changedEdges, get, set }) {\n    const { nodeInternals, edges, onNodesChange, onEdgesChange, hasDefaultNodes, hasDefaultEdges } = get();\n    if (changedNodes?.length) {\n        if (hasDefaultNodes) {\n            set({ nodeInternals: handleControlledNodeSelectionChange(changedNodes, nodeInternals) });\n        }\n        onNodesChange?.(changedNodes);\n    }\n    if (changedEdges?.length) {\n        if (hasDefaultEdges) {\n            set({ edges: handleControlledEdgeSelectionChange(changedEdges, edges) });\n        }\n        onEdgesChange?.(changedEdges);\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => { };\nconst initialViewportHelper = {\n    zoomIn: noop,\n    zoomOut: noop,\n    zoomTo: noop,\n    getZoom: () => 1,\n    setViewport: noop,\n    getViewport: () => ({ x: 0, y: 0, zoom: 1 }),\n    fitView: () => false,\n    setCenter: noop,\n    fitBounds: noop,\n    project: (position) => position,\n    viewportInitialized: false,\n};\nconst selector$b = (s) => ({\n    d3Zoom: s.d3Zoom,\n    d3Selection: s.d3Selection,\n});\nconst useViewportHelper = () => {\n    const store = useStoreApi();\n    const { d3Zoom, d3Selection } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const viewportHelperFunctions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (d3Selection && d3Zoom) {\n            return {\n                zoomIn: (options) => d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1.2),\n                zoomOut: (options) => d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1 / 1.2),\n                zoomTo: (zoomLevel, options) => d3Zoom.scaleTo(getD3Transition(d3Selection, options?.duration), zoomLevel),\n                getZoom: () => store.getState().transform[2],\n                setViewport: (transform, options) => {\n                    const [x, y, zoom] = store.getState().transform;\n                    const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity\n                        .translate(transform.x ?? x, transform.y ?? y)\n                        .scale(transform.zoom ?? zoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), nextTransform);\n                },\n                getViewport: () => {\n                    const [x, y, zoom] = store.getState().transform;\n                    return { x, y, zoom };\n                },\n                fitView: (options) => fitView(store.getState, options),\n                setCenter: (x, y, options) => {\n                    const { width, height, maxZoom } = store.getState();\n                    const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;\n                    const centerX = width / 2 - x * nextZoom;\n                    const centerY = height / 2 - y * nextZoom;\n                    const transform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(centerX, centerY).scale(nextZoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);\n                },\n                fitBounds: (bounds, options) => {\n                    const { width, height, minZoom, maxZoom } = store.getState();\n                    const [x, y, zoom] = getTransformForBounds(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                    const transform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(x, y).scale(zoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);\n                },\n                project: (position) => {\n                    const { transform, snapToGrid, snapGrid } = store.getState();\n                    return pointToRendererPoint(position, transform, snapToGrid, snapGrid);\n                },\n                viewportInitialized: true,\n            };\n        }\n        return initialViewportHelper;\n    }, [d3Zoom, d3Selection]);\n    return viewportHelperFunctions;\n};\n\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nfunction useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const getNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        return store\n            .getState()\n            .getNodes()\n            .map((n) => ({ ...n }));\n    }, []);\n    const getNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n        return store.getState().nodeInternals.get(id);\n    }, []);\n    const getEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        const { edges = [] } = store.getState();\n        return edges.map((e) => ({ ...e }));\n    }, []);\n    const getEdge = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n        const { edges = [] } = store.getState();\n        return edges.find((e) => e.id === id);\n    }, []);\n    const setNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload) => {\n        const { getNodes, setNodes, hasDefaultNodes, onNodesChange } = store.getState();\n        const nodes = getNodes();\n        const nextNodes = typeof payload === 'function' ? payload(nodes) : payload;\n        if (hasDefaultNodes) {\n            setNodes(nextNodes);\n        }\n        else if (onNodesChange) {\n            const changes = nextNodes.length === 0\n                ? nodes.map((node) => ({ type: 'remove', id: node.id }))\n                : nextNodes.map((node) => ({ item: node, type: 'reset' }));\n            onNodesChange(changes);\n        }\n    }, []);\n    const setEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload) => {\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange } = store.getState();\n        const nextEdges = typeof payload === 'function' ? payload(edges) : payload;\n        if (hasDefaultEdges) {\n            setEdges(nextEdges);\n        }\n        else if (onEdgesChange) {\n            const changes = nextEdges.length === 0\n                ? edges.map((edge) => ({ type: 'remove', id: edge.id }))\n                : nextEdges.map((edge) => ({ item: edge, type: 'reset' }));\n            onEdgesChange(changes);\n        }\n    }, []);\n    const addNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload) => {\n        const nodes = Array.isArray(payload) ? payload : [payload];\n        const { getNodes, setNodes, hasDefaultNodes, onNodesChange } = store.getState();\n        if (hasDefaultNodes) {\n            const currentNodes = getNodes();\n            const nextNodes = [...currentNodes, ...nodes];\n            setNodes(nextNodes);\n        }\n        else if (onNodesChange) {\n            const changes = nodes.map((node) => ({ item: node, type: 'add' }));\n            onNodesChange(changes);\n        }\n    }, []);\n    const addEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload) => {\n        const nextEdges = Array.isArray(payload) ? payload : [payload];\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange } = store.getState();\n        if (hasDefaultEdges) {\n            setEdges([...edges, ...nextEdges]);\n        }\n        else if (onEdgesChange) {\n            const changes = nextEdges.map((edge) => ({ item: edge, type: 'add' }));\n            onEdgesChange(changes);\n        }\n    }, []);\n    const toObject = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        const { getNodes, edges = [], transform } = store.getState();\n        const [x, y, zoom] = transform;\n        return {\n            nodes: getNodes().map((n) => ({ ...n })),\n            edges: edges.map((e) => ({ ...e })),\n            viewport: {\n                x,\n                y,\n                zoom,\n            },\n        };\n    }, []);\n    const deleteElements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ nodes: nodesDeleted, edges: edgesDeleted }) => {\n        const { nodeInternals, getNodes, edges, hasDefaultNodes, hasDefaultEdges, onNodesDelete, onEdgesDelete, onNodesChange, onEdgesChange, } = store.getState();\n        const nodeIds = (nodesDeleted || []).map((node) => node.id);\n        const edgeIds = (edgesDeleted || []).map((edge) => edge.id);\n        const nodesToRemove = getNodes().reduce((res, node) => {\n            const parentHit = !nodeIds.includes(node.id) && node.parentNode && res.find((n) => n.id === node.parentNode);\n            const deletable = typeof node.deletable === 'boolean' ? node.deletable : true;\n            if (deletable && (nodeIds.includes(node.id) || parentHit)) {\n                res.push(node);\n            }\n            return res;\n        }, []);\n        const deletableEdges = edges.filter((e) => (typeof e.deletable === 'boolean' ? e.deletable : true));\n        const initialHitEdges = deletableEdges.filter((e) => edgeIds.includes(e.id));\n        if (nodesToRemove || initialHitEdges) {\n            const connectedEdges = getConnectedEdges(nodesToRemove, deletableEdges);\n            const edgesToRemove = [...initialHitEdges, ...connectedEdges];\n            const edgeIdsToRemove = edgesToRemove.reduce((res, edge) => {\n                if (!res.includes(edge.id)) {\n                    res.push(edge.id);\n                }\n                return res;\n            }, []);\n            if (hasDefaultEdges || hasDefaultNodes) {\n                if (hasDefaultEdges) {\n                    store.setState({\n                        edges: edges.filter((e) => !edgeIdsToRemove.includes(e.id)),\n                    });\n                }\n                if (hasDefaultNodes) {\n                    nodesToRemove.forEach((node) => {\n                        nodeInternals.delete(node.id);\n                    });\n                    store.setState({\n                        nodeInternals: new Map(nodeInternals),\n                    });\n                }\n            }\n            if (edgeIdsToRemove.length > 0) {\n                onEdgesDelete?.(edgesToRemove);\n                if (onEdgesChange) {\n                    onEdgesChange(edgeIdsToRemove.map((id) => ({\n                        id,\n                        type: 'remove',\n                    })));\n                }\n            }\n            if (nodesToRemove.length > 0) {\n                onNodesDelete?.(nodesToRemove);\n                if (onNodesChange) {\n                    const nodeChanges = nodesToRemove.map((n) => ({ id: n.id, type: 'remove' }));\n                    onNodesChange(nodeChanges);\n                }\n            }\n        }\n    }, []);\n    const getNodeRect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect) => {\n        const isRect = isRectObject(nodeOrRect);\n        const node = isRect ? null : store.getState().nodeInternals.get(nodeOrRect.id);\n        const nodeRect = isRect ? nodeOrRect : nodeToRect(node);\n        return [nodeRect, node, isRect];\n    }, []);\n    const getIntersectingNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect, partially = true, nodes) => {\n        const [nodeRect, node, isRect] = getNodeRect(nodeOrRect);\n        if (!nodeRect) {\n            return [];\n        }\n        return (nodes || store.getState().getNodes()).filter((n) => {\n            if (!isRect && (n.id === node.id || !n.positionAbsolute)) {\n                return false;\n            }\n            const currNodeRect = nodeToRect(n);\n            const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);\n            const partiallyVisible = partially && overlappingArea > 0;\n            return partiallyVisible || overlappingArea >= nodeOrRect.width * nodeOrRect.height;\n        });\n    }, []);\n    const isNodeIntersecting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect, area, partially = true) => {\n        const [nodeRect] = getNodeRect(nodeOrRect);\n        if (!nodeRect) {\n            return false;\n        }\n        const overlappingArea = getOverlappingArea(nodeRect, area);\n        const partiallyVisible = partially && overlappingArea > 0;\n        return partiallyVisible || overlappingArea >= nodeOrRect.width * nodeOrRect.height;\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            ...viewportHelper,\n            getNodes,\n            getNode,\n            getEdges,\n            getEdge,\n            setNodes,\n            setEdges,\n            addNodes,\n            addEdges,\n            toObject,\n            deleteElements,\n            getIntersectingNodes,\n            isNodeIntersecting,\n        };\n    }, [\n        viewportHelper,\n        getNodes,\n        getNode,\n        getEdges,\n        getEdge,\n        setNodes,\n        setEdges,\n        addNodes,\n        addEdges,\n        toObject,\n        deleteElements,\n        getIntersectingNodes,\n        isNodeIntersecting,\n    ]);\n}\n\nconst deleteKeyOptions = { actInsideInputWithModifier: false };\nvar useGlobalKeyHandler = ({ deleteKeyCode, multiSelectionKeyCode }) => {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (deleteKeyPressed) {\n            const { edges, getNodes } = store.getState();\n            const selectedNodes = getNodes().filter((node) => node.selected);\n            const selectedEdges = edges.filter((edge) => edge.selected);\n            deleteElements({ nodes: selectedNodes, edges: selectedEdges });\n            store.setState({ nodesSelectionActive: false });\n        }\n    }, [deleteKeyPressed]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        store.setState({ multiSelectionActive: multiSelectionKeyPressed });\n    }, [multiSelectionKeyPressed]);\n};\n\nfunction useResizeHandler(rendererNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        let resizeObserver;\n        const updateDimensions = () => {\n            if (!rendererNode.current) {\n                return;\n            }\n            const size = getDimensions(rendererNode.current);\n            if (size.height === 0 || size.width === 0) {\n                store.getState().onError?.('004', errorMessages['error004']());\n            }\n            store.setState({ width: size.width || 500, height: size.height || 500 });\n        };\n        updateDimensions();\n        window.addEventListener('resize', updateDimensions);\n        if (rendererNode.current) {\n            resizeObserver = new ResizeObserver(() => updateDimensions());\n            resizeObserver.observe(rendererNode.current);\n        }\n        return () => {\n            window.removeEventListener('resize', updateDimensions);\n            if (resizeObserver && rendererNode.current) {\n                resizeObserver.unobserve(rendererNode.current);\n            }\n        };\n    }, []);\n}\n\nconst containerStyle = {\n    position: 'absolute',\n    width: '100%',\n    height: '100%',\n    top: 0,\n    left: 0,\n};\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nconst viewChanged = (prevViewport, eventTransform) => prevViewport.x !== eventTransform.x || prevViewport.y !== eventTransform.y || prevViewport.zoom !== eventTransform.k;\nconst eventToFlowTransform = (eventTransform) => ({\n    x: eventTransform.x,\n    y: eventTransform.y,\n    zoom: eventTransform.k,\n});\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\nconst selector$a = (s) => ({\n    d3Zoom: s.d3Zoom,\n    d3Selection: s.d3Selection,\n    d3ZoomHandler: s.d3ZoomHandler,\n    userSelectionActive: s.userSelectionActive,\n});\nconst ZoomPane = ({ onMove, onMoveStart, onMoveEnd, onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, elementsSelectable, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, }) => {\n    const timerId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const store = useStoreApi();\n    const isZoomingOrPanning = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const zoomedWithRightMouseButton = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const prevTransform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ x: 0, y: 0, zoom: 0 });\n    const { d3Zoom, d3Selection, d3ZoomHandler, userSelectionActive } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const mouseButton = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const isPanScrolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const panScrollTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    useResizeHandler(zoomPane);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (zoomPane.current) {\n            const bbox = zoomPane.current.getBoundingClientRect();\n            const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoom)().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);\n            const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zoomPane.current).call(d3ZoomInstance);\n            const updatedTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity\n                .translate(defaultViewport.x, defaultViewport.y)\n                .scale(clamp(defaultViewport.zoom, minZoom, maxZoom));\n            const extent = [\n                [0, 0],\n                [bbox.width, bbox.height],\n            ];\n            const constrainedTransform = d3ZoomInstance.constrain()(updatedTransform, extent, translateExtent);\n            d3ZoomInstance.transform(selection, constrainedTransform);\n            d3ZoomInstance.wheelDelta(wheelDelta);\n            store.setState({\n                d3Zoom: d3ZoomInstance,\n                d3Selection: selection,\n                d3ZoomHandler: selection.on('wheel.zoom'),\n                // we need to pass transform because zoom handler is not registered when we set the initial transform\n                transform: [constrainedTransform.x, constrainedTransform.y, constrainedTransform.k],\n                domNode: zoomPane.current.closest('.react-flow'),\n            });\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (d3Selection && d3Zoom) {\n            if (panOnScroll && !zoomActivationKeyPressed && !userSelectionActive) {\n                d3Selection.on('wheel.zoom', (event) => {\n                    if (isWrappedWithClass(event, noWheelClassName)) {\n                        return false;\n                    }\n                    event.preventDefault();\n                    event.stopImmediatePropagation();\n                    const currentZoom = d3Selection.property('__zoom').k || 1;\n                    const _isMacOs = isMacOs();\n                    // macos sets ctrlKey=true for pinch gesture on a trackpad\n                    if (event.ctrlKey && zoomOnPinch && _isMacOs) {\n                        const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(event);\n                        const pinchDelta = wheelDelta(event);\n                        const zoom = currentZoom * Math.pow(2, pinchDelta);\n                        // @ts-ignore\n                        d3Zoom.scaleTo(d3Selection, zoom, point, event);\n                        return;\n                    }\n                    // increase scroll speed in firefox\n                    // firefox: deltaMode === 1; chrome: deltaMode === 0\n                    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n                    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n                    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n                    // this enables vertical scrolling with shift + scroll on windows\n                    if (!_isMacOs && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n                        deltaX = event.deltaY * deltaNormalize;\n                        deltaY = 0;\n                    }\n                    d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n                    // @ts-ignore\n                    { internal: true });\n                    const nextViewport = eventToFlowTransform(d3Selection.property('__zoom'));\n                    const { onViewportChangeStart, onViewportChange, onViewportChangeEnd } = store.getState();\n                    clearTimeout(panScrollTimeout.current);\n                    // for pan on scroll we need to handle the event calls on our own\n                    // we can't use the start, zoom and end events from d3-zoom\n                    // because start and move gets called on every scroll event and not once at the beginning\n                    if (!isPanScrolling.current) {\n                        isPanScrolling.current = true;\n                        onMoveStart?.(event, nextViewport);\n                        onViewportChangeStart?.(nextViewport);\n                    }\n                    if (isPanScrolling.current) {\n                        onMove?.(event, nextViewport);\n                        onViewportChange?.(nextViewport);\n                        panScrollTimeout.current = setTimeout(() => {\n                            onMoveEnd?.(event, nextViewport);\n                            onViewportChangeEnd?.(nextViewport);\n                            isPanScrolling.current = false;\n                        }, 150);\n                    }\n                }, { passive: false });\n            }\n            else if (typeof d3ZoomHandler !== 'undefined') {\n                d3Selection.on('wheel.zoom', function (event, d) {\n                    if (!preventScrolling || isWrappedWithClass(event, noWheelClassName)) {\n                        return null;\n                    }\n                    event.preventDefault();\n                    d3ZoomHandler.call(this, event, d);\n                }, { passive: false });\n            }\n        }\n    }, [\n        userSelectionActive,\n        panOnScroll,\n        panOnScrollMode,\n        d3Selection,\n        d3Zoom,\n        d3ZoomHandler,\n        zoomActivationKeyPressed,\n        zoomOnPinch,\n        preventScrolling,\n        noWheelClassName,\n        onMoveStart,\n        onMove,\n        onMoveEnd,\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (d3Zoom) {\n            d3Zoom.on('start', (event) => {\n                if (!event.sourceEvent || event.sourceEvent.internal) {\n                    return null;\n                }\n                // we need to remember it here, because it's always 0 in the \"zoom\" event\n                mouseButton.current = event.sourceEvent?.button;\n                const { onViewportChangeStart } = store.getState();\n                const flowTransform = eventToFlowTransform(event.transform);\n                isZoomingOrPanning.current = true;\n                prevTransform.current = flowTransform;\n                if (event.sourceEvent?.type === 'mousedown') {\n                    store.setState({ paneDragging: true });\n                }\n                onViewportChangeStart?.(flowTransform);\n                onMoveStart?.(event.sourceEvent, flowTransform);\n            });\n        }\n    }, [d3Zoom, onMoveStart]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (d3Zoom) {\n            if (userSelectionActive && !isZoomingOrPanning.current) {\n                d3Zoom.on('zoom', null);\n            }\n            else if (!userSelectionActive) {\n                d3Zoom.on('zoom', (event) => {\n                    const { onViewportChange } = store.getState();\n                    store.setState({ transform: [event.transform.x, event.transform.y, event.transform.k] });\n                    zoomedWithRightMouseButton.current = !!(onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0));\n                    if ((onMove || onViewportChange) && !event.sourceEvent?.internal) {\n                        const flowTransform = eventToFlowTransform(event.transform);\n                        onViewportChange?.(flowTransform);\n                        onMove?.(event.sourceEvent, flowTransform);\n                    }\n                });\n            }\n        }\n    }, [userSelectionActive, d3Zoom, onMove, panOnDrag, onPaneContextMenu]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (d3Zoom) {\n            d3Zoom.on('end', (event) => {\n                if (!event.sourceEvent || event.sourceEvent.internal) {\n                    return null;\n                }\n                const { onViewportChangeEnd } = store.getState();\n                isZoomingOrPanning.current = false;\n                store.setState({ paneDragging: false });\n                if (onPaneContextMenu &&\n                    isRightClickPan(panOnDrag, mouseButton.current ?? 0) &&\n                    !zoomedWithRightMouseButton.current) {\n                    onPaneContextMenu(event.sourceEvent);\n                }\n                zoomedWithRightMouseButton.current = false;\n                if ((onMoveEnd || onViewportChangeEnd) && viewChanged(prevTransform.current, event.transform)) {\n                    const flowTransform = eventToFlowTransform(event.transform);\n                    prevTransform.current = flowTransform;\n                    clearTimeout(timerId.current);\n                    timerId.current = setTimeout(() => {\n                        onViewportChangeEnd?.(flowTransform);\n                        onMoveEnd?.(event.sourceEvent, flowTransform);\n                    }, panOnScroll ? 150 : 0);\n                }\n            });\n        }\n    }, [d3Zoom, panOnScroll, panOnDrag, onMoveEnd, onPaneContextMenu]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (d3Zoom) {\n            d3Zoom.filter((event) => {\n                const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n                const pinchZoom = zoomOnPinch && event.ctrlKey;\n                if ((panOnDrag === true || (Array.isArray(panOnDrag) && panOnDrag.includes(1))) &&\n                    event.button === 1 &&\n                    event.type === 'mousedown' &&\n                    (isWrappedWithClass(event, 'react-flow__node') || isWrappedWithClass(event, 'react-flow__edge'))) {\n                    return true;\n                }\n                // if all interactions are disabled, we prevent all zoom events\n                if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n                    return false;\n                }\n                // during a selection we prevent all other interactions\n                if (userSelectionActive) {\n                    return false;\n                }\n                // if zoom on double click is disabled, we prevent the double click event\n                if (!zoomOnDoubleClick && event.type === 'dblclick') {\n                    return false;\n                }\n                // if the target element is inside an element with the nowheel class, we prevent zooming\n                if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {\n                    return false;\n                }\n                // if the target element is inside an element with the nopan class, we prevent panning\n                if (isWrappedWithClass(event, noPanClassName) &&\n                    ((!panOnScroll && event.type !== 'wheel') || (panOnScroll && event.type === 'wheel'))) {\n                    return false;\n                }\n                if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {\n                    return false;\n                }\n                // when there is no scroll handling enabled, we prevent all wheel events\n                if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {\n                    return false;\n                }\n                // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n                if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n                    return false;\n                }\n                // if the pane is only movable using allowed clicks\n                if (Array.isArray(panOnDrag) &&\n                    !panOnDrag.includes(event.button) &&\n                    (event.type === 'mousedown' || event.type === 'touchstart')) {\n                    return false;\n                }\n                // We only allow right clicks if pan on drag is set to right click\n                const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n                // default filter for d3-zoom\n                return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;\n            });\n        }\n    }, [\n        userSelectionActive,\n        d3Zoom,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        zoomOnDoubleClick,\n        panOnDrag,\n        elementsSelectable,\n        zoomActivationKeyPressed,\n    ]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"react-flow__renderer\", ref: zoomPane, style: containerStyle }, children));\n};\n\nconst selector$9 = (s) => ({\n    userSelectionActive: s.userSelectionActive,\n    userSelectionRect: s.userSelectionRect,\n});\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$9, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"react-flow__selection react-flow__container\", style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`,\n        } }));\n}\n\nfunction handleParentExpand(res, updateItem) {\n    const parent = res.find((e) => e.id === updateItem.parentNode);\n    if (parent) {\n        const extendWidth = updateItem.position.x + updateItem.width - parent.width;\n        const extendHeight = updateItem.position.y + updateItem.height - parent.height;\n        if (extendWidth > 0 || extendHeight > 0 || updateItem.position.x < 0 || updateItem.position.y < 0) {\n            parent.style = { ...parent.style } || {};\n            parent.style.width = parent.style.width ?? parent.width;\n            parent.style.height = parent.style.height ?? parent.height;\n            if (extendWidth > 0) {\n                parent.style.width += extendWidth;\n            }\n            if (extendHeight > 0) {\n                parent.style.height += extendHeight;\n            }\n            if (updateItem.position.x < 0) {\n                const xDiff = Math.abs(updateItem.position.x);\n                parent.position.x = parent.position.x - xDiff;\n                parent.style.width += xDiff;\n                updateItem.position.x = 0;\n            }\n            if (updateItem.position.y < 0) {\n                const yDiff = Math.abs(updateItem.position.y);\n                parent.position.y = parent.position.y - yDiff;\n                parent.style.height += yDiff;\n                updateItem.position.y = 0;\n            }\n            parent.width = parent.style.width;\n            parent.height = parent.style.height;\n        }\n    }\n}\nfunction applyChanges(changes, elements) {\n    // we need this hack to handle the setNodes and setEdges function of the useReactFlow hook for controlled flows\n    if (changes.some((c) => c.type === 'reset')) {\n        return changes.filter((c) => c.type === 'reset').map((c) => c.item);\n    }\n    const initElements = changes.filter((c) => c.type === 'add').map((c) => c.item);\n    return elements.reduce((res, item) => {\n        const currentChanges = changes.filter((c) => c.id === item.id);\n        if (currentChanges.length === 0) {\n            res.push(item);\n            return res;\n        }\n        const updateItem = { ...item };\n        for (const currentChange of currentChanges) {\n            if (currentChange) {\n                switch (currentChange.type) {\n                    case 'select': {\n                        updateItem.selected = currentChange.selected;\n                        break;\n                    }\n                    case 'position': {\n                        if (typeof currentChange.position !== 'undefined') {\n                            updateItem.position = currentChange.position;\n                        }\n                        if (typeof currentChange.positionAbsolute !== 'undefined') {\n                            updateItem.positionAbsolute = currentChange.positionAbsolute;\n                        }\n                        if (typeof currentChange.dragging !== 'undefined') {\n                            updateItem.dragging = currentChange.dragging;\n                        }\n                        if (updateItem.expandParent) {\n                            handleParentExpand(res, updateItem);\n                        }\n                        break;\n                    }\n                    case 'dimensions': {\n                        if (typeof currentChange.dimensions !== 'undefined') {\n                            updateItem.width = currentChange.dimensions.width;\n                            updateItem.height = currentChange.dimensions.height;\n                        }\n                        if (typeof currentChange.updateStyle !== 'undefined') {\n                            updateItem.style = { ...(updateItem.style || {}), ...currentChange.dimensions };\n                        }\n                        if (typeof currentChange.resizing === 'boolean') {\n                            updateItem.resizing = currentChange.resizing;\n                        }\n                        if (updateItem.expandParent) {\n                            handleParentExpand(res, updateItem);\n                        }\n                        break;\n                    }\n                    case 'remove': {\n                        return res;\n                    }\n                }\n            }\n        }\n        res.push(updateItem);\n        return res;\n    }, initElements);\n}\nfunction applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\nfunction applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nconst createSelectionChange = (id, selected) => ({\n    id,\n    type: 'select',\n    selected,\n});\nfunction getSelectionChanges(items, selectedIds) {\n    return items.reduce((res, item) => {\n        const willBeSelected = selectedIds.includes(item.id);\n        if (!item.selected && willBeSelected) {\n            item.selected = true;\n            res.push(createSelectionChange(item.id, true));\n        }\n        else if (item.selected && !willBeSelected) {\n            item.selected = false;\n            res.push(createSelectionChange(item.id, false));\n        }\n        return res;\n    }, []);\n}\n\n/**\n * The user selection rectangle gets displayed when a user drags the mouse while pressing shift\n */\nconst wrapHandler = (handler, containerRef) => {\n    return (event) => {\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$8 = (s) => ({\n    userSelectionActive: s.userSelectionActive,\n    elementsSelectable: s.elementsSelectable,\n    dragging: s.paneDragging,\n});\nconst Pane = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ isSelecting, selectionMode = SelectionMode.Full, panOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children, }) => {\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const store = useStoreApi();\n    const prevSelectedNodesCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const prevSelectedEdgesCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$8, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const resetUserSelection = () => {\n        store.setState({ userSelectionActive: false, userSelectionRect: null });\n        prevSelectedNodesCount.current = 0;\n        prevSelectedEdgesCount.current = 0;\n    };\n    const onClick = (event) => {\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({ nodesSelectionActive: false });\n    };\n    const onContextMenu = (event) => {\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event) => onPaneScroll(event) : undefined;\n    const onMouseDown = (event) => {\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable ||\n            !isSelecting ||\n            event.button !== 0 ||\n            event.target !== container.current ||\n            !containerBounds.current) {\n            return;\n        }\n        const { x, y } = getEventPosition(event, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y,\n            },\n        });\n        onSelectionStart?.(event);\n    };\n    const onMouseMove = (event) => {\n        const { userSelectionRect, nodeInternals, edges, transform, onNodesChange, onEdgesChange, nodeOrigin, getNodes } = store.getState();\n        if (!isSelecting || !containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        store.setState({ userSelectionActive: true, nodesSelectionActive: false });\n        const mousePos = getEventPosition(event, containerBounds.current);\n        const startX = userSelectionRect.startX ?? 0;\n        const startY = userSelectionRect.startY ?? 0;\n        const nextUserSelectRect = {\n            ...userSelectionRect,\n            x: mousePos.x < startX ? mousePos.x : startX,\n            y: mousePos.y < startY ? mousePos.y : startY,\n            width: Math.abs(mousePos.x - startX),\n            height: Math.abs(mousePos.y - startY),\n        };\n        const nodes = getNodes();\n        const selectedNodes = getNodesInside(nodeInternals, nextUserSelectRect, transform, selectionMode === SelectionMode.Partial, true, nodeOrigin);\n        const selectedEdgeIds = getConnectedEdges(selectedNodes, edges).map((e) => e.id);\n        const selectedNodeIds = selectedNodes.map((n) => n.id);\n        if (prevSelectedNodesCount.current !== selectedNodeIds.length) {\n            prevSelectedNodesCount.current = selectedNodeIds.length;\n            const changes = getSelectionChanges(nodes, selectedNodeIds);\n            if (changes.length) {\n                onNodesChange?.(changes);\n            }\n        }\n        if (prevSelectedEdgesCount.current !== selectedEdgeIds.length) {\n            prevSelectedEdgesCount.current = selectedEdgeIds.length;\n            const changes = getSelectionChanges(edges, selectedEdgeIds);\n            if (changes.length) {\n                onEdgesChange?.(changes);\n            }\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n        });\n    };\n    const onMouseUp = (event) => {\n        if (event.button !== 0) {\n            return;\n        }\n        const { userSelectionRect } = store.getState();\n        // We only want to trigger click functions when in selection mode if\n        // the user did not move the mouse.\n        if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({ nodesSelectionActive: prevSelectedNodesCount.current > 0 });\n        resetUserSelection();\n        onSelectionEnd?.(event);\n    };\n    const onMouseLeave = (event) => {\n        if (userSelectionActive) {\n            store.setState({ nodesSelectionActive: prevSelectedNodesCount.current > 0 });\n            onSelectionEnd?.(event);\n        }\n        resetUserSelection();\n    };\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(['react-flow__pane', { dragging, selection: isSelecting }]), onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container), onContextMenu: wrapHandler(onContextMenu, container), onWheel: wrapHandler(onWheel, container), onMouseEnter: hasActiveSelection ? undefined : onPaneMouseEnter, onMouseDown: hasActiveSelection ? onMouseDown : undefined, onMouseMove: hasActiveSelection ? onMouseMove : onPaneMouseMove, onMouseUp: hasActiveSelection ? onMouseUp : undefined, onMouseLeave: hasActiveSelection ? onMouseLeave : onPaneMouseLeave, ref: container, style: containerStyle },\n        children,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(UserSelection, null)));\n});\nPane.displayName = 'Pane';\n\nfunction isParentSelected(node, nodeInternals) {\n    if (!node.parentNode) {\n        return false;\n    }\n    const parentNode = nodeInternals.get(node.parentNode);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeInternals);\n}\nfunction hasSelector(target, selector, nodeRef) {\n    let current = target;\n    do {\n        if (current?.matches(selector))\n            return true;\n        if (current === nodeRef.current)\n            return false;\n        current = current.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeInternals, nodesDraggable, mousePos, nodeId) {\n    return Array.from(nodeInternals.values())\n        .filter((n) => (n.selected || n.id === nodeId) &&\n        (!n.parentNode || !isParentSelected(n, nodeInternals)) &&\n        (n.draggable || (nodesDraggable && typeof n.draggable === 'undefined')))\n        .map((n) => ({\n        id: n.id,\n        position: n.position || { x: 0, y: 0 },\n        positionAbsolute: n.positionAbsolute || { x: 0, y: 0 },\n        distance: {\n            x: mousePos.x - (n.positionAbsolute?.x ?? 0),\n            y: mousePos.y - (n.positionAbsolute?.y ?? 0),\n        },\n        delta: {\n            x: 0,\n            y: 0,\n        },\n        extent: n.extent,\n        parentNode: n.parentNode,\n        width: n.width,\n        height: n.height,\n        expandParent: n.expandParent,\n    }));\n}\nfunction clampNodeExtent(node, extent) {\n    if (!extent || extent === 'parent') {\n        return extent;\n    }\n    return [extent[0], [extent[1][0] - (node.width || 0), extent[1][1] - (node.height || 0)]];\n}\nfunction calcNextPosition(node, nextPosition, nodeInternals, nodeExtent, nodeOrigin = [0, 0], onError) {\n    const clampedNodeExtent = clampNodeExtent(node, node.extent || nodeExtent);\n    let currentExtent = clampedNodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (node.parentNode && node.width && node.height) {\n            const parent = nodeInternals.get(node.parentNode);\n            const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;\n            currentExtent =\n                parent && isNumeric(parentX) && isNumeric(parentY) && isNumeric(parent.width) && isNumeric(parent.height)\n                    ? [\n                        [parentX + node.width * nodeOrigin[0], parentY + node.height * nodeOrigin[1]],\n                        [\n                            parentX + parent.width - node.width + node.width * nodeOrigin[0],\n                            parentY + parent.height - node.height + node.height * nodeOrigin[1],\n                        ],\n                    ]\n                    : currentExtent;\n        }\n        else {\n            onError?.('005', errorMessages['error005']());\n            currentExtent = clampedNodeExtent;\n        }\n    }\n    else if (node.extent && node.parentNode && node.extent !== 'parent') {\n        const parent = nodeInternals.get(node.parentNode);\n        const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;\n        currentExtent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    let parentPosition = { x: 0, y: 0 };\n    if (node.parentNode) {\n        const parentNode = nodeInternals.get(node.parentNode);\n        parentPosition = getNodePositionWithOrigin(parentNode, nodeOrigin).positionAbsolute;\n    }\n    const positionAbsolute = currentExtent && currentExtent !== 'parent'\n        ? clampPosition(nextPosition, currentExtent)\n        : nextPosition;\n    return {\n        position: {\n            x: positionAbsolute.x - parentPosition.x,\n            y: positionAbsolute.y - parentPosition.y,\n        },\n        positionAbsolute,\n    };\n}\n// returns two params:\n// 1. the dragged node (or the first of the list, if we are dragging a node selection)\n// 2. array of selected nodes (for multi selections)\nfunction getEventHandlerParams({ nodeId, dragItems, nodeInternals, }) {\n    const extentedDragItems = dragItems.map((n) => {\n        const node = nodeInternals.get(n.id);\n        return {\n            ...node,\n            position: n.position,\n            positionAbsolute: n.positionAbsolute,\n        };\n    });\n    return [nodeId ? extentedDragItems.find((n) => n.id === nodeId) : extentedDragItems[0], extentedDragItems];\n}\n\nconst getHandleBounds = (selector, nodeElement, zoom, nodeOrigin) => {\n    const handles = nodeElement.querySelectorAll(selector);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    const handlesArray = Array.from(handles);\n    const nodeBounds = nodeElement.getBoundingClientRect();\n    const nodeOffset = {\n        x: nodeBounds.width * nodeOrigin[0],\n        y: nodeBounds.height * nodeOrigin[1],\n    };\n    return handlesArray.map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left - nodeOffset.x) / zoom,\n            y: (handleBounds.top - nodeBounds.top - nodeOffset.y) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\nfunction getMouseHandler(id, getState, handler) {\n    return handler === undefined\n        ? handler\n        : (event) => {\n            const node = getState().nodeInternals.get(id);\n            if (node) {\n                handler(event, { ...node });\n            }\n        };\n}\n// this handler is called by\n// 1. the click handler when node is not draggable or selectNodesOnDrag = false\n// or\n// 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\nfunction handleNodeClick({ id, store, unselect = false, nodeRef, }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeInternals, onError } = store.getState();\n    const node = nodeInternals.get(id);\n    if (!node) {\n        onError?.('012', errorMessages['error012'](id));\n        return;\n    }\n    store.setState({ nodesSelectionActive: false });\n    if (!node.selected) {\n        addSelectedNodes([id]);\n    }\n    else if (unselect || (node.selected && multiSelectionActive)) {\n        unselectNodesAndEdges({ nodes: [node], edges: [] });\n        requestAnimationFrame(() => nodeRef?.current?.blur());\n    }\n}\n\nfunction useGetPointerPosition() {\n    const store = useStoreApi();\n    // returns the pointer position projected to the RF coordinate system\n    const getPointerPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ sourceEvent }) => {\n        const { transform, snapGrid, snapToGrid } = store.getState();\n        const x = sourceEvent.touches ? sourceEvent.touches[0].clientX : sourceEvent.clientX;\n        const y = sourceEvent.touches ? sourceEvent.touches[0].clientY : sourceEvent.clientY;\n        const pointerPos = {\n            x: (x - transform[0]) / transform[2],\n            y: (y - transform[1]) / transform[2],\n        };\n        // we need the snapped position in order to be able to skip unnecessary drag events\n        return {\n            xSnapped: snapToGrid ? snapGrid[0] * Math.round(pointerPos.x / snapGrid[0]) : pointerPos.x,\n            ySnapped: snapToGrid ? snapGrid[1] * Math.round(pointerPos.y / snapGrid[1]) : pointerPos.y,\n            ...pointerPos,\n        };\n    }, []);\n    return getPointerPosition;\n}\n\nfunction wrapSelectionDragFunc(selectionFunc) {\n    return (event, _, nodes) => selectionFunc?.(event, nodes);\n}\nfunction useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, selectNodesOnDrag, }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const dragItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const lastPos = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ x: null, y: null });\n    const autoPanId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const mousePosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ x: 0, y: 0 });\n    const dragEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoPanStarted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const dragStarted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const getPointerPosition = useGetPointerPosition();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (nodeRef?.current) {\n            const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(nodeRef.current);\n            const updateNodes = ({ x, y }) => {\n                const { nodeInternals, onNodeDrag, onSelectionDrag, updateNodePositions, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onError, } = store.getState();\n                lastPos.current = { x, y };\n                let hasChange = false;\n                let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };\n                if (dragItems.current.length > 1 && nodeExtent) {\n                    const rect = getRectOfNodes(dragItems.current, nodeOrigin);\n                    nodesBox = rectToBox(rect);\n                }\n                dragItems.current = dragItems.current.map((n) => {\n                    const nextPosition = { x: x - n.distance.x, y: y - n.distance.y };\n                    if (snapToGrid) {\n                        nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);\n                        nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);\n                    }\n                    // if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node\n                    // based on its position so that the node stays at it's position relative to the selection.\n                    const adjustedNodeExtent = [\n                        [nodeExtent[0][0], nodeExtent[0][1]],\n                        [nodeExtent[1][0], nodeExtent[1][1]],\n                    ];\n                    if (dragItems.current.length > 1 && nodeExtent && !n.extent) {\n                        adjustedNodeExtent[0][0] = n.positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                        adjustedNodeExtent[1][0] = n.positionAbsolute.x + (n.width ?? 0) - nodesBox.x2 + nodeExtent[1][0];\n                        adjustedNodeExtent[0][1] = n.positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                        adjustedNodeExtent[1][1] = n.positionAbsolute.y + (n.height ?? 0) - nodesBox.y2 + nodeExtent[1][1];\n                    }\n                    const updatedPos = calcNextPosition(n, nextPosition, nodeInternals, adjustedNodeExtent, nodeOrigin, onError);\n                    // we want to make sure that we only fire a change event when there is a change\n                    hasChange = hasChange || n.position.x !== updatedPos.position.x || n.position.y !== updatedPos.position.y;\n                    n.position = updatedPos.position;\n                    n.positionAbsolute = updatedPos.positionAbsolute;\n                    return n;\n                });\n                if (!hasChange) {\n                    return;\n                }\n                updateNodePositions(dragItems.current, true, true);\n                setDragging(true);\n                const onDrag = nodeId ? onNodeDrag : wrapSelectionDragFunc(onSelectionDrag);\n                if (onDrag && dragEvent.current) {\n                    const [currentNode, nodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems: dragItems.current,\n                        nodeInternals,\n                    });\n                    onDrag(dragEvent.current, currentNode, nodes);\n                }\n            };\n            const autoPan = () => {\n                if (!containerBounds.current) {\n                    return;\n                }\n                const [xMovement, yMovement] = calcAutoPan(mousePosition.current, containerBounds.current);\n                if (xMovement !== 0 || yMovement !== 0) {\n                    const { transform, panBy } = store.getState();\n                    lastPos.current.x = (lastPos.current.x ?? 0) - xMovement / transform[2];\n                    lastPos.current.y = (lastPos.current.y ?? 0) - yMovement / transform[2];\n                    if (panBy({ x: xMovement, y: yMovement })) {\n                        updateNodes(lastPos.current);\n                    }\n                }\n                autoPanId.current = requestAnimationFrame(autoPan);\n            };\n            const startDrag = (event) => {\n                const { nodeInternals, multiSelectionActive, nodesDraggable, unselectNodesAndEdges, onNodeDragStart, onSelectionDragStart, } = store.getState();\n                dragStarted.current = true;\n                const onStart = nodeId ? onNodeDragStart : wrapSelectionDragFunc(onSelectionDragStart);\n                if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                    if (!nodeInternals.get(nodeId)?.selected) {\n                        // we need to reset selected nodes when selectNodesOnDrag=false\n                        unselectNodesAndEdges();\n                    }\n                }\n                if (nodeId && isSelectable && selectNodesOnDrag) {\n                    handleNodeClick({\n                        id: nodeId,\n                        store,\n                        nodeRef: nodeRef,\n                    });\n                }\n                const pointerPos = getPointerPosition(event);\n                lastPos.current = pointerPos;\n                dragItems.current = getDragItems(nodeInternals, nodesDraggable, pointerPos, nodeId);\n                if (onStart && dragItems.current) {\n                    const [currentNode, nodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems: dragItems.current,\n                        nodeInternals,\n                    });\n                    onStart(event.sourceEvent, currentNode, nodes);\n                }\n            };\n            if (disabled) {\n                selection.on('.drag', null);\n            }\n            else {\n                const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_8__[\"default\"])()\n                    .on('start', (event) => {\n                    const { domNode, nodeDragThreshold } = store.getState();\n                    if (nodeDragThreshold === 0) {\n                        startDrag(event);\n                    }\n                    const pointerPos = getPointerPosition(event);\n                    lastPos.current = pointerPos;\n                    containerBounds.current = domNode?.getBoundingClientRect() || null;\n                    mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);\n                })\n                    .on('drag', (event) => {\n                    const pointerPos = getPointerPosition(event);\n                    const { autoPanOnNodeDrag, nodeDragThreshold } = store.getState();\n                    if (!autoPanStarted.current && dragStarted.current && autoPanOnNodeDrag) {\n                        autoPanStarted.current = true;\n                        autoPan();\n                    }\n                    if (!dragStarted.current) {\n                        const x = pointerPos.xSnapped - (lastPos?.current?.x ?? 0);\n                        const y = pointerPos.ySnapped - (lastPos?.current?.y ?? 0);\n                        const distance = Math.sqrt(x * x + y * y);\n                        if (distance > nodeDragThreshold) {\n                            startDrag(event);\n                        }\n                    }\n                    // skip events without movement\n                    if ((lastPos.current.x !== pointerPos.xSnapped || lastPos.current.y !== pointerPos.ySnapped) &&\n                        dragItems.current &&\n                        dragStarted.current) {\n                        dragEvent.current = event.sourceEvent;\n                        mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);\n                        updateNodes(pointerPos);\n                    }\n                })\n                    .on('end', (event) => {\n                    if (!dragStarted.current) {\n                        return;\n                    }\n                    setDragging(false);\n                    autoPanStarted.current = false;\n                    dragStarted.current = false;\n                    cancelAnimationFrame(autoPanId.current);\n                    if (dragItems.current) {\n                        const { updateNodePositions, nodeInternals, onNodeDragStop, onSelectionDragStop } = store.getState();\n                        const onStop = nodeId ? onNodeDragStop : wrapSelectionDragFunc(onSelectionDragStop);\n                        updateNodePositions(dragItems.current, false, false);\n                        if (onStop) {\n                            const [currentNode, nodes] = getEventHandlerParams({\n                                nodeId,\n                                dragItems: dragItems.current,\n                                nodeInternals,\n                            });\n                            onStop(event.sourceEvent, currentNode, nodes);\n                        }\n                    }\n                })\n                    .filter((event) => {\n                    const target = event.target;\n                    const isDraggable = !event.button &&\n                        (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, nodeRef)) &&\n                        (!handleSelector || hasSelector(target, handleSelector, nodeRef));\n                    return isDraggable;\n                });\n                selection.call(dragHandler);\n                return () => {\n                    selection.on('.drag', null);\n                };\n            }\n        }\n    }, [\n        nodeRef,\n        disabled,\n        noDragClassName,\n        handleSelector,\n        isSelectable,\n        store,\n        nodeId,\n        selectNodesOnDrag,\n        getPointerPosition,\n    ]);\n    return dragging;\n}\n\nfunction useUpdateNodePositions() {\n    const store = useStoreApi();\n    const updatePositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((params) => {\n        const { nodeInternals, nodeExtent, updateNodePositions, getNodes, snapToGrid, snapGrid, onError, nodesDraggable } = store.getState();\n        const selectedNodes = getNodes().filter((n) => n.selected && (n.draggable || (nodesDraggable && typeof n.draggable === 'undefined')));\n        // by default a node moves 5px on each key press, or 20px if shift is pressed\n        // if snap grid is enabled, we use that for the velocity.\n        const xVelo = snapToGrid ? snapGrid[0] : 5;\n        const yVelo = snapToGrid ? snapGrid[1] : 5;\n        const factor = params.isShiftPressed ? 4 : 1;\n        const positionDiffX = params.x * xVelo * factor;\n        const positionDiffY = params.y * yVelo * factor;\n        const nodeUpdates = selectedNodes.map((n) => {\n            if (n.positionAbsolute) {\n                const nextPosition = { x: n.positionAbsolute.x + positionDiffX, y: n.positionAbsolute.y + positionDiffY };\n                if (snapToGrid) {\n                    nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);\n                    nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);\n                }\n                const { positionAbsolute, position } = calcNextPosition(n, nextPosition, nodeInternals, nodeExtent, undefined, onError);\n                n.position = position;\n                n.positionAbsolute = positionAbsolute;\n            }\n            return n;\n        });\n        updateNodePositions(nodeUpdates, true, false);\n    }, []);\n    return updatePositions;\n}\n\nconst arrowKeyDiffs = {\n    ArrowUp: { x: 0, y: -1 },\n    ArrowDown: { x: 0, y: 1 },\n    ArrowLeft: { x: -1, y: 0 },\n    ArrowRight: { x: 1, y: 0 },\n};\nvar wrapNode = (NodeComponent) => {\n    const NodeWrapper = ({ id, type, data, xPos, yPos, xPosOrigin, yPosOrigin, selected, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, style, className, isDraggable, isSelectable, isConnectable, isFocusable, selectNodesOnDrag, sourcePosition, targetPosition, hidden, resizeObserver, dragHandle, zIndex, isParent, noDragClassName, noPanClassName, initialized, disableKeyboardA11y, ariaLabel, rfId, }) => {\n        const store = useStoreApi();\n        const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n        const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(sourcePosition);\n        const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(targetPosition);\n        const prevType = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(type);\n        const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n        const updatePositions = useUpdateNodePositions();\n        const onMouseEnterHandler = getMouseHandler(id, store.getState, onMouseEnter);\n        const onMouseMoveHandler = getMouseHandler(id, store.getState, onMouseMove);\n        const onMouseLeaveHandler = getMouseHandler(id, store.getState, onMouseLeave);\n        const onContextMenuHandler = getMouseHandler(id, store.getState, onContextMenu);\n        const onDoubleClickHandler = getMouseHandler(id, store.getState, onDoubleClick);\n        const onSelectNodeHandler = (event) => {\n            const { nodeDragThreshold } = store.getState();\n            if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n                // this handler gets called within the drag start event when selectNodesOnDrag=true\n                handleNodeClick({\n                    id,\n                    store,\n                    nodeRef,\n                });\n            }\n            if (onClick) {\n                const node = store.getState().nodeInternals.get(id);\n                if (node) {\n                    onClick(event, { ...node });\n                }\n            }\n        };\n        const onKeyDown = (event) => {\n            if (isInputDOMNode(event)) {\n                return;\n            }\n            if (elementSelectionKeys.includes(event.key) && isSelectable) {\n                const unselect = event.key === 'Escape';\n                handleNodeClick({\n                    id,\n                    store,\n                    unselect,\n                    nodeRef,\n                });\n            }\n            else if (!disableKeyboardA11y &&\n                isDraggable &&\n                selected &&\n                Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n                store.setState({\n                    ariaLiveMessage: `Moved selected node ${event.key\n                        .replace('Arrow', '')\n                        .toLowerCase()}. New position, x: ${~~xPos}, y: ${~~yPos}`,\n                });\n                updatePositions({\n                    x: arrowKeyDiffs[event.key].x,\n                    y: arrowKeyDiffs[event.key].y,\n                    isShiftPressed: event.shiftKey,\n                });\n            }\n        };\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n            if (nodeRef.current && !hidden) {\n                const currNode = nodeRef.current;\n                resizeObserver?.observe(currNode);\n                return () => resizeObserver?.unobserve(currNode);\n            }\n        }, [hidden]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n            // when the user programmatically changes the source or handle position, we re-initialize the node\n            const typeChanged = prevType.current !== type;\n            const sourcePosChanged = prevSourcePosition.current !== sourcePosition;\n            const targetPosChanged = prevTargetPosition.current !== targetPosition;\n            if (nodeRef.current && (typeChanged || sourcePosChanged || targetPosChanged)) {\n                if (typeChanged) {\n                    prevType.current = type;\n                }\n                if (sourcePosChanged) {\n                    prevSourcePosition.current = sourcePosition;\n                }\n                if (targetPosChanged) {\n                    prevTargetPosition.current = targetPosition;\n                }\n                store.getState().updateNodeDimensions([{ id, nodeElement: nodeRef.current, forceUpdate: true }]);\n            }\n        }, [id, type, sourcePosition, targetPosition]);\n        const dragging = useDrag({\n            nodeRef,\n            disabled: hidden || !isDraggable,\n            noDragClassName,\n            handleSelector: dragHandle,\n            nodeId: id,\n            isSelectable,\n            selectNodesOnDrag,\n        });\n        if (hidden) {\n            return null;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                'react-flow__node',\n                `react-flow__node-${type}`,\n                {\n                    // this is overwritable by passing `nopan` as a class name\n                    [noPanClassName]: isDraggable,\n                },\n                className,\n                {\n                    selected,\n                    selectable: isSelectable,\n                    parent: isParent,\n                    dragging,\n                },\n            ]), ref: nodeRef, style: {\n                zIndex,\n                transform: `translate(${xPosOrigin}px,${yPosOrigin}px)`,\n                pointerEvents: hasPointerEvents ? 'all' : 'none',\n                visibility: initialized ? 'visible' : 'hidden',\n                ...style,\n            }, \"data-id\": id, \"data-testid\": `rf__node-${id}`, onMouseEnter: onMouseEnterHandler, onMouseMove: onMouseMoveHandler, onMouseLeave: onMouseLeaveHandler, onContextMenu: onContextMenuHandler, onClick: onSelectNodeHandler, onDoubleClick: onDoubleClickHandler, onKeyDown: isFocusable ? onKeyDown : undefined, tabIndex: isFocusable ? 0 : undefined, role: isFocusable ? 'button' : undefined, \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`, \"aria-label\": ariaLabel },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, { value: id },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeComponent, { id: id, data: data, type: type, xPos: xPos, yPos: yPos, selected: selected, isConnectable: isConnectable, sourcePosition: sourcePosition, targetPosition: targetPosition, dragging: dragging, dragHandle: dragHandle, zIndex: zIndex }))));\n    };\n    NodeWrapper.displayName = 'NodeWrapper';\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodeWrapper);\n};\n\n/**\n * The nodes selection rectangle gets displayed when a user\n * made a selection with on or several nodes\n */\nconst selector$7 = (s) => {\n    const selectedNodes = s.getNodes().filter((n) => n.selected);\n    return {\n        ...getRectOfNodes(selectedNodes, s.nodeOrigin),\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`,\n        userSelectionActive: s.userSelectionActive,\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, x: left, y: top, transformString, userSelectionActive } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const updatePositions = useUpdateNodePositions();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!disableKeyboardA11y) {\n            nodeRef.current?.focus({\n                preventScroll: true,\n            });\n        }\n    }, [disableKeyboardA11y]);\n    useDrag({\n        nodeRef,\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu\n        ? (event) => {\n            const selectedNodes = store\n                .getState()\n                .getNodes()\n                .filter((n) => n.selected);\n            onSelectionContextMenu(event, selectedNodes);\n        }\n        : undefined;\n    const onKeyDown = (event) => {\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            updatePositions({\n                x: arrowKeyDiffs[event.key].x,\n                y: arrowKeyDiffs[event.key].y,\n                isShiftPressed: event.shiftKey,\n            });\n        }\n    };\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(['react-flow__nodesselection', 'react-flow__container', noPanClassName]), style: {\n            transform: transformString,\n        } },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: nodeRef, className: \"react-flow__nodesselection-rect\", onContextMenu: onContextMenu, tabIndex: disableKeyboardA11y ? undefined : -1, onKeyDown: disableKeyboardA11y ? undefined : onKeyDown, style: {\n                width,\n                height,\n                top,\n                left,\n            } })));\n}\nvar NodesSelection$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodesSelection);\n\nconst selector$6 = (s) => s.nodesSelectionActive;\nconst FlowRenderer = ({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, deleteKeyCode, onMove, onMoveStart, onMoveEnd, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, }) => {\n    const nodesSelectionActive = useStore(selector$6);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode);\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode);\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const isSelecting = selectionKeyPressed || (selectionOnDrag && panOnDrag !== true);\n    useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode });\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(ZoomPane, { onMove: onMove, onMoveStart: onMoveStart, onMoveEnd: onMoveEnd, onPaneContextMenu: onPaneContextMenu, elementsSelectable: elementsSelectable, zoomOnScroll: zoomOnScroll, zoomOnPinch: zoomOnPinch, panOnScroll: panOnScroll, panOnScrollSpeed: panOnScrollSpeed, panOnScrollMode: panOnScrollMode, zoomOnDoubleClick: zoomOnDoubleClick, panOnDrag: !selectionKeyPressed && panOnDrag, defaultViewport: defaultViewport, translateExtent: translateExtent, minZoom: minZoom, maxZoom: maxZoom, zoomActivationKeyCode: zoomActivationKeyCode, preventScrolling: preventScrolling, noWheelClassName: noWheelClassName, noPanClassName: noPanClassName },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Pane, { onSelectionStart: onSelectionStart, onSelectionEnd: onSelectionEnd, onPaneClick: onPaneClick, onPaneMouseEnter: onPaneMouseEnter, onPaneMouseMove: onPaneMouseMove, onPaneMouseLeave: onPaneMouseLeave, onPaneContextMenu: onPaneContextMenu, onPaneScroll: onPaneScroll, panOnDrag: panOnDrag, isSelecting: !!isSelecting, selectionMode: selectionMode },\n            children,\n            nodesSelectionActive && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodesSelection$1, { onSelectionContextMenu: onSelectionContextMenu, noPanClassName: noPanClassName, disableKeyboardA11y: disableKeyboardA11y })))));\n};\nFlowRenderer.displayName = 'FlowRenderer';\nvar FlowRenderer$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(FlowRenderer);\n\nfunction useVisibleNodes(onlyRenderVisible) {\n    const nodes = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s) => onlyRenderVisible\n        ? getNodesInside(s.nodeInternals, { x: 0, y: 0, width: s.width, height: s.height }, s.transform, true)\n        : s.getNodes(), [onlyRenderVisible]));\n    return nodes;\n}\n\nfunction createNodeTypes(nodeTypes) {\n    const standardTypes = {\n        input: wrapNode((nodeTypes.input || InputNode$1)),\n        default: wrapNode((nodeTypes.default || DefaultNode$1)),\n        output: wrapNode((nodeTypes.output || OutputNode$1)),\n        group: wrapNode((nodeTypes.group || GroupNode)),\n    };\n    const wrappedTypes = {};\n    const specialTypes = Object.keys(nodeTypes)\n        .filter((k) => !['input', 'default', 'output', 'group'].includes(k))\n        .reduce((res, key) => {\n        res[key] = wrapNode((nodeTypes[key] || DefaultNode$1));\n        return res;\n    }, wrappedTypes);\n    return {\n        ...standardTypes,\n        ...specialTypes,\n    };\n}\nconst getPositionWithOrigin = ({ x, y, width, height, origin, }) => {\n    if (!width || !height) {\n        return { x, y };\n    }\n    if (origin[0] < 0 || origin[1] < 0 || origin[0] > 1 || origin[1] > 1) {\n        return { x, y };\n    }\n    return {\n        x: x - width * origin[0],\n        y: y - height * origin[1],\n    };\n};\n\nconst selector$5 = (s) => ({\n    nodesDraggable: s.nodesDraggable,\n    nodesConnectable: s.nodesConnectable,\n    nodesFocusable: s.nodesFocusable,\n    elementsSelectable: s.elementsSelectable,\n    updateNodeDimensions: s.updateNodeDimensions,\n    onError: s.onError,\n});\nconst NodeRenderer = (props) => {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, updateNodeDimensions, onError } = useStore(selector$5, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const nodes = useVisibleNodes(props.onlyRenderVisibleElements);\n    const resizeObserverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (typeof ResizeObserver === 'undefined') {\n            return null;\n        }\n        const observer = new ResizeObserver((entries) => {\n            const updates = entries.map((entry) => ({\n                id: entry.target.getAttribute('data-id'),\n                nodeElement: entry.target,\n                forceUpdate: true,\n            }));\n            updateNodeDimensions(updates);\n        });\n        resizeObserverRef.current = observer;\n        return observer;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        return () => {\n            resizeObserverRef?.current?.disconnect();\n        };\n    }, []);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"react-flow__nodes\", style: containerStyle }, nodes.map((node) => {\n        let nodeType = node.type || 'default';\n        if (!props.nodeTypes[nodeType]) {\n            onError?.('003', errorMessages['error003'](nodeType));\n            nodeType = 'default';\n        }\n        const NodeComponent = (props.nodeTypes[nodeType] || props.nodeTypes.default);\n        const isDraggable = !!(node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'));\n        const isSelectable = !!(node.selectable || (elementsSelectable && typeof node.selectable === 'undefined'));\n        const isConnectable = !!(node.connectable || (nodesConnectable && typeof node.connectable === 'undefined'));\n        const isFocusable = !!(node.focusable || (nodesFocusable && typeof node.focusable === 'undefined'));\n        const clampedPosition = props.nodeExtent\n            ? clampPosition(node.positionAbsolute, props.nodeExtent)\n            : node.positionAbsolute;\n        const posX = clampedPosition?.x ?? 0;\n        const posY = clampedPosition?.y ?? 0;\n        const posOrigin = getPositionWithOrigin({\n            x: posX,\n            y: posY,\n            width: node.width ?? 0,\n            height: node.height ?? 0,\n            origin: props.nodeOrigin,\n        });\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeComponent, { key: node.id, id: node.id, className: node.className, style: node.style, type: nodeType, data: node.data, sourcePosition: node.sourcePosition || Position.Bottom, targetPosition: node.targetPosition || Position.Top, hidden: node.hidden, xPos: posX, yPos: posY, xPosOrigin: posOrigin.x, yPosOrigin: posOrigin.y, selectNodesOnDrag: props.selectNodesOnDrag, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onDoubleClick: props.onNodeDoubleClick, selected: !!node.selected, isDraggable: isDraggable, isSelectable: isSelectable, isConnectable: isConnectable, isFocusable: isFocusable, resizeObserver: resizeObserver, dragHandle: node.dragHandle, zIndex: node[internalsSymbol]?.z ?? 0, isParent: !!node[internalsSymbol]?.isParent, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName, initialized: !!node.width && !!node.height, rfId: props.rfId, disableKeyboardA11y: props.disableKeyboardA11y, ariaLabel: node.ariaLabel }));\n    })));\n};\nNodeRenderer.displayName = 'NodeRenderer';\nvar NodeRenderer$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodeRenderer);\n\nconst shiftX = (x, shift, position) => {\n    if (position === Position.Left)\n        return x - shift;\n    if (position === Position.Right)\n        return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position) => {\n    if (position === Position.Top)\n        return y - shift;\n    if (position === Position.Bottom)\n        return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = 'react-flow__edgeupdater';\nconst EdgeAnchor = ({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type, }) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", { onMouseDown: onMouseDown, onMouseEnter: onMouseEnter, onMouseOut: onMouseOut, className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${type}`]), cx: shiftX(centerX, radius, position), cy: shiftY(centerY, radius, position), r: radius, stroke: \"transparent\", fill: \"transparent\" }));\n\nconst alwaysValidConnection = () => true;\nvar wrapEdge = (EdgeComponent) => {\n    const EdgeWrapper = ({ id, className, type, data, onClick, onEdgeDoubleClick, selected, animated, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, source, target, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, elementsSelectable, hidden, sourceHandleId, targetHandleId, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, edgeUpdaterRadius, onEdgeUpdate, onEdgeUpdateStart, onEdgeUpdateEnd, markerEnd, markerStart, rfId, ariaLabel, isFocusable, isUpdatable, pathOptions, interactionWidth, }) => {\n        const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n        const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const [updating, setUpdating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const store = useStoreApi();\n        const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `url(#${getMarkerId(markerStart, rfId)})`, [markerStart, rfId]);\n        const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `url(#${getMarkerId(markerEnd, rfId)})`, [markerEnd, rfId]);\n        if (hidden) {\n            return null;\n        }\n        const onEdgeClick = (event) => {\n            const { edges, addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n            const edge = edges.find((e) => e.id === id);\n            if (!edge) {\n                return;\n            }\n            if (elementsSelectable) {\n                store.setState({ nodesSelectionActive: false });\n                if (edge.selected && multiSelectionActive) {\n                    unselectNodesAndEdges({ nodes: [], edges: [edge] });\n                    edgeRef.current?.blur();\n                }\n                else {\n                    addSelectedEdges([id]);\n                }\n            }\n            if (onClick) {\n                onClick(event, edge);\n            }\n        };\n        const onEdgeDoubleClickHandler = getMouseHandler$1(id, store.getState, onEdgeDoubleClick);\n        const onEdgeContextMenu = getMouseHandler$1(id, store.getState, onContextMenu);\n        const onEdgeMouseEnter = getMouseHandler$1(id, store.getState, onMouseEnter);\n        const onEdgeMouseMove = getMouseHandler$1(id, store.getState, onMouseMove);\n        const onEdgeMouseLeave = getMouseHandler$1(id, store.getState, onMouseLeave);\n        const handleEdgeUpdater = (event, isSourceHandle) => {\n            // avoid triggering edge updater if mouse btn is not left\n            if (event.button !== 0) {\n                return;\n            }\n            const { edges, isValidConnection: isValidConnectionStore } = store.getState();\n            const nodeId = isSourceHandle ? target : source;\n            const handleId = (isSourceHandle ? targetHandleId : sourceHandleId) || null;\n            const handleType = isSourceHandle ? 'target' : 'source';\n            const isValidConnection = isValidConnectionStore || alwaysValidConnection;\n            const isTarget = isSourceHandle;\n            const edge = edges.find((e) => e.id === id);\n            setUpdating(true);\n            onEdgeUpdateStart?.(event, edge, handleType);\n            const _onEdgeUpdateEnd = (evt) => {\n                setUpdating(false);\n                onEdgeUpdateEnd?.(evt, edge, handleType);\n            };\n            const onConnectEdge = (connection) => onEdgeUpdate?.(edge, connection);\n            handlePointerDown({\n                event,\n                handleId,\n                nodeId,\n                onConnect: onConnectEdge,\n                isTarget,\n                getState: store.getState,\n                setState: store.setState,\n                isValidConnection,\n                edgeUpdaterType: handleType,\n                onEdgeUpdateEnd: _onEdgeUpdateEnd,\n            });\n        };\n        const onEdgeUpdaterSourceMouseDown = (event) => handleEdgeUpdater(event, true);\n        const onEdgeUpdaterTargetMouseDown = (event) => handleEdgeUpdater(event, false);\n        const onEdgeUpdaterMouseEnter = () => setUpdateHover(true);\n        const onEdgeUpdaterMouseOut = () => setUpdateHover(false);\n        const inactive = !elementsSelectable && !onClick;\n        const onKeyDown = (event) => {\n            if (elementSelectionKeys.includes(event.key) && elementsSelectable) {\n                const { unselectNodesAndEdges, addSelectedEdges, edges } = store.getState();\n                const unselect = event.key === 'Escape';\n                if (unselect) {\n                    edgeRef.current?.blur();\n                    unselectNodesAndEdges({ edges: [edges.find((e) => e.id === id)] });\n                }\n                else {\n                    addSelectedEdges([id]);\n                }\n            }\n        };\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                'react-flow__edge',\n                `react-flow__edge-${type}`,\n                className,\n                { selected, animated, inactive, updating: updateHover },\n            ]), onClick: onEdgeClick, onDoubleClick: onEdgeDoubleClickHandler, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onKeyDown: isFocusable ? onKeyDown : undefined, tabIndex: isFocusable ? 0 : undefined, role: isFocusable ? 'button' : 'img', \"data-testid\": `rf__edge-${id}`, \"aria-label\": ariaLabel === null ? undefined : ariaLabel ? ariaLabel : `Edge from ${source} to ${target}`, \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined, ref: edgeRef },\n            !updating && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeComponent, { id: id, source: source, target: target, selected: selected, animated: animated, label: label, labelStyle: labelStyle, labelShowBg: labelShowBg, labelBgStyle: labelBgStyle, labelBgPadding: labelBgPadding, labelBgBorderRadius: labelBgBorderRadius, data: data, style: style, sourceX: sourceX, sourceY: sourceY, targetX: targetX, targetY: targetY, sourcePosition: sourcePosition, targetPosition: targetPosition, sourceHandleId: sourceHandleId, targetHandleId: targetHandleId, markerStart: markerStartUrl, markerEnd: markerEndUrl, pathOptions: pathOptions, interactionWidth: interactionWidth })),\n            isUpdatable && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                (isUpdatable === 'source' || isUpdatable === true) && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeAnchor, { position: sourcePosition, centerX: sourceX, centerY: sourceY, radius: edgeUpdaterRadius, onMouseDown: onEdgeUpdaterSourceMouseDown, onMouseEnter: onEdgeUpdaterMouseEnter, onMouseOut: onEdgeUpdaterMouseOut, type: \"source\" })),\n                (isUpdatable === 'target' || isUpdatable === true) && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeAnchor, { position: targetPosition, centerX: targetX, centerY: targetY, radius: edgeUpdaterRadius, onMouseDown: onEdgeUpdaterTargetMouseDown, onMouseEnter: onEdgeUpdaterMouseEnter, onMouseOut: onEdgeUpdaterMouseOut, type: \"target\" }))))));\n    };\n    EdgeWrapper.displayName = 'EdgeWrapper';\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeWrapper);\n};\n\nfunction createEdgeTypes(edgeTypes) {\n    const standardTypes = {\n        default: wrapEdge((edgeTypes.default || BezierEdge)),\n        straight: wrapEdge((edgeTypes.bezier || StraightEdge)),\n        step: wrapEdge((edgeTypes.step || StepEdge)),\n        smoothstep: wrapEdge((edgeTypes.step || SmoothStepEdge)),\n        simplebezier: wrapEdge((edgeTypes.simplebezier || SimpleBezierEdge)),\n    };\n    const wrappedTypes = {};\n    const specialTypes = Object.keys(edgeTypes)\n        .filter((k) => !['default', 'bezier'].includes(k))\n        .reduce((res, key) => {\n        res[key] = wrapEdge((edgeTypes[key] || BezierEdge));\n        return res;\n    }, wrappedTypes);\n    return {\n        ...standardTypes,\n        ...specialTypes,\n    };\n}\nfunction getHandlePosition(position, nodeRect, handle = null) {\n    const x = (handle?.x || 0) + nodeRect.x;\n    const y = (handle?.y || 0) + nodeRect.y;\n    const width = handle?.width || nodeRect.width;\n    const height = handle?.height || nodeRect.height;\n    switch (position) {\n        case Position.Top:\n            return {\n                x: x + width / 2,\n                y,\n            };\n        case Position.Right:\n            return {\n                x: x + width,\n                y: y + height / 2,\n            };\n        case Position.Bottom:\n            return {\n                x: x + width / 2,\n                y: y + height,\n            };\n        case Position.Left:\n            return {\n                x,\n                y: y + height / 2,\n            };\n    }\n}\nfunction getHandle(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    if (bounds.length === 1 || !handleId) {\n        return bounds[0];\n    }\n    else if (handleId) {\n        return bounds.find((d) => d.id === handleId) || null;\n    }\n    return null;\n}\nconst getEdgePositions = (sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition) => {\n    const sourceHandlePos = getHandlePosition(sourcePosition, sourceNodeRect, sourceHandle);\n    const targetHandlePos = getHandlePosition(targetPosition, targetNodeRect, targetHandle);\n    return {\n        sourceX: sourceHandlePos.x,\n        sourceY: sourceHandlePos.y,\n        targetX: targetHandlePos.x,\n        targetY: targetHandlePos.y,\n    };\n};\nfunction isEdgeVisible({ sourcePos, targetPos, sourceWidth, sourceHeight, targetWidth, targetHeight, width, height, transform, }) {\n    const edgeBox = {\n        x: Math.min(sourcePos.x, targetPos.x),\n        y: Math.min(sourcePos.y, targetPos.y),\n        x2: Math.max(sourcePos.x + sourceWidth, targetPos.x + targetWidth),\n        y2: Math.max(sourcePos.y + sourceHeight, targetPos.y + targetHeight),\n    };\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewBox = rectToBox({\n        x: (0 - transform[0]) / transform[2],\n        y: (0 - transform[1]) / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    });\n    const xOverlap = Math.max(0, Math.min(viewBox.x2, edgeBox.x2) - Math.max(viewBox.x, edgeBox.x));\n    const yOverlap = Math.max(0, Math.min(viewBox.y2, edgeBox.y2) - Math.max(viewBox.y, edgeBox.y));\n    const overlappingArea = Math.ceil(xOverlap * yOverlap);\n    return overlappingArea > 0;\n}\nfunction getNodeData(node) {\n    const handleBounds = node?.[internalsSymbol]?.handleBounds || null;\n    const isValid = handleBounds &&\n        node?.width &&\n        node?.height &&\n        typeof node?.positionAbsolute?.x !== 'undefined' &&\n        typeof node?.positionAbsolute?.y !== 'undefined';\n    return [\n        {\n            x: node?.positionAbsolute?.x || 0,\n            y: node?.positionAbsolute?.y || 0,\n            width: node?.width || 0,\n            height: node?.height || 0,\n        },\n        handleBounds,\n        !!isValid,\n    ];\n}\n\nconst defaultEdgeTree = [{ level: 0, isMaxLevel: true, edges: [] }];\nfunction groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect = false) {\n    let maxLevel = -1;\n    const levelLookup = edges.reduce((tree, edge) => {\n        const hasZIndex = isNumeric(edge.zIndex);\n        let z = hasZIndex ? edge.zIndex : 0;\n        if (elevateEdgesOnSelect) {\n            const targetNode = nodeInternals.get(edge.target);\n            const sourceNode = nodeInternals.get(edge.source);\n            const edgeOrConnectedNodeSelected = edge.selected || targetNode?.selected || sourceNode?.selected;\n            const selectedZIndex = Math.max(sourceNode?.[internalsSymbol]?.z || 0, targetNode?.[internalsSymbol]?.z || 0, 1000);\n            z = (hasZIndex ? edge.zIndex : 0) + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);\n        }\n        if (tree[z]) {\n            tree[z].push(edge);\n        }\n        else {\n            tree[z] = [edge];\n        }\n        maxLevel = z > maxLevel ? z : maxLevel;\n        return tree;\n    }, {});\n    const edgeTree = Object.entries(levelLookup).map(([key, edges]) => {\n        const level = +key;\n        return {\n            edges,\n            level,\n            isMaxLevel: level === maxLevel,\n        };\n    });\n    if (edgeTree.length === 0) {\n        return defaultEdgeTree;\n    }\n    return edgeTree;\n}\nfunction useVisibleEdges(onlyRenderVisible, nodeInternals, elevateEdgesOnSelect) {\n    const edges = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s) => {\n        if (!onlyRenderVisible) {\n            return s.edges;\n        }\n        return s.edges.filter((e) => {\n            const sourceNode = nodeInternals.get(e.source);\n            const targetNode = nodeInternals.get(e.target);\n            return (sourceNode?.width &&\n                sourceNode?.height &&\n                targetNode?.width &&\n                targetNode?.height &&\n                isEdgeVisible({\n                    sourcePos: sourceNode.positionAbsolute || { x: 0, y: 0 },\n                    targetPos: targetNode.positionAbsolute || { x: 0, y: 0 },\n                    sourceWidth: sourceNode.width,\n                    sourceHeight: sourceNode.height,\n                    targetWidth: targetNode.width,\n                    targetHeight: targetNode.height,\n                    width: s.width,\n                    height: s.height,\n                    transform: s.transform,\n                }));\n        });\n    }, [onlyRenderVisible, nodeInternals]));\n    return groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect);\n}\n\nconst ArrowSymbol = ({ color = 'none', strokeWidth = 1 }) => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"polyline\", { style: {\n            stroke: color,\n            strokeWidth,\n        }, strokeLinecap: \"round\", strokeLinejoin: \"round\", fill: \"none\", points: \"-5,-4 0,0 -5,4\" }));\n};\nconst ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 }) => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"polyline\", { style: {\n            stroke: color,\n            fill: color,\n            strokeWidth,\n        }, strokeLinecap: \"round\", strokeLinejoin: \"round\", points: \"-5,-4 0,0 -5,4 -5,-4\" }));\n};\nconst MarkerSymbols = {\n    [MarkerType.Arrow]: ArrowSymbol,\n    [MarkerType.ArrowClosed]: ArrowClosedSymbol,\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n        if (!symbolExists) {\n            store.getState().onError?.('009', errorMessages['error009'](type));\n            return null;\n        }\n        return MarkerSymbols[type];\n    }, [type]);\n    return symbol;\n}\n\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse', }) => {\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"marker\", { className: \"react-flow__arrowhead\", id: id, markerWidth: `${width}`, markerHeight: `${height}`, viewBox: \"-10 -10 20 20\", markerUnits: markerUnits, orient: orient, refX: \"0\", refY: \"0\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Symbol, { color: color, strokeWidth: strokeWidth })));\n};\nconst markerSelector = ({ defaultColor, rfId }) => (s) => {\n    const ids = [];\n    return s.edges\n        .reduce((markers, edge) => {\n        [edge.markerStart, edge.markerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, rfId);\n                if (!ids.includes(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.push(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n};\n// when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n// when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n// that we can then use for creating our unique marker ids\nconst MarkerDefinitions = ({ defaultColor, rfId }) => {\n    const markers = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(markerSelector({ defaultColor, rfId }), [defaultColor, rfId]), \n    // the id includes all marker options, so we just need to look at that part of the marker\n    (a, b) => !(a.length !== b.length || a.some((m, i) => m.id !== b[i].id)));\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, markers.map((marker) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Marker, { id: marker.id, key: marker.id, type: marker.type, color: marker.color, width: marker.width, height: marker.height, markerUnits: marker.markerUnits, strokeWidth: marker.strokeWidth, orient: marker.orient })))));\n};\nMarkerDefinitions.displayName = 'MarkerDefinitions';\nvar MarkerDefinitions$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MarkerDefinitions);\n\nconst selector$4 = (s) => ({\n    nodesConnectable: s.nodesConnectable,\n    edgesFocusable: s.edgesFocusable,\n    edgesUpdatable: s.edgesUpdatable,\n    elementsSelectable: s.elementsSelectable,\n    width: s.width,\n    height: s.height,\n    connectionMode: s.connectionMode,\n    nodeInternals: s.nodeInternals,\n    onError: s.onError,\n});\nconst EdgeRenderer = ({ defaultMarkerColor, onlyRenderVisibleElements, elevateEdgesOnSelect, rfId, edgeTypes, noPanClassName, onEdgeUpdate, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, edgeUpdaterRadius, onEdgeDoubleClick, onEdgeUpdateStart, onEdgeUpdateEnd, children, }) => {\n    const { edgesFocusable, edgesUpdatable, elementsSelectable, width, height, connectionMode, nodeInternals, onError } = useStore(selector$4, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const edgeTree = useVisibleEdges(onlyRenderVisibleElements, nodeInternals, elevateEdgesOnSelect);\n    if (!width) {\n        return null;\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        edgeTree.map(({ level, edges, isMaxLevel }) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { key: level, style: { zIndex: level }, width: width, height: height, className: \"react-flow__edges react-flow__container\" },\n            isMaxLevel && react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerDefinitions$1, { defaultColor: defaultMarkerColor, rfId: rfId }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", null, edges.map((edge) => {\n                const [sourceNodeRect, sourceHandleBounds, sourceIsValid] = getNodeData(nodeInternals.get(edge.source));\n                const [targetNodeRect, targetHandleBounds, targetIsValid] = getNodeData(nodeInternals.get(edge.target));\n                if (!sourceIsValid || !targetIsValid) {\n                    return null;\n                }\n                let edgeType = edge.type || 'default';\n                if (!edgeTypes[edgeType]) {\n                    onError?.('011', errorMessages['error011'](edgeType));\n                    edgeType = 'default';\n                }\n                const EdgeComponent = edgeTypes[edgeType] || edgeTypes.default;\n                // when connection type is loose we can define all handles as sources and connect source -> source\n                const targetNodeHandles = connectionMode === ConnectionMode.Strict\n                    ? targetHandleBounds.target\n                    : (targetHandleBounds.target ?? []).concat(targetHandleBounds.source ?? []);\n                const sourceHandle = getHandle(sourceHandleBounds.source, edge.sourceHandle);\n                const targetHandle = getHandle(targetNodeHandles, edge.targetHandle);\n                const sourcePosition = sourceHandle?.position || Position.Bottom;\n                const targetPosition = targetHandle?.position || Position.Top;\n                const isFocusable = !!(edge.focusable || (edgesFocusable && typeof edge.focusable === 'undefined'));\n                const isUpdatable = typeof onEdgeUpdate !== 'undefined' &&\n                    (edge.updatable || (edgesUpdatable && typeof edge.updatable === 'undefined'));\n                if (!sourceHandle || !targetHandle) {\n                    onError?.('008', errorMessages['error008'](sourceHandle, edge));\n                    return null;\n                }\n                const { sourceX, sourceY, targetX, targetY } = getEdgePositions(sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition);\n                return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeComponent, { key: edge.id, id: edge.id, className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([edge.className, noPanClassName]), type: edgeType, data: edge.data, selected: !!edge.selected, animated: !!edge.animated, hidden: !!edge.hidden, label: edge.label, labelStyle: edge.labelStyle, labelShowBg: edge.labelShowBg, labelBgStyle: edge.labelBgStyle, labelBgPadding: edge.labelBgPadding, labelBgBorderRadius: edge.labelBgBorderRadius, style: edge.style, source: edge.source, target: edge.target, sourceHandleId: edge.sourceHandle, targetHandleId: edge.targetHandle, markerEnd: edge.markerEnd, markerStart: edge.markerStart, sourceX: sourceX, sourceY: sourceY, targetX: targetX, targetY: targetY, sourcePosition: sourcePosition, targetPosition: targetPosition, elementsSelectable: elementsSelectable, onEdgeUpdate: onEdgeUpdate, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onClick: onEdgeClick, edgeUpdaterRadius: edgeUpdaterRadius, onEdgeDoubleClick: onEdgeDoubleClick, onEdgeUpdateStart: onEdgeUpdateStart, onEdgeUpdateEnd: onEdgeUpdateEnd, rfId: rfId, ariaLabel: edge.ariaLabel, isFocusable: isFocusable, isUpdatable: isUpdatable, pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined, interactionWidth: edge.interactionWidth }));\n            }))))),\n        children));\n};\nEdgeRenderer.displayName = 'EdgeRenderer';\nvar EdgeRenderer$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeRenderer);\n\nconst selector$3 = (s) => `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$3);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"react-flow__viewport react-flow__container\", style: { transform } }, children));\n}\n\nfunction useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n            setTimeout(() => onInit(rfInstance), 1);\n            isInitialized.current = true;\n        }\n    }, [onInit, rfInstance.viewportInitialized]);\n}\n\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\nconst ConnectionLine = ({ nodeId, handleType, style, type = ConnectionLineType.Bezier, CustomComponent, connectionStatus, }) => {\n    const { fromNode, handleId, toX, toY, connectionMode } = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s) => ({\n        fromNode: s.nodeInternals.get(nodeId),\n        handleId: s.connectionHandleId,\n        toX: (s.connectionPosition.x - s.transform[0]) / s.transform[2],\n        toY: (s.connectionPosition.y - s.transform[1]) / s.transform[2],\n        connectionMode: s.connectionMode,\n    }), [nodeId]), zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const fromHandleBounds = fromNode?.[internalsSymbol]?.handleBounds;\n    let handleBounds = fromHandleBounds?.[handleType];\n    if (connectionMode === ConnectionMode.Loose) {\n        handleBounds = handleBounds ? handleBounds : fromHandleBounds?.[handleType === 'source' ? 'target' : 'source'];\n    }\n    if (!fromNode || !handleBounds) {\n        return null;\n    }\n    const fromHandle = handleId ? handleBounds.find((d) => d.id === handleId) : handleBounds[0];\n    const fromHandleX = fromHandle ? fromHandle.x + fromHandle.width / 2 : (fromNode.width ?? 0) / 2;\n    const fromHandleY = fromHandle ? fromHandle.y + fromHandle.height / 2 : fromNode.height ?? 0;\n    const fromX = (fromNode.positionAbsolute?.x ?? 0) + fromHandleX;\n    const fromY = (fromNode.positionAbsolute?.y ?? 0) + fromHandleY;\n    const fromPosition = fromHandle?.position;\n    const toPosition = fromPosition ? oppositePosition[fromPosition] : null;\n    if (!fromPosition || !toPosition) {\n        return null;\n    }\n    if (CustomComponent) {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomComponent, { connectionLineType: type, connectionLineStyle: style, fromNode: fromNode, fromHandle: fromHandle, fromX: fromX, fromY: fromY, toX: toX, toY: toY, fromPosition: fromPosition, toPosition: toPosition, connectionStatus: connectionStatus }));\n    }\n    let dAttr = '';\n    const pathParams = {\n        sourceX: fromX,\n        sourceY: fromY,\n        sourcePosition: fromPosition,\n        targetX: toX,\n        targetY: toY,\n        targetPosition: toPosition,\n    };\n    if (type === ConnectionLineType.Bezier) {\n        // we assume the destination position is opposite to the source position\n        [dAttr] = getBezierPath(pathParams);\n    }\n    else if (type === ConnectionLineType.Step) {\n        [dAttr] = getSmoothStepPath({\n            ...pathParams,\n            borderRadius: 0,\n        });\n    }\n    else if (type === ConnectionLineType.SmoothStep) {\n        [dAttr] = getSmoothStepPath(pathParams);\n    }\n    else if (type === ConnectionLineType.SimpleBezier) {\n        [dAttr] = getSimpleBezierPath(pathParams);\n    }\n    else {\n        dAttr = `M${fromX},${fromY} ${toX},${toY}`;\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: dAttr, fill: \"none\", className: \"react-flow__connection-path\", style: style });\n};\nConnectionLine.displayName = 'ConnectionLine';\nconst selector$2 = (s) => ({\n    nodeId: s.connectionNodeId,\n    handleType: s.connectionHandleType,\n    nodesConnectable: s.nodesConnectable,\n    connectionStatus: s.connectionStatus,\n    width: s.width,\n    height: s.height,\n});\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodeId, handleType, nodesConnectable, width, height, connectionStatus } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const isValid = !!(nodeId && handleType && width && nodesConnectable);\n    if (!isValid) {\n        return null;\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { style: containerStyle, width: width, height: height, className: \"react-flow__edges react-flow__connectionline react-flow__container\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(['react-flow__connection', connectionStatus]) },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConnectionLine, { nodeId: nodeId, handleType: handleType, style: style, type: type, CustomComponent: component, connectionStatus: connectionStatus }))));\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypes(nodeOrEdgeTypes, createTypes) {\n    const typesKeysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const store = useStoreApi();\n    const typesParsed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (true) {\n            const typeKeys = Object.keys(nodeOrEdgeTypes);\n            if ((0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(typesKeysRef.current, typeKeys)) {\n                store.getState().onError?.('002', errorMessages['error002']());\n            }\n            typesKeysRef.current = typeKeys;\n        }\n        return createTypes(nodeOrEdgeTypes);\n    }, [nodeOrEdgeTypes]);\n    return typesParsed;\n}\n\nconst GraphView = ({ nodeTypes, edgeTypes, onMove, onMoveStart, onMoveEnd, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, selectNodesOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, onEdgeUpdate, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, edgeUpdaterRadius, onEdgeUpdateStart, onEdgeUpdateEnd, noDragClassName, noWheelClassName, noPanClassName, elevateEdgesOnSelect, disableKeyboardA11y, nodeOrigin, nodeExtent, rfId, }) => {\n    const nodeTypesWrapped = useNodeOrEdgeTypes(nodeTypes, createNodeTypes);\n    const edgeTypesWrapped = useNodeOrEdgeTypes(edgeTypes, createEdgeTypes);\n    useOnInitHandler(onInit);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(FlowRenderer$1, { onPaneClick: onPaneClick, onPaneMouseEnter: onPaneMouseEnter, onPaneMouseMove: onPaneMouseMove, onPaneMouseLeave: onPaneMouseLeave, onPaneContextMenu: onPaneContextMenu, onPaneScroll: onPaneScroll, deleteKeyCode: deleteKeyCode, selectionKeyCode: selectionKeyCode, selectionOnDrag: selectionOnDrag, selectionMode: selectionMode, onSelectionStart: onSelectionStart, onSelectionEnd: onSelectionEnd, multiSelectionKeyCode: multiSelectionKeyCode, panActivationKeyCode: panActivationKeyCode, zoomActivationKeyCode: zoomActivationKeyCode, elementsSelectable: elementsSelectable, onMove: onMove, onMoveStart: onMoveStart, onMoveEnd: onMoveEnd, zoomOnScroll: zoomOnScroll, zoomOnPinch: zoomOnPinch, zoomOnDoubleClick: zoomOnDoubleClick, panOnScroll: panOnScroll, panOnScrollSpeed: panOnScrollSpeed, panOnScrollMode: panOnScrollMode, panOnDrag: panOnDrag, defaultViewport: defaultViewport, translateExtent: translateExtent, minZoom: minZoom, maxZoom: maxZoom, onSelectionContextMenu: onSelectionContextMenu, preventScrolling: preventScrolling, noDragClassName: noDragClassName, noWheelClassName: noWheelClassName, noPanClassName: noPanClassName, disableKeyboardA11y: disableKeyboardA11y },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Viewport, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeRenderer$1, { edgeTypes: edgeTypesWrapped, onEdgeClick: onEdgeClick, onEdgeDoubleClick: onEdgeDoubleClick, onEdgeUpdate: onEdgeUpdate, onlyRenderVisibleElements: onlyRenderVisibleElements, onEdgeContextMenu: onEdgeContextMenu, onEdgeMouseEnter: onEdgeMouseEnter, onEdgeMouseMove: onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave, onEdgeUpdateStart: onEdgeUpdateStart, onEdgeUpdateEnd: onEdgeUpdateEnd, edgeUpdaterRadius: edgeUpdaterRadius, defaultMarkerColor: defaultMarkerColor, noPanClassName: noPanClassName, elevateEdgesOnSelect: !!elevateEdgesOnSelect, disableKeyboardA11y: disableKeyboardA11y, rfId: rfId },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConnectionLineWrapper, { style: connectionLineStyle, type: connectionLineType, component: connectionLineComponent, containerStyle: connectionLineContainerStyle })),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"react-flow__edgelabel-renderer\" }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeRenderer$1, { nodeTypes: nodeTypesWrapped, onNodeClick: onNodeClick, onNodeDoubleClick: onNodeDoubleClick, onNodeMouseEnter: onNodeMouseEnter, onNodeMouseMove: onNodeMouseMove, onNodeMouseLeave: onNodeMouseLeave, onNodeContextMenu: onNodeContextMenu, selectNodesOnDrag: selectNodesOnDrag, onlyRenderVisibleElements: onlyRenderVisibleElements, noPanClassName: noPanClassName, noDragClassName: noDragClassName, disableKeyboardA11y: disableKeyboardA11y, nodeOrigin: nodeOrigin, nodeExtent: nodeExtent, rfId: rfId }))));\n};\nGraphView.displayName = 'GraphView';\nvar GraphView$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GraphView);\n\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst initialState = {\n    rfId: '1',\n    width: 0,\n    height: 0,\n    transform: [0, 0, 1],\n    nodeInternals: new Map(),\n    edges: [],\n    onNodesChange: null,\n    onEdgesChange: null,\n    hasDefaultNodes: false,\n    hasDefaultEdges: false,\n    d3Zoom: null,\n    d3Selection: null,\n    d3ZoomHandler: undefined,\n    minZoom: 0.5,\n    maxZoom: 2,\n    translateExtent: infiniteExtent,\n    nodeExtent: infiniteExtent,\n    nodesSelectionActive: false,\n    userSelectionActive: false,\n    userSelectionRect: null,\n    connectionNodeId: null,\n    connectionHandleId: null,\n    connectionHandleType: 'source',\n    connectionPosition: { x: 0, y: 0 },\n    connectionStatus: null,\n    connectionMode: ConnectionMode.Strict,\n    domNode: null,\n    paneDragging: false,\n    noPanClassName: 'nopan',\n    nodeOrigin: [0, 0],\n    nodeDragThreshold: 0,\n    snapGrid: [15, 15],\n    snapToGrid: false,\n    nodesDraggable: true,\n    nodesConnectable: true,\n    nodesFocusable: true,\n    edgesFocusable: true,\n    edgesUpdatable: true,\n    elementsSelectable: true,\n    elevateNodesOnSelect: true,\n    fitViewOnInit: false,\n    fitViewOnInitDone: false,\n    fitViewOnInitOptions: undefined,\n    multiSelectionActive: false,\n    connectionStartHandle: null,\n    connectionEndHandle: null,\n    connectionClickStartHandle: null,\n    connectOnClick: true,\n    ariaLiveMessage: '',\n    autoPanOnConnect: true,\n    autoPanOnNodeDrag: true,\n    connectionRadius: 20,\n    onError: devWarn,\n    isValidConnection: undefined,\n};\n\nconst createRFStore = () => (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_4__.createWithEqualityFn)((set, get) => ({\n    ...initialState,\n    setNodes: (nodes) => {\n        const { nodeInternals, nodeOrigin, elevateNodesOnSelect } = get();\n        set({ nodeInternals: createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) });\n    },\n    getNodes: () => {\n        return Array.from(get().nodeInternals.values());\n    },\n    setEdges: (edges) => {\n        const { defaultEdgeOptions = {} } = get();\n        set({ edges: edges.map((e) => ({ ...defaultEdgeOptions, ...e })) });\n    },\n    setDefaultNodesAndEdges: (nodes, edges) => {\n        const hasDefaultNodes = typeof nodes !== 'undefined';\n        const hasDefaultEdges = typeof edges !== 'undefined';\n        const nodeInternals = hasDefaultNodes\n            ? createNodeInternals(nodes, new Map(), get().nodeOrigin, get().elevateNodesOnSelect)\n            : new Map();\n        const nextEdges = hasDefaultEdges ? edges : [];\n        set({ nodeInternals, edges: nextEdges, hasDefaultNodes, hasDefaultEdges });\n    },\n    updateNodeDimensions: (updates) => {\n        const { onNodesChange, nodeInternals, fitViewOnInit, fitViewOnInitDone, fitViewOnInitOptions, domNode, nodeOrigin, } = get();\n        const viewportNode = domNode?.querySelector('.react-flow__viewport');\n        if (!viewportNode) {\n            return;\n        }\n        const style = window.getComputedStyle(viewportNode);\n        const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n        const changes = updates.reduce((res, update) => {\n            const node = nodeInternals.get(update.id);\n            if (node) {\n                const dimensions = getDimensions(update.nodeElement);\n                const doUpdate = !!(dimensions.width &&\n                    dimensions.height &&\n                    (node.width !== dimensions.width || node.height !== dimensions.height || update.forceUpdate));\n                if (doUpdate) {\n                    nodeInternals.set(node.id, {\n                        ...node,\n                        [internalsSymbol]: {\n                            ...node[internalsSymbol],\n                            handleBounds: {\n                                source: getHandleBounds('.source', update.nodeElement, zoom, nodeOrigin),\n                                target: getHandleBounds('.target', update.nodeElement, zoom, nodeOrigin),\n                            },\n                        },\n                        ...dimensions,\n                    });\n                    res.push({\n                        id: node.id,\n                        type: 'dimensions',\n                        dimensions,\n                    });\n                }\n            }\n            return res;\n        }, []);\n        updateAbsoluteNodePositions(nodeInternals, nodeOrigin);\n        const nextFitViewOnInitDone = fitViewOnInitDone ||\n            (fitViewOnInit && !fitViewOnInitDone && fitView(get, { initial: true, ...fitViewOnInitOptions }));\n        set({ nodeInternals: new Map(nodeInternals), fitViewOnInitDone: nextFitViewOnInitDone });\n        if (changes?.length > 0) {\n            onNodesChange?.(changes);\n        }\n    },\n    updateNodePositions: (nodeDragItems, positionChanged = true, dragging = false) => {\n        const { triggerNodeChanges } = get();\n        const changes = nodeDragItems.map((node) => {\n            const change = {\n                id: node.id,\n                type: 'position',\n                dragging,\n            };\n            if (positionChanged) {\n                change.positionAbsolute = node.positionAbsolute;\n                change.position = node.position;\n            }\n            return change;\n        });\n        triggerNodeChanges(changes);\n    },\n    triggerNodeChanges: (changes) => {\n        const { onNodesChange, nodeInternals, hasDefaultNodes, nodeOrigin, getNodes, elevateNodesOnSelect } = get();\n        if (changes?.length) {\n            if (hasDefaultNodes) {\n                const nodes = applyNodeChanges(changes, getNodes());\n                const nextNodeInternals = createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect);\n                set({ nodeInternals: nextNodeInternals });\n            }\n            onNodesChange?.(changes);\n        }\n    },\n    addSelectedNodes: (selectedNodeIds) => {\n        const { multiSelectionActive, edges, getNodes } = get();\n        let changedNodes;\n        let changedEdges = null;\n        if (multiSelectionActive) {\n            changedNodes = selectedNodeIds.map((nodeId) => createSelectionChange(nodeId, true));\n        }\n        else {\n            changedNodes = getSelectionChanges(getNodes(), selectedNodeIds);\n            changedEdges = getSelectionChanges(edges, []);\n        }\n        updateNodesAndEdgesSelections({\n            changedNodes,\n            changedEdges,\n            get,\n            set,\n        });\n    },\n    addSelectedEdges: (selectedEdgeIds) => {\n        const { multiSelectionActive, edges, getNodes } = get();\n        let changedEdges;\n        let changedNodes = null;\n        if (multiSelectionActive) {\n            changedEdges = selectedEdgeIds.map((edgeId) => createSelectionChange(edgeId, true));\n        }\n        else {\n            changedEdges = getSelectionChanges(edges, selectedEdgeIds);\n            changedNodes = getSelectionChanges(getNodes(), []);\n        }\n        updateNodesAndEdgesSelections({\n            changedNodes,\n            changedEdges,\n            get,\n            set,\n        });\n    },\n    unselectNodesAndEdges: ({ nodes, edges } = {}) => {\n        const { edges: storeEdges, getNodes } = get();\n        const nodesToUnselect = nodes ? nodes : getNodes();\n        const edgesToUnselect = edges ? edges : storeEdges;\n        const changedNodes = nodesToUnselect.map((n) => {\n            n.selected = false;\n            return createSelectionChange(n.id, false);\n        });\n        const changedEdges = edgesToUnselect.map((edge) => createSelectionChange(edge.id, false));\n        updateNodesAndEdgesSelections({\n            changedNodes,\n            changedEdges,\n            get,\n            set,\n        });\n    },\n    setMinZoom: (minZoom) => {\n        const { d3Zoom, maxZoom } = get();\n        d3Zoom?.scaleExtent([minZoom, maxZoom]);\n        set({ minZoom });\n    },\n    setMaxZoom: (maxZoom) => {\n        const { d3Zoom, minZoom } = get();\n        d3Zoom?.scaleExtent([minZoom, maxZoom]);\n        set({ maxZoom });\n    },\n    setTranslateExtent: (translateExtent) => {\n        get().d3Zoom?.translateExtent(translateExtent);\n        set({ translateExtent });\n    },\n    resetSelectedElements: () => {\n        const { edges, getNodes } = get();\n        const nodes = getNodes();\n        const nodesToUnselect = nodes\n            .filter((e) => e.selected)\n            .map((n) => createSelectionChange(n.id, false));\n        const edgesToUnselect = edges\n            .filter((e) => e.selected)\n            .map((e) => createSelectionChange(e.id, false));\n        updateNodesAndEdgesSelections({\n            changedNodes: nodesToUnselect,\n            changedEdges: edgesToUnselect,\n            get,\n            set,\n        });\n    },\n    setNodeExtent: (nodeExtent) => {\n        const { nodeInternals } = get();\n        nodeInternals.forEach((node) => {\n            node.positionAbsolute = clampPosition(node.position, nodeExtent);\n        });\n        set({\n            nodeExtent,\n            nodeInternals: new Map(nodeInternals),\n        });\n    },\n    panBy: (delta) => {\n        const { transform, width, height, d3Zoom, d3Selection, translateExtent } = get();\n        if (!d3Zoom || !d3Selection || (!delta.x && !delta.y)) {\n            return false;\n        }\n        const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity\n            .translate(transform[0] + delta.x, transform[1] + delta.y)\n            .scale(transform[2]);\n        const extent = [\n            [0, 0],\n            [width, height],\n        ];\n        const constrainedTransform = d3Zoom?.constrain()(nextTransform, extent, translateExtent);\n        d3Zoom.transform(d3Selection, constrainedTransform);\n        const transformChanged = transform[0] !== constrainedTransform.x ||\n            transform[1] !== constrainedTransform.y ||\n            transform[2] !== constrainedTransform.k;\n        return transformChanged;\n    },\n    cancelConnection: () => set({\n        connectionNodeId: initialState.connectionNodeId,\n        connectionHandleId: initialState.connectionHandleId,\n        connectionHandleType: initialState.connectionHandleType,\n        connectionStatus: initialState.connectionStatus,\n        connectionStartHandle: initialState.connectionStartHandle,\n        connectionEndHandle: initialState.connectionEndHandle,\n    }),\n    reset: () => set({ ...initialState }),\n}), Object.is);\n\nconst ReactFlowProvider = ({ children }) => {\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (!storeRef.current) {\n        storeRef.current = createRFStore();\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider$1, { value: storeRef.current }, children);\n};\nReactFlowProvider.displayName = 'ReactFlowProvider';\n\nconst Wrapper = ({ children }) => {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (isWrapped) {\n        // we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactFlowProvider, null, children);\n};\nWrapper.displayName = 'ReactFlowWrapper';\n\nconst defaultNodeTypes = {\n    input: InputNode$1,\n    default: DefaultNode$1,\n    output: OutputNode$1,\n    group: GroupNode,\n};\nconst defaultEdgeTypes = {\n    default: BezierEdge,\n    straight: StraightEdge,\n    step: StepEdge,\n    smoothstep: SmoothStepEdge,\n    simplebezier: SimpleBezierEdge,\n};\nconst initNodeOrigin = [0, 0];\nconst initSnapGrid = [15, 15];\nconst initDefaultViewport = { x: 0, y: 0, zoom: 1 };\nconst wrapperStyle = {\n    width: '100%',\n    height: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n    zIndex: 0,\n};\nconst ReactFlow = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes = defaultNodeTypes, edgeTypes = defaultEdgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionMode = ConnectionMode.Strict, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = isMacOs() ? 'Meta' : 'Control', zoomActivationKeyCode = isMacOs() ? 'Meta' : 'Control', snapToGrid = false, snapGrid = initSnapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag = true, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = initNodeOrigin, edgesFocusable, edgesUpdatable, elementsSelectable, defaultViewport = initDefaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, children, onEdgeUpdate, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeUpdateStart, onEdgeUpdateEnd, edgeUpdaterRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView = false, fitViewOptions, connectOnClick = true, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = true, elevateEdgesOnSelect = false, disableKeyboardA11y = false, autoPanOnConnect = true, autoPanOnNodeDrag = true, connectionRadius = 20, isValidConnection, onError, style, id, nodeDragThreshold, ...rest }, ref) => {\n    const rfId = id || '1';\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ...rest, style: { ...style, ...wrapperStyle }, ref: ref, className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(['react-flow', className]), \"data-testid\": \"rf__wrapper\", id: id },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(GraphView$1, { onInit: onInit, onMove: onMove, onMoveStart: onMoveStart, onMoveEnd: onMoveEnd, onNodeClick: onNodeClick, onEdgeClick: onEdgeClick, onNodeMouseEnter: onNodeMouseEnter, onNodeMouseMove: onNodeMouseMove, onNodeMouseLeave: onNodeMouseLeave, onNodeContextMenu: onNodeContextMenu, onNodeDoubleClick: onNodeDoubleClick, nodeTypes: nodeTypes, edgeTypes: edgeTypes, connectionLineType: connectionLineType, connectionLineStyle: connectionLineStyle, connectionLineComponent: connectionLineComponent, connectionLineContainerStyle: connectionLineContainerStyle, selectionKeyCode: selectionKeyCode, selectionOnDrag: selectionOnDrag, selectionMode: selectionMode, deleteKeyCode: deleteKeyCode, multiSelectionKeyCode: multiSelectionKeyCode, panActivationKeyCode: panActivationKeyCode, zoomActivationKeyCode: zoomActivationKeyCode, onlyRenderVisibleElements: onlyRenderVisibleElements, selectNodesOnDrag: selectNodesOnDrag, defaultViewport: defaultViewport, translateExtent: translateExtent, minZoom: minZoom, maxZoom: maxZoom, preventScrolling: preventScrolling, zoomOnScroll: zoomOnScroll, zoomOnPinch: zoomOnPinch, zoomOnDoubleClick: zoomOnDoubleClick, panOnScroll: panOnScroll, panOnScrollSpeed: panOnScrollSpeed, panOnScrollMode: panOnScrollMode, panOnDrag: panOnDrag, onPaneClick: onPaneClick, onPaneMouseEnter: onPaneMouseEnter, onPaneMouseMove: onPaneMouseMove, onPaneMouseLeave: onPaneMouseLeave, onPaneScroll: onPaneScroll, onPaneContextMenu: onPaneContextMenu, onSelectionContextMenu: onSelectionContextMenu, onSelectionStart: onSelectionStart, onSelectionEnd: onSelectionEnd, onEdgeUpdate: onEdgeUpdate, onEdgeContextMenu: onEdgeContextMenu, onEdgeDoubleClick: onEdgeDoubleClick, onEdgeMouseEnter: onEdgeMouseEnter, onEdgeMouseMove: onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave, onEdgeUpdateStart: onEdgeUpdateStart, onEdgeUpdateEnd: onEdgeUpdateEnd, edgeUpdaterRadius: edgeUpdaterRadius, defaultMarkerColor: defaultMarkerColor, noDragClassName: noDragClassName, noWheelClassName: noWheelClassName, noPanClassName: noPanClassName, elevateEdgesOnSelect: elevateEdgesOnSelect, rfId: rfId, disableKeyboardA11y: disableKeyboardA11y, nodeOrigin: nodeOrigin, nodeExtent: nodeExtent }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(StoreUpdater, { nodes: nodes, edges: edges, defaultNodes: defaultNodes, defaultEdges: defaultEdges, onConnect: onConnect, onConnectStart: onConnectStart, onConnectEnd: onConnectEnd, onClickConnectStart: onClickConnectStart, onClickConnectEnd: onClickConnectEnd, nodesDraggable: nodesDraggable, nodesConnectable: nodesConnectable, nodesFocusable: nodesFocusable, edgesFocusable: edgesFocusable, edgesUpdatable: edgesUpdatable, elementsSelectable: elementsSelectable, elevateNodesOnSelect: elevateNodesOnSelect, minZoom: minZoom, maxZoom: maxZoom, nodeExtent: nodeExtent, onNodesChange: onNodesChange, onEdgesChange: onEdgesChange, snapToGrid: snapToGrid, snapGrid: snapGrid, connectionMode: connectionMode, translateExtent: translateExtent, connectOnClick: connectOnClick, defaultEdgeOptions: defaultEdgeOptions, fitView: fitView, fitViewOptions: fitViewOptions, onNodesDelete: onNodesDelete, onEdgesDelete: onEdgesDelete, onNodeDragStart: onNodeDragStart, onNodeDrag: onNodeDrag, onNodeDragStop: onNodeDragStop, onSelectionDrag: onSelectionDrag, onSelectionDragStart: onSelectionDragStart, onSelectionDragStop: onSelectionDragStop, noPanClassName: noPanClassName, nodeOrigin: nodeOrigin, rfId: rfId, autoPanOnConnect: autoPanOnConnect, autoPanOnNodeDrag: autoPanOnNodeDrag, onError: onError, connectionRadius: connectionRadius, isValidConnection: isValidConnection, nodeDragThreshold: nodeDragThreshold }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper$1, { onSelectionChange: onSelectionChange }),\n            children,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(Attribution, { proOptions: proOptions, position: attributionPosition }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(A11yDescriptions, { rfId: rfId, disableKeyboardA11y: disableKeyboardA11y }))));\n});\nReactFlow.displayName = 'ReactFlow';\n\nconst selector$1 = (s) => s.domNode?.querySelector('.react-flow__edgelabel-renderer');\nfunction EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$1);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal)(children, edgeLabelRenderer);\n}\n\nfunction useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n        const { domNode, updateNodeDimensions } = store.getState();\n        const updateIds = Array.isArray(id) ? id : [id];\n        const updates = updateIds.reduce((res, updateId) => {\n            const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n            if (nodeElement) {\n                res.push({ id: updateId, nodeElement, forceUpdate: true });\n            }\n            return res;\n        }, []);\n        requestAnimationFrame(() => updateNodeDimensions(updates));\n    }, []);\n}\n\nconst nodesSelector = (state) => state.getNodes();\nfunction useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return nodes;\n}\n\nconst edgesSelector = (state) => state.edges;\nfunction useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return edges;\n}\n\nconst viewportSelector = (state) => ({\n    x: state.transform[0],\n    y: state.transform[1],\n    zoom: state.transform[2],\n});\nfunction useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return viewport;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createUseItemsState(applyChanges) {\n    return (initialItems) => {\n        const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialItems);\n        const onItemsChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((changes) => setItems((items) => applyChanges(changes, items)), []);\n        return [items, setItems, onItemsChange];\n    };\n}\nconst useNodesState = createUseItemsState(applyNodeChanges);\nconst useEdgesState = createUseItemsState(applyEdgeChanges);\n\nfunction useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        store.setState({ onViewportChangeStart: onStart });\n    }, [onStart]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        store.setState({ onViewportChange: onChange });\n    }, [onChange]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        store.setState({ onViewportChangeEnd: onEnd });\n    }, [onEnd]);\n}\n\nfunction useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        store.setState({ onSelectionChange: onChange });\n    }, [onChange]);\n}\n\nconst selector = (options) => (s) => {\n    if (s.nodeInternals.size === 0) {\n        return false;\n    }\n    return s\n        .getNodes()\n        .filter((n) => (options.includeHiddenNodes ? true : !n.hidden))\n        .every((n) => n[internalsSymbol]?.handleBounds !== undefined);\n};\nconst defaultOptions = {\n    includeHiddenNodes: false,\n};\nfunction useNodesInitialized(options = defaultOptions) {\n    const initialized = useStore(selector(options));\n    return initialized;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdGZsb3crY29yZUAxMS45LjNfQHR5cGVzK3JlYWN0QDE4LjIuNV9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlYWN0Zmxvdy9jb3JlL2Rpc3QvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4SDtBQUNwRztBQUN5RDtBQUN6QztBQUNHO0FBQ0U7QUFDaEI7QUFDVTs7QUFFekMscUJBQXFCLG9EQUFhO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xELHdDQUF3QyxLQUFLO0FBQzdDLGtFQUFrRSxxQ0FBcUMsY0FBYyxzREFBc0QsY0FBYyxRQUFRO0FBQ2pNO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQsdUNBQXVDLEdBQUc7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixpREFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJFQUFzQjtBQUNqQztBQUNBO0FBQ0Esa0JBQWtCLGlEQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxpQkFBaUIsK0NBQStDO0FBQ2hFO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEMsWUFBWSxnREFBbUIsVUFBVSxXQUFXLG9EQUFFLGlFQUFpRSx5QkFBeUIsV0FBVztBQUMzSjs7QUFFQSx1QkFBdUIsdUNBQXVDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQW1CLFVBQVUsb0xBQW9MO0FBQzdOLFFBQVEsZ0RBQW1CLFFBQVEscUhBQXFIO0FBQ3hKOztBQUVBLG9CQUFvQiw0QkFBNEIsdUNBQXVDLGtGQUFrRjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0Zmxvdytjb3JlQDExLjkuM19AdHlwZXMrcmVhY3RAMTguMi41X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVhY3RmbG93L2NvcmUvZGlzdC9lc20vaW5kZXgubWpzPzk0N2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIG1lbW8sIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbiwgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tICd6dXN0YW5kL3NoYWxsb3cnO1xuaW1wb3J0IHsgem9vbUlkZW50aXR5LCB6b29tIH0gZnJvbSAnZDMtem9vbSc7XG5pbXBvcnQgeyBzZWxlY3QsIHBvaW50ZXIgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgZHJhZyB9IGZyb20gJ2QzLWRyYWcnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IFByb3ZpZGVyJDEgPSBTdG9yZUNvbnRleHQuUHJvdmlkZXI7XG5cbmNvbnN0IGVycm9yTWVzc2FnZXMgPSB7XG4gICAgZXJyb3IwMDE6ICgpID0+ICdbUmVhY3QgRmxvd106IFNlZW1zIGxpa2UgeW91IGhhdmUgbm90IHVzZWQgenVzdGFuZCBwcm92aWRlciBhcyBhbiBhbmNlc3Rvci4gSGVscDogaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2Vycm9yIzAwMScsXG4gICAgZXJyb3IwMDI6ICgpID0+IFwiSXQgbG9va3MgbGlrZSB5b3UndmUgY3JlYXRlZCBhIG5ldyBub2RlVHlwZXMgb3IgZWRnZVR5cGVzIG9iamVjdC4gSWYgdGhpcyB3YXNuJ3Qgb24gcHVycG9zZSBwbGVhc2UgZGVmaW5lIHRoZSBub2RlVHlwZXMvZWRnZVR5cGVzIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudCBvciBtZW1vaXplIHRoZW0uXCIsXG4gICAgZXJyb3IwMDM6IChub2RlVHlwZSkgPT4gYE5vZGUgdHlwZSBcIiR7bm9kZVR5cGV9XCIgbm90IGZvdW5kLiBVc2luZyBmYWxsYmFjayB0eXBlIFwiZGVmYXVsdFwiLmAsXG4gICAgZXJyb3IwMDQ6ICgpID0+ICdUaGUgUmVhY3QgRmxvdyBwYXJlbnQgY29udGFpbmVyIG5lZWRzIGEgd2lkdGggYW5kIGEgaGVpZ2h0IHRvIHJlbmRlciB0aGUgZ3JhcGguJyxcbiAgICBlcnJvcjAwNTogKCkgPT4gJ09ubHkgY2hpbGQgbm9kZXMgY2FuIHVzZSBhIHBhcmVudCBleHRlbnQuJyxcbiAgICBlcnJvcjAwNjogKCkgPT4gXCJDYW4ndCBjcmVhdGUgZWRnZS4gQW4gZWRnZSBuZWVkcyBhIHNvdXJjZSBhbmQgYSB0YXJnZXQuXCIsXG4gICAgZXJyb3IwMDc6IChpZCkgPT4gYFRoZSBvbGQgZWRnZSB3aXRoIGlkPSR7aWR9IGRvZXMgbm90IGV4aXN0LmAsXG4gICAgZXJyb3IwMDk6ICh0eXBlKSA9PiBgTWFya2VyIHR5cGUgXCIke3R5cGV9XCIgZG9lc24ndCBleGlzdC5gLFxuICAgIGVycm9yMDA4OiAoc291cmNlSGFuZGxlLCBlZGdlKSA9PiBgQ291bGRuJ3QgY3JlYXRlIGVkZ2UgZm9yICR7IXNvdXJjZUhhbmRsZSA/ICdzb3VyY2UnIDogJ3RhcmdldCd9IGhhbmRsZSBpZDogXCIkeyFzb3VyY2VIYW5kbGUgPyBlZGdlLnNvdXJjZUhhbmRsZSA6IGVkZ2UudGFyZ2V0SGFuZGxlfVwiLCBlZGdlIGlkOiAke2VkZ2UuaWR9LmAsXG4gICAgZXJyb3IwMTA6ICgpID0+ICdIYW5kbGU6IE5vIG5vZGUgaWQgZm91bmQuIE1ha2Ugc3VyZSB0byBvbmx5IHVzZSBhIEhhbmRsZSBpbnNpZGUgYSBjdXN0b20gTm9kZS4nLFxuICAgIGVycm9yMDExOiAoZWRnZVR5cGUpID0+IGBFZGdlIHR5cGUgXCIke2VkZ2VUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDEyOiAoaWQpID0+IGBOb2RlIHdpdGggaWQgXCIke2lkfVwiIGRvZXMgbm90IGV4aXN0LCBpdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgbm9kZSBpcyBkZWxldGVkIGJlZm9yZSB0aGUgXCJvbk5vZGVDbGlja1wiIGhhbmRsZXIgaXMgY2FsbGVkLmAsXG59O1xuXG5jb25zdCB6dXN0YW5kRXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMDEnXSgpO1xuZnVuY3Rpb24gdXNlU3RvcmUoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihzdG9yZSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuY29uc3QgdXNlU3RvcmVBcGkgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogc3RvcmUuc2V0U3RhdGUsXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgICBkZXN0cm95OiBzdG9yZS5kZXN0cm95LFxuICAgIH0pLCBbc3RvcmVdKTtcbn07XG5cbmNvbnN0IHNlbGVjdG9yJGcgPSAocykgPT4gKHMudXNlclNlbGVjdGlvbkFjdGl2ZSA/ICdub25lJyA6ICdhbGwnKTtcbmZ1bmN0aW9uIFBhbmVsKHsgcG9zaXRpb24sIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCBwb2ludGVyRXZlbnRzID0gdXNlU3RvcmUoc2VsZWN0b3IkZyk7XG4gICAgY29uc3QgcG9zaXRpb25DbGFzc2VzID0gYCR7cG9zaXRpb259YC5zcGxpdCgnLScpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lbCcsIGNsYXNzTmFtZSwgLi4ucG9zaXRpb25DbGFzc2VzXSksIHN0eWxlOiB7IC4uLnN0eWxlLCBwb2ludGVyRXZlbnRzIH0sIC4uLnJlc3QgfSwgY2hpbGRyZW4pKTtcbn1cblxuZnVuY3Rpb24gQXR0cmlidXRpb24oeyBwcm9PcHRpb25zLCBwb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnIH0pIHtcbiAgICBpZiAocHJvT3B0aW9ucz8uaGlkZUF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXR0cmlidXRpb25cIiwgXCJkYXRhLW1lc3NhZ2VcIjogXCJQbGVhc2Ugb25seSBoaWRlIHRoaXMgYXR0cmlidXRpb24gd2hlbiB5b3UgYXJlIHN1YnNjcmliZWQgdG8gUmVhY3QgRmxvdyBQcm86IGh0dHBzOi8vcHJvLnJlYWN0Zmxvdy5kZXZcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGhyZWY6IFwiaHR0cHM6Ly9yZWFjdGZsb3cuZGV2XCIsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiwgXCJhcmlhLWxhYmVsXCI6IFwiUmVhY3QgRmxvdyBhdHRyaWJ1dGlvblwiIH0sIFwiUmVhY3QgRmxvd1wiKSkpO1xufVxuXG5jb25zdCBFZGdlVGV4dCA9ICh7IHgsIHksIGxhYmVsLCBsYWJlbFN0eWxlID0ge30sIGxhYmVsU2hvd0JnID0gdHJ1ZSwgbGFiZWxCZ1N0eWxlID0ge30sIGxhYmVsQmdQYWRkaW5nID0gWzIsIDRdLCBsYWJlbEJnQm9yZGVyUmFkaXVzID0gMiwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSA9PiB7XG4gICAgY29uc3QgZWRnZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBbZWRnZVRleHRCYm94LCBzZXRFZGdlVGV4dEJib3hdID0gdXNlU3RhdGUoeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0Q2xhc3NlcyA9IGNjKFsncmVhY3QtZmxvd19fZWRnZS10ZXh0d3JhcHBlcicsIGNsYXNzTmFtZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlZGdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRCYm94ID0gZWRnZVJlZi5jdXJyZW50LmdldEJCb3goKTtcbiAgICAgICAgICAgIHNldEVkZ2VUZXh0QmJveCh7XG4gICAgICAgICAgICAgICAgeDogdGV4dEJib3gueCxcbiAgICAgICAgICAgICAgICB5OiB0ZXh0QmJveC55LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXh0QmJveC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleHRCYm94LmhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2xhYmVsXSk7XG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWxhYmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7eCAtIGVkZ2VUZXh0QmJveC53aWR0aCAvIDJ9ICR7eSAtIGVkZ2VUZXh0QmJveC5oZWlnaHQgLyAyfSlgLCBjbGFzc05hbWU6IGVkZ2VUZXh0Q2xhc3NlcywgdmlzaWJpbGl0eTogZWRnZVRleHRCYm94LndpZHRoID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIC4uLnJlc3QgfSxcbiAgICAgICAgbGFiZWxTaG93QmcgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHsgd2lkdGg6IGVkZ2VUZXh0QmJveC53aWR0aCArIDIgKiBsYWJlbEJnUGFkZGluZ1swXSwgeDogLWxhYmVsQmdQYWRkaW5nWzBdLCB5OiAtbGFiZWxCZ1BhZGRpbmdbMV0sIGhlaWdodDogZWRnZVRleHRCYm94LmhlaWdodCArIDIgKiBsYWJlbEJnUGFkZGluZ1sxXSwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dGJnXCIsIHN0eWxlOiBsYWJlbEJnU3R5bGUsIHJ4OiBsYWJlbEJnQm9yZGVyUmFkaXVzLCByeTogbGFiZWxCZ0JvcmRlclJhZGl1cyB9KSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dFwiLCB5OiBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMiwgZHk6IFwiMC4zZW1cIiwgcmVmOiBlZGdlUmVmLCBzdHlsZTogbGFiZWxTdHlsZSB9LCBsYWJlbCksXG4gICAgICAgIGNoaWxkcmVuKSk7XG59O1xudmFyIEVkZ2VUZXh0JDEgPSBtZW1vKEVkZ2VUZXh0KTtcblxuY29uc3QgZ2V0RGltZW5zaW9ucyA9IChub2RlKSA9PiAoe1xuICAgIHdpZHRoOiBub2RlLm9mZnNldFdpZHRoLFxuICAgIGhlaWdodDogbm9kZS5vZmZzZXRIZWlnaHQsXG59KTtcbmNvbnN0IGNsYW1wID0gKHZhbCwgbWluID0gMCwgbWF4ID0gMSkgPT4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xuY29uc3QgY2xhbXBQb3NpdGlvbiA9IChwb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9LCBleHRlbnQpID0+ICh7XG4gICAgeDogY2xhbXAocG9zaXRpb24ueCwgZXh0ZW50WzBdWzBdLCBleHRlbnRbMV1bMF0pLFxuICAgIHk6IGNsYW1wKHBvc2l0aW9uLnksIGV4dGVudFswXVsxXSwgZXh0ZW50WzFdWzFdKSxcbn0pO1xuLy8gcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgdGhhdCByZXByZXNlbnRzIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbW92ZW1lbnRcbi8vIHdoZW4gdGhlIG1vdXNlIGlzIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBjYW52YXNcbmNvbnN0IGNhbGNBdXRvUGFuVmVsb2NpdHkgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1pbiksIDEsIDUwKSAvIDUwO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICByZXR1cm4gLWNsYW1wKE1hdGguYWJzKHZhbHVlIC0gbWF4KSwgMSwgNTApIC8gNTA7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcbmNvbnN0IGNhbGNBdXRvUGFuID0gKHBvcywgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgeE1vdmVtZW50ID0gY2FsY0F1dG9QYW5WZWxvY2l0eShwb3MueCwgMzUsIGJvdW5kcy53aWR0aCAtIDM1KSAqIDIwO1xuICAgIGNvbnN0IHlNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLnksIDM1LCBib3VuZHMuaGVpZ2h0IC0gMzUpICogMjA7XG4gICAgcmV0dXJuIFt4TW92ZW1lbnQsIHlNb3ZlbWVudF07XG59O1xuY29uc3QgZ2V0SG9zdEZvckVsZW1lbnQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRSb290Tm9kZT8uKCkgfHwgd2luZG93Py5kb2N1bWVudDtcbmNvbnN0IGdldEJvdW5kc09mQm94ZXMgPSAoYm94MSwgYm94MikgPT4gKHtcbiAgICB4OiBNYXRoLm1pbihib3gxLngsIGJveDIueCksXG4gICAgeTogTWF0aC5taW4oYm94MS55LCBib3gyLnkpLFxuICAgIHgyOiBNYXRoLm1heChib3gxLngyLCBib3gyLngyKSxcbiAgICB5MjogTWF0aC5tYXgoYm94MS55MiwgYm94Mi55MiksXG59KTtcbmNvbnN0IHJlY3RUb0JveCA9ICh7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSkgPT4gKHtcbiAgICB4LFxuICAgIHksXG4gICAgeDI6IHggKyB3aWR0aCxcbiAgICB5MjogeSArIGhlaWdodCxcbn0pO1xuY29uc3QgYm94VG9SZWN0ID0gKHsgeCwgeSwgeDIsIHkyIH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiB4MiAtIHgsXG4gICAgaGVpZ2h0OiB5MiAtIHksXG59KTtcbmNvbnN0IG5vZGVUb1JlY3QgPSAobm9kZSkgPT4gKHtcbiAgICAuLi4obm9kZS5wb3NpdGlvbkFic29sdXRlIHx8IHsgeDogMCwgeTogMCB9KSxcbiAgICB3aWR0aDogbm9kZS53aWR0aCB8fCAwLFxuICAgIGhlaWdodDogbm9kZS5oZWlnaHQgfHwgMCxcbn0pO1xuY29uc3QgZ2V0Qm91bmRzT2ZSZWN0cyA9IChyZWN0MSwgcmVjdDIpID0+IGJveFRvUmVjdChnZXRCb3VuZHNPZkJveGVzKHJlY3RUb0JveChyZWN0MSksIHJlY3RUb0JveChyZWN0MikpKTtcbmNvbnN0IGdldE92ZXJsYXBwaW5nQXJlYSA9IChyZWN0QSwgcmVjdEIpID0+IHtcbiAgICBjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnggKyByZWN0QS53aWR0aCwgcmVjdEIueCArIHJlY3RCLndpZHRoKSAtIE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpKTtcbiAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnkgKyByZWN0QS5oZWlnaHQsIHJlY3RCLnkgKyByZWN0Qi5oZWlnaHQpIC0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSkpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoeE92ZXJsYXAgKiB5T3ZlcmxhcCk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGlzUmVjdE9iamVjdCA9IChvYmopID0+IGlzTnVtZXJpYyhvYmoud2lkdGgpICYmIGlzTnVtZXJpYyhvYmouaGVpZ2h0KSAmJiBpc051bWVyaWMob2JqLngpICYmIGlzTnVtZXJpYyhvYmoueSk7XG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgaXNOdW1lcmljID0gKG4pID0+ICFpc05hTihuKSAmJiBpc0Zpbml0ZShuKTtcbmNvbnN0IGludGVybmFsc1N5bWJvbCA9IFN5bWJvbC5mb3IoJ2ludGVybmFscycpO1xuLy8gdXNlZCBmb3IgYTExeSBrZXkgYm9hcmQgY29udHJvbHMgZm9yIG5vZGVzIGFuZCBlZGdlc1xuY29uc3QgZWxlbWVudFNlbGVjdGlvbktleXMgPSBbJ0VudGVyJywgJyAnLCAnRXNjYXBlJ107XG5jb25zdCBkZXZXYXJuID0gKGlkLCBtZXNzYWdlKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1JlYWN0IEZsb3ddOiAke21lc3NhZ2V9IEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMke2lkfWApO1xuICAgIH1cbn07XG5jb25zdCBpc1JlYWN0S2V5Ym9hcmRFdmVudCA9IChldmVudCkgPT4gJ25hdGl2ZUV2ZW50JyBpbiBldmVudDtcbmZ1bmN0aW9uIGlzSW5wdXRET01Ob2RlKGV2ZW50KSB7XG4gICAgY29uc3Qga2JFdmVudCA9IGlzUmVhY3RLZXlib2FyZEV2ZW50KGV2ZW50KSA/IGV2ZW50Lm5hdGl2ZUV2ZW50IDogZXZlbnQ7XG4gICAgLy8gdXNpbmcgY29tcG9zZWQgcGF0aCBmb3IgaGFuZGxpbmcgc2hhZG93IGRvbVxuICAgIGNvbnN0IHRhcmdldCA9IChrYkV2ZW50LmNvbXBvc2VkUGF0aD8uKCk/LlswXSB8fCBldmVudC50YXJnZXQpO1xuICAgIGNvbnN0IGlzSW5wdXQgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddLmluY2x1ZGVzKHRhcmdldD8ubm9kZU5hbWUpIHx8IHRhcmdldD8uaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAvLyB3aGVuIGFuIGlucHV0IGZpZWxkIGlzIGZvY3VzZWQgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGRlbGV0aW9uIG9yIG1vdmVtZW50IG9mIG5vZGVzXG4gICAgcmV0dXJuIGlzSW5wdXQgfHwgISF0YXJnZXQ/LmNsb3Nlc3QoJy5ub2tleScpO1xufVxuY29uc3QgaXNNb3VzZUV2ZW50ID0gKGV2ZW50KSA9PiAnY2xpZW50WCcgaW4gZXZlbnQ7XG5jb25zdCBnZXRFdmVudFBvc2l0aW9uID0gKGV2ZW50LCBib3VuZHMpID0+IHtcbiAgICBjb25zdCBpc01vdXNlVHJpZ2dlcmVkID0gaXNNb3VzZUV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCBldnRYID0gaXNNb3VzZVRyaWdnZXJlZCA/IGV2ZW50LmNsaWVudFggOiBldmVudC50b3VjaGVzPy5bMF0uY2xpZW50WDtcbiAgICBjb25zdCBldnRZID0gaXNNb3VzZVRyaWdnZXJlZCA/IGV2ZW50LmNsaWVudFkgOiBldmVudC50b3VjaGVzPy5bMF0uY2xpZW50WTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldnRYIC0gKGJvdW5kcz8ubGVmdCA/PyAwKSxcbiAgICAgICAgeTogZXZ0WSAtIChib3VuZHM/LnRvcCA/PyAwKSxcbiAgICB9O1xufTtcbmNvbnN0IGlzTWFjT3MgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5kZXhPZignTWFjJykgPj0gMDtcblxuY29uc3QgQmFzZUVkZ2UgPSAoeyBpZCwgcGF0aCwgbGFiZWxYLCBsYWJlbFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGggPSAyMCwgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBpZDogaWQsIHN0eWxlOiBzdHlsZSwgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXBhdGhcIiwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCB9KSxcbiAgICAgICAgaW50ZXJhY3Rpb25XaWR0aCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlT3BhY2l0eTogMCwgc3Ryb2tlV2lkdGg6IGludGVyYWN0aW9uV2lkdGgsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLWludGVyYWN0aW9uXCIgfSkpLFxuICAgICAgICBsYWJlbCAmJiBpc051bWVyaWMobGFiZWxYKSAmJiBpc051bWVyaWMobGFiZWxZKSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KEVkZ2VUZXh0JDEsIHsgeDogbGFiZWxYLCB5OiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzIH0pKSA6IG51bGwpKTtcbn07XG5CYXNlRWRnZS5kaXNwbGF5TmFtZSA9ICdCYXNlRWRnZSc7XG5cbmNvbnN0IGdldE1hcmtlckVuZCA9IChtYXJrZXJUeXBlLCBtYXJrZXJFbmRJZCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbWFya2VyRW5kSWQgIT09ICd1bmRlZmluZWQnICYmIG1hcmtlckVuZElkKSB7XG4gICAgICAgIHJldHVybiBgdXJsKCMke21hcmtlckVuZElkfSlgO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIG1hcmtlclR5cGUgIT09ICd1bmRlZmluZWQnID8gYHVybCgjcmVhY3QtZmxvd19fJHttYXJrZXJUeXBlfSlgIDogJ25vbmUnO1xufTtcbmZ1bmN0aW9uIGdldE1vdXNlSGFuZGxlciQxKGlkLCBnZXRTdGF0ZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVyID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBoYW5kbGVyXG4gICAgICAgIDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlZGdlID0gZ2V0U3RhdGUoKS5lZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBpZCk7XG4gICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbn1cbi8vIHRoaXMgaXMgdXNlZCBmb3Igc3RyYWlnaHQgZWRnZXMgYW5kIHNpbXBsZSBzbW9vdGhzdGVwIGVkZ2VzIChMVFIsIFJUTCwgQlRULCBUVEIpXG5mdW5jdGlvbiBnZXRFZGdlQ2VudGVyKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgfSkge1xuICAgIGNvbnN0IHhPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRYIC0gc291cmNlWCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclggPSB0YXJnZXRYIDwgc291cmNlWCA/IHRhcmdldFggKyB4T2Zmc2V0IDogdGFyZ2V0WCAtIHhPZmZzZXQ7XG4gICAgY29uc3QgeU9mZnNldCA9IE1hdGguYWJzKHRhcmdldFkgLSBzb3VyY2VZKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IHRhcmdldFkgPCBzb3VyY2VZID8gdGFyZ2V0WSArIHlPZmZzZXQgOiB0YXJnZXRZIC0geU9mZnNldDtcbiAgICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclksIHhPZmZzZXQsIHlPZmZzZXRdO1xufVxuZnVuY3Rpb24gZ2V0QmV6aWVyRWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWSwgdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZLCB9KSB7XG4gICAgLy8gY3ViaWMgYmV6aWVyIHQ9MC41IG1pZCBwb2ludCwgbm90IHRoZSBhY3R1YWwgbWlkIHBvaW50LCBidXQgZWFzeSB0byBjYWxjdWxhdGVcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzUxNjEwMS9ob3ctdG8tZmluZC1kaXN0YW5jZS1taWQtcG9pbnQtb2YtYmV6aWVyLWN1cnZlXG4gICAgY29uc3QgY2VudGVyWCA9IHNvdXJjZVggKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0WCAqIDAuMTI1O1xuICAgIGNvbnN0IGNlbnRlclkgPSBzb3VyY2VZICogMC4xMjUgKyBzb3VyY2VDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFkgKiAwLjM3NSArIHRhcmdldFkgKiAwLjEyNTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5hYnMoY2VudGVyWCAtIHNvdXJjZVgpO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmFicyhjZW50ZXJZIC0gc291cmNlWSk7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxudmFyIENvbm5lY3Rpb25Nb2RlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTW9kZSkge1xuICAgIENvbm5lY3Rpb25Nb2RlW1wiU3RyaWN0XCJdID0gXCJzdHJpY3RcIjtcbiAgICBDb25uZWN0aW9uTW9kZVtcIkxvb3NlXCJdID0gXCJsb29zZVwiO1xufSkoQ29ubmVjdGlvbk1vZGUgfHwgKENvbm5lY3Rpb25Nb2RlID0ge30pKTtcbnZhciBQYW5PblNjcm9sbE1vZGU7XG4oZnVuY3Rpb24gKFBhbk9uU2Nyb2xsTW9kZSkge1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIkZyZWVcIl0gPSBcImZyZWVcIjtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJWZXJ0aWNhbFwiXSA9IFwidmVydGljYWxcIjtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJIb3Jpem9udGFsXCJdID0gXCJob3Jpem9udGFsXCI7XG59KShQYW5PblNjcm9sbE1vZGUgfHwgKFBhbk9uU2Nyb2xsTW9kZSA9IHt9KSk7XG52YXIgU2VsZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uTW9kZSkge1xuICAgIFNlbGVjdGlvbk1vZGVbXCJQYXJ0aWFsXCJdID0gXCJwYXJ0aWFsXCI7XG4gICAgU2VsZWN0aW9uTW9kZVtcIkZ1bGxcIl0gPSBcImZ1bGxcIjtcbn0pKFNlbGVjdGlvbk1vZGUgfHwgKFNlbGVjdGlvbk1vZGUgPSB7fSkpO1xuXG52YXIgQ29ubmVjdGlvbkxpbmVUeXBlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTGluZVR5cGUpIHtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJCZXppZXJcIl0gPSBcImRlZmF1bHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdHJhaWdodFwiXSA9IFwic3RyYWlnaHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdGVwXCJdID0gXCJzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU21vb3RoU3RlcFwiXSA9IFwic21vb3Roc3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNpbXBsZUJlemllclwiXSA9IFwic2ltcGxlYmV6aWVyXCI7XG59KShDb25uZWN0aW9uTGluZVR5cGUgfHwgKENvbm5lY3Rpb25MaW5lVHlwZSA9IHt9KSk7XG52YXIgTWFya2VyVHlwZTtcbihmdW5jdGlvbiAoTWFya2VyVHlwZSkge1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd1wiXSA9IFwiYXJyb3dcIjtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dDbG9zZWRcIl0gPSBcImFycm93Y2xvc2VkXCI7XG59KShNYXJrZXJUeXBlIHx8IChNYXJrZXJUeXBlID0ge30pKTtcblxudmFyIFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChQb3NpdGlvbikge1xuICAgIFBvc2l0aW9uW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIFBvc2l0aW9uW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgICBQb3NpdGlvbltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIFBvc2l0aW9uW1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG5cbmZ1bmN0aW9uIGdldENvbnRyb2woeyBwb3MsIHgxLCB5MSwgeDIsIHkyIH0pIHtcbiAgICBpZiAocG9zID09PSBQb3NpdGlvbi5MZWZ0IHx8IHBvcyA9PT0gUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFswLjUgKiAoeDEgKyB4MiksIHkxXTtcbiAgICB9XG4gICAgcmV0dXJuIFt4MSwgMC41ICogKHkxICsgeTIpXTtcbn1cbmZ1bmN0aW9uIGdldFNpbXBsZUJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2woe1xuICAgICAgICBwb3M6IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB4MTogc291cmNlWCxcbiAgICAgICAgeTE6IHNvdXJjZVksXG4gICAgICAgIHgyOiB0YXJnZXRYLFxuICAgICAgICB5MjogdGFyZ2V0WSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2woe1xuICAgICAgICBwb3M6IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB4MTogdGFyZ2V0WCxcbiAgICAgICAgeTE6IHRhcmdldFksXG4gICAgICAgIHgyOiBzb3VyY2VYLFxuICAgICAgICB5Mjogc291cmNlWSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuY29uc3QgU2ltcGxlQmV6aWVyRWRnZSA9IG1lbW8oKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNpbXBsZUJlemllclBhdGgoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VFZGdlLCB7IHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG59KTtcblNpbXBsZUJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnU2ltcGxlQmV6aWVyRWRnZSc7XG5cbmNvbnN0IGhhbmRsZURpcmVjdGlvbnMgPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiB7IHg6IC0xLCB5OiAwIH0sXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogeyB4OiAxLCB5OiAwIH0sXG4gICAgW1Bvc2l0aW9uLlRvcF06IHsgeDogMCwgeTogLTEgfSxcbiAgICBbUG9zaXRpb24uQm90dG9tXTogeyB4OiAwLCB5OiAxIH0sXG59O1xuY29uc3QgZ2V0RGlyZWN0aW9uID0gKHsgc291cmNlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0LCB9KSA9PiB7XG4gICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSBQb3NpdGlvbi5MZWZ0IHx8IHNvdXJjZVBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodCkge1xuICAgICAgICByZXR1cm4gc291cmNlLnggPCB0YXJnZXQueCA/IHsgeDogMSwgeTogMCB9IDogeyB4OiAtMSwgeTogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlLnkgPCB0YXJnZXQueSA/IHsgeDogMCwgeTogMSB9IDogeyB4OiAwLCB5OiAtMSB9O1xufTtcbmNvbnN0IGRpc3RhbmNlID0gKGEsIGIpID0+IE1hdGguc3FydChNYXRoLnBvdyhiLnggLSBhLngsIDIpICsgTWF0aC5wb3coYi55IC0gYS55LCAyKSk7XG4vLyBpdGggdGhpcyBmdW5jdGlvbiB3ZSB0cnkgdG8gbWltaWMgYSBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZyBiZWhhdmlvdXJcbi8vIEl0J3Mgbm90IGFzIGdvb2QgYXMgYSByZWFsIG9ydGhvZ29uYWwgZWRnZSByb3V0aW5nIGJ1dCBpdCdzIGZhc3RlciBhbmQgZ29vZCBlbm91Z2ggYXMgYSBkZWZhdWx0IGZvciBzdGVwIGFuZCBzbW9vdGggc3RlcCBlZGdlc1xuZnVuY3Rpb24gZ2V0UG9pbnRzKHsgc291cmNlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0LCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgY2VudGVyLCBvZmZzZXQsIH0pIHtcbiAgICBjb25zdCBzb3VyY2VEaXIgPSBoYW5kbGVEaXJlY3Rpb25zW3NvdXJjZVBvc2l0aW9uXTtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBoYW5kbGVEaXJlY3Rpb25zW3RhcmdldFBvc2l0aW9uXTtcbiAgICBjb25zdCBzb3VyY2VHYXBwZWQgPSB7IHg6IHNvdXJjZS54ICsgc291cmNlRGlyLnggKiBvZmZzZXQsIHk6IHNvdXJjZS55ICsgc291cmNlRGlyLnkgKiBvZmZzZXQgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBwZWQgPSB7IHg6IHRhcmdldC54ICsgdGFyZ2V0RGlyLnggKiBvZmZzZXQsIHk6IHRhcmdldC55ICsgdGFyZ2V0RGlyLnkgKiBvZmZzZXQgfTtcbiAgICBjb25zdCBkaXIgPSBnZXREaXJlY3Rpb24oe1xuICAgICAgICBzb3VyY2U6IHNvdXJjZUdhcHBlZCxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldDogdGFyZ2V0R2FwcGVkLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpckFjY2Vzc29yID0gZGlyLnggIT09IDAgPyAneCcgOiAneSc7XG4gICAgY29uc3QgY3VyckRpciA9IGRpcltkaXJBY2Nlc3Nvcl07XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGxldCBjZW50ZXJYLCBjZW50ZXJZO1xuICAgIGNvbnN0IHNvdXJjZUdhcE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IHRhcmdldEdhcE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IFtkZWZhdWx0Q2VudGVyWCwgZGVmYXVsdENlbnRlclksIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgfSk7XG4gICAgLy8gb3Bwb3NpdGUgaGFuZGxlIHBvc2l0aW9ucywgZGVmYXVsdCBjYXNlXG4gICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gKiB0YXJnZXREaXJbZGlyQWNjZXNzb3JdID09PSAtMSkge1xuICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggfHwgZGVmYXVsdENlbnRlclg7XG4gICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSB8fCBkZWZhdWx0Q2VudGVyWTtcbiAgICAgICAgLy8gICAgLS0tPlxuICAgICAgICAvLyAgICB8XG4gICAgICAgIC8vID4tLS1cbiAgICAgICAgY29uc3QgdmVydGljYWxTcGxpdCA9IFtcbiAgICAgICAgICAgIHsgeDogY2VudGVyWCwgeTogc291cmNlR2FwcGVkLnkgfSxcbiAgICAgICAgICAgIHsgeDogY2VudGVyWCwgeTogdGFyZ2V0R2FwcGVkLnkgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gICAgfFxuICAgICAgICAvLyAgLS0tXG4gICAgICAgIC8vICB8XG4gICAgICAgIGNvbnN0IGhvcml6b250YWxTcGxpdCA9IFtcbiAgICAgICAgICAgIHsgeDogc291cmNlR2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyB2ZXJ0aWNhbFNwbGl0IDogaG9yaXpvbnRhbFNwbGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IGhvcml6b250YWxTcGxpdCA6IHZlcnRpY2FsU3BsaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNvdXJjZVRhcmdldCBtZWFucyB3ZSB0YWtlIHggZnJvbSBzb3VyY2UgYW5kIHkgZnJvbSB0YXJnZXQsIHRhcmdldFNvdXJjZSBpcyB0aGUgb3Bwb3NpdGVcbiAgICAgICAgY29uc3Qgc291cmNlVGFyZ2V0ID0gW3sgeDogc291cmNlR2FwcGVkLngsIHk6IHRhcmdldEdhcHBlZC55IH1dO1xuICAgICAgICBjb25zdCB0YXJnZXRTb3VyY2UgPSBbeyB4OiB0YXJnZXRHYXBwZWQueCwgeTogc291cmNlR2FwcGVkLnkgfV07XG4gICAgICAgIC8vIHRoaXMgaGFuZGxlcyBlZGdlcyB3aXRoIHNhbWUgaGFuZGxlIHBvc2l0aW9uc1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnggPT09IGN1cnJEaXIgPyB0YXJnZXRTb3VyY2UgOiBzb3VyY2VUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMgPSBzb3VyY2VEaXIueSA9PT0gY3VyckRpciA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMoc291cmNlW2RpckFjY2Vzc29yXSAtIHRhcmdldFtkaXJBY2Nlc3Nvcl0pO1xuICAgICAgICAgICAgLy8gaWYgYW4gZWRnZSBnb2VzIGZyb20gcmlnaHQgdG8gcmlnaHQgZm9yIGV4YW1wbGUgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikgYW5kIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZS54IGFuZCB0YXJnZXQueCBpcyBsZXNzIHRoYW4gdGhlIG9mZnNldCwgdGhlIGFkZGVkIHBvaW50IGFuZCB0aGUgZ2FwcGVkIHNvdXJjZS90YXJnZXQgd2lsbCBvdmVybGFwLiBUaGlzIGxlYWRzIHRvIGEgd2VpcmQgZWRnZSBwYXRoLiBUbyBhdm9pZCB0aGlzIHdlIGFkZCBhIGdhcE9mZnNldCB0byB0aGUgc291cmNlL3RhcmdldFxuICAgICAgICAgICAgaWYgKGRpZmYgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwT2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0IC0gMSwgb2Zmc2V0IC0gZGlmZik7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlR2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9IChzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JdID4gc291cmNlW2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRHYXBPZmZzZXRbZGlyQWNjZXNzb3JdID0gKHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvcl0gPiB0YXJnZXRbZGlyQWNjZXNzb3JdID8gLTEgOiAxKSAqIGdhcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2UgYXJlIGNvbmRpdGlvbnMgZm9yIGhhbmRsaW5nIG1peGVkIGhhbmRsZSBwb3NpdGlvbnMgbGlrZSBSaWdodCAtPiBCb3R0b20gZm9yIGV4YW1wbGVcbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uICE9PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlyQWNjZXNzb3JPcHBvc2l0ZSA9IGRpckFjY2Vzc29yID09PSAneCcgPyAneScgOiAneCc7XG4gICAgICAgICAgICBjb25zdCBpc1NhbWVEaXIgPSBzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSB0YXJnZXREaXJbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VHdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPiB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPCB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBmbGlwU291cmNlVGFyZ2V0ID0gKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VMdFRhcmdldE9wcG8pKSkgfHxcbiAgICAgICAgICAgICAgICAoc291cmNlRGlyW2RpckFjY2Vzc29yXSAhPT0gMSAmJiAoKCFpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSB8fCAoaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykpKTtcbiAgICAgICAgICAgIGlmIChmbGlwU291cmNlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VHYXBQb2ludCA9IHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCB0YXJnZXRHYXBQb2ludCA9IHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCBtYXhYRGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLmFicyhzb3VyY2VHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpLCBNYXRoLmFicyh0YXJnZXRHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpKTtcbiAgICAgICAgY29uc3QgbWF4WURpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueSAtIHBvaW50c1swXS55KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueSAtIHBvaW50c1swXS55KSk7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gcGxhY2UgdGhlIGxhYmVsIG9uIHRoZSBsb25nZXN0IHNlZ21lbnQgb2YgdGhlIGVkZ2VcbiAgICAgICAgaWYgKG1heFhEaXN0YW5jZSA+PSBtYXhZRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNlbnRlclggPSAoc291cmNlR2FwUG9pbnQueCArIHRhcmdldEdhcFBvaW50LngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBwb2ludHNbMF0ueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNlbnRlclggPSBwb2ludHNbMF0ueDtcbiAgICAgICAgICAgIGNlbnRlclkgPSAoc291cmNlR2FwUG9pbnQueSArIHRhcmdldEdhcFBvaW50LnkpIC8gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXRoUG9pbnRzID0gW1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9LFxuICAgICAgICAuLi5wb2ludHMsXG4gICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9LFxuICAgICAgICB0YXJnZXQsXG4gICAgXTtcbiAgICByZXR1cm4gW3BhdGhQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV07XG59XG5mdW5jdGlvbiBnZXRCZW5kKGEsIGIsIGMsIHNpemUpIHtcbiAgICBjb25zdCBiZW5kU2l6ZSA9IE1hdGgubWluKGRpc3RhbmNlKGEsIGIpIC8gMiwgZGlzdGFuY2UoYiwgYykgLyAyLCBzaXplKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGI7XG4gICAgLy8gbm8gYmVuZFxuICAgIGlmICgoYS54ID09PSB4ICYmIHggPT09IGMueCkgfHwgKGEueSA9PT0geSAmJiB5ID09PSBjLnkpKSB7XG4gICAgICAgIHJldHVybiBgTCR7eH0gJHt5fWA7XG4gICAgfVxuICAgIC8vIGZpcnN0IHNlZ21lbnQgaXMgaG9yaXpvbnRhbFxuICAgIGlmIChhLnkgPT09IHkpIHtcbiAgICAgICAgY29uc3QgeERpciA9IGEueCA8IGMueCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIGBMICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fVEgJHt4fSwke3l9ICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfWA7XG4gICAgfVxuICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAxIDogLTE7XG4gICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IC0xIDogMTtcbiAgICByZXR1cm4gYEwgJHt4fSwke3kgKyBiZW5kU2l6ZSAqIHlEaXJ9USAke3h9LCR7eX0gJHt4ICsgYmVuZFNpemUgKiB4RGlyfSwke3l9YDtcbn1cbmZ1bmN0aW9uIGdldFNtb290aFN0ZXBQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBib3JkZXJSYWRpdXMgPSA1LCBjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXQgPSAyMCwgfSkge1xuICAgIGNvbnN0IFtwb2ludHMsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFBvaW50cyh7XG4gICAgICAgIHNvdXJjZTogeyB4OiBzb3VyY2VYLCB5OiBzb3VyY2VZIH0sXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHsgeDogdGFyZ2V0WCwgeTogdGFyZ2V0WSB9LFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgY2VudGVyOiB7IHg6IGNlbnRlclgsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgb2Zmc2V0LFxuICAgIH0pO1xuICAgIGNvbnN0IHBhdGggPSBwb2ludHMucmVkdWNlKChyZXMsIHAsIGkpID0+IHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IGdldEJlbmQocG9pbnRzW2kgLSAxXSwgcCwgcG9pbnRzW2kgKyAxXSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBgJHtpID09PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBzZWdtZW50O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cbmNvbnN0IFNtb290aFN0ZXBFZGdlID0gbWVtbygoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIHBhdGhPcHRpb25zLCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICBib3JkZXJSYWRpdXM6IHBhdGhPcHRpb25zPy5ib3JkZXJSYWRpdXMsXG4gICAgICAgIG9mZnNldDogcGF0aE9wdGlvbnM/Lm9mZnNldCxcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZUVkZ2UsIHsgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbn0pO1xuU21vb3RoU3RlcEVkZ2UuZGlzcGxheU5hbWUgPSAnU21vb3RoU3RlcEVkZ2UnO1xuXG5jb25zdCBTdGVwRWRnZSA9IG1lbW8oKHByb3BzKSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChTbW9vdGhTdGVwRWRnZSwgeyAuLi5wcm9wcywgcGF0aE9wdGlvbnM6IHVzZU1lbW8oKCkgPT4gKHsgYm9yZGVyUmFkaXVzOiAwLCBvZmZzZXQ6IHByb3BzLnBhdGhPcHRpb25zPy5vZmZzZXQgfSksIFtwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0XSkgfSkpKTtcblN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlJztcblxuZnVuY3Rpb24gZ2V0U3RyYWlnaHRQYXRoKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgfSkge1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICB9KTtcbiAgICByZXR1cm4gW2BNICR7c291cmNlWH0sJHtzb3VyY2VZfUwgJHt0YXJnZXRYfSwke3RhcmdldFl9YCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldO1xufVxuY29uc3QgU3RyYWlnaHRFZGdlID0gbWVtbygoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VFZGdlLCB7IHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG59KTtcblN0cmFpZ2h0RWRnZS5kaXNwbGF5TmFtZSA9ICdTdHJhaWdodEVkZ2UnO1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KGRpc3RhbmNlLCBjdXJ2YXR1cmUpIHtcbiAgICBpZiAoZGlzdGFuY2UgPj0gMCkge1xuICAgICAgICByZXR1cm4gMC41ICogZGlzdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2YXR1cmUgKiAyNSAqIE1hdGguc3FydCgtZGlzdGFuY2UpO1xufVxuZnVuY3Rpb24gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoeyBwb3MsIHgxLCB5MSwgeDIsIHkyLCBjIH0pIHtcbiAgICBzd2l0Y2ggKHBvcykge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4gW3gxIC0gY2FsY3VsYXRlQ29udHJvbE9mZnNldCh4MSAtIHgyLCBjKSwgeTFdO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcmV0dXJuIFt4MSArIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeDIgLSB4MSwgYyksIHkxXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4gW3gxLCB5MSAtIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeTEgLSB5MiwgYyldO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHkxICsgY2FsY3VsYXRlQ29udHJvbE9mZnNldCh5MiAtIHkxLCBjKV07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QmV6aWVyUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgY3VydmF0dXJlID0gMC4yNSwgfSkge1xuICAgIGNvbnN0IFtzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFldID0gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoe1xuICAgICAgICBwb3M6IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB4MTogc291cmNlWCxcbiAgICAgICAgeTE6IHNvdXJjZVksXG4gICAgICAgIHgyOiB0YXJnZXRYLFxuICAgICAgICB5MjogdGFyZ2V0WSxcbiAgICAgICAgYzogY3VydmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IFt0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFldID0gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoe1xuICAgICAgICBwb3M6IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB4MTogdGFyZ2V0WCxcbiAgICAgICAgeTE6IHRhcmdldFksXG4gICAgICAgIHgyOiBzb3VyY2VYLFxuICAgICAgICB5Mjogc291cmNlWSxcbiAgICAgICAgYzogY3VydmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgc291cmNlQ29udHJvbFgsXG4gICAgICAgIHNvdXJjZUNvbnRyb2xZLFxuICAgICAgICB0YXJnZXRDb250cm9sWCxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYE0ke3NvdXJjZVh9LCR7c291cmNlWX0gQyR7c291cmNlQ29udHJvbFh9LCR7c291cmNlQ29udHJvbFl9ICR7dGFyZ2V0Q29udHJvbFh9LCR7dGFyZ2V0Q29udHJvbFl9ICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsXG4gICAgICAgIGxhYmVsWCxcbiAgICAgICAgbGFiZWxZLFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgIF07XG59XG5jb25zdCBCZXppZXJFZGdlID0gbWVtbygoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIHBhdGhPcHRpb25zLCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIGN1cnZhdHVyZTogcGF0aE9wdGlvbnM/LmN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZUVkZ2UsIHsgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbn0pO1xuQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlJztcblxuY29uc3QgTm9kZUlkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciA9IE5vZGVJZENvbnRleHQuUHJvdmlkZXI7XG5Ob2RlSWRDb250ZXh0LkNvbnN1bWVyO1xuY29uc3QgdXNlTm9kZUlkID0gKCkgPT4ge1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZUNvbnRleHQoTm9kZUlkQ29udGV4dCk7XG4gICAgcmV0dXJuIG5vZGVJZDtcbn07XG5cbmNvbnN0IGlzRWRnZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3NvdXJjZScgaW4gZWxlbWVudCAmJiAndGFyZ2V0JyBpbiBlbGVtZW50O1xuY29uc3QgaXNOb2RlID0gKGVsZW1lbnQpID0+ICdpZCcgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG5jb25zdCBnZXRPdXRnb2VycyA9IChub2RlLCBub2RlcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIWlzTm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG91dGdvZXJJZHMgPSBlZGdlcy5maWx0ZXIoKGUpID0+IGUuc291cmNlID09PSBub2RlLmlkKS5tYXAoKGUpID0+IGUudGFyZ2V0KTtcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKChuKSA9PiBvdXRnb2VySWRzLmluY2x1ZGVzKG4uaWQpKTtcbn07XG5jb25zdCBnZXRJbmNvbWVycyA9IChub2RlLCBub2RlcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIWlzTm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluY29tZXJzSWRzID0gZWRnZXMuZmlsdGVyKChlKSA9PiBlLnRhcmdldCA9PT0gbm9kZS5pZCkubWFwKChlKSA9PiBlLnNvdXJjZSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gaW5jb21lcnNJZHMuaW5jbHVkZXMobi5pZCkpO1xufTtcbmNvbnN0IGdldEVkZ2VJZCA9ICh7IHNvdXJjZSwgc291cmNlSGFuZGxlLCB0YXJnZXQsIHRhcmdldEhhbmRsZSB9KSA9PiBgcmVhY3RmbG93X19lZGdlLSR7c291cmNlfSR7c291cmNlSGFuZGxlIHx8ICcnfS0ke3RhcmdldH0ke3RhcmdldEhhbmRsZSB8fCAnJ31gO1xuY29uc3QgZ2V0TWFya2VySWQgPSAobWFya2VyLCByZklkKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIGNvbnN0IGlkUHJlZml4ID0gcmZJZCA/IGAke3JmSWR9X19gIDogJyc7XG4gICAgcmV0dXJuIGAke2lkUHJlZml4fSR7T2JqZWN0LmtleXMobWFya2VyKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gYCR7a2V5fT0ke21hcmtlcltrZXldfWApXG4gICAgICAgIC5qb2luKCcmJyl9YDtcbn07XG5jb25zdCBjb25uZWN0aW9uRXhpc3RzID0gKGVkZ2UsIGVkZ2VzKSA9PiB7XG4gICAgcmV0dXJuIGVkZ2VzLnNvbWUoKGVsKSA9PiBlbC5zb3VyY2UgPT09IGVkZ2Uuc291cmNlICYmXG4gICAgICAgIGVsLnRhcmdldCA9PT0gZWRnZS50YXJnZXQgJiZcbiAgICAgICAgKGVsLnNvdXJjZUhhbmRsZSA9PT0gZWRnZS5zb3VyY2VIYW5kbGUgfHwgKCFlbC5zb3VyY2VIYW5kbGUgJiYgIWVkZ2Uuc291cmNlSGFuZGxlKSkgJiZcbiAgICAgICAgKGVsLnRhcmdldEhhbmRsZSA9PT0gZWRnZS50YXJnZXRIYW5kbGUgfHwgKCFlbC50YXJnZXRIYW5kbGUgJiYgIWVkZ2UudGFyZ2V0SGFuZGxlKSkpO1xufTtcbmNvbnN0IGFkZEVkZ2UgPSAoZWRnZVBhcmFtcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIWVkZ2VQYXJhbXMuc291cmNlIHx8ICFlZGdlUGFyYW1zLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGxldCBlZGdlO1xuICAgIGlmIChpc0VkZ2UoZWRnZVBhcmFtcykpIHtcbiAgICAgICAgZWRnZSA9IHsgLi4uZWRnZVBhcmFtcyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWRnZSA9IHtcbiAgICAgICAgICAgIC4uLmVkZ2VQYXJhbXMsXG4gICAgICAgICAgICBpZDogZ2V0RWRnZUlkKGVkZ2VQYXJhbXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbkV4aXN0cyhlZGdlLCBlZGdlcykpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXMuY29uY2F0KGVkZ2UpO1xufTtcbmNvbnN0IHVwZGF0ZUVkZ2UgPSAob2xkRWRnZSwgbmV3Q29ubmVjdGlvbiwgZWRnZXMsIG9wdGlvbnMgPSB7IHNob3VsZFJlcGxhY2VJZDogdHJ1ZSB9KSA9PiB7XG4gICAgY29uc3QgeyBpZDogb2xkRWRnZUlkLCAuLi5yZXN0IH0gPSBvbGRFZGdlO1xuICAgIGlmICghbmV3Q29ubmVjdGlvbi5zb3VyY2UgfHwgIW5ld0Nvbm5lY3Rpb24udGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZm91bmRFZGdlID0gZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gb2xkRWRnZUlkKTtcbiAgICBpZiAoIWZvdW5kRWRnZSkge1xuICAgICAgICBkZXZXYXJuKCcwMDcnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNyddKG9sZEVkZ2VJZCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBvbGQgZWRnZSBhbmQgY3JlYXRlIHRoZSBuZXcgZWRnZSB3aXRoIHBhcmFtZXRlcnMgb2Ygb2xkIGVkZ2UuXG4gICAgY29uc3QgZWRnZSA9IHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgaWQ6IG9wdGlvbnMuc2hvdWxkUmVwbGFjZUlkID8gZ2V0RWRnZUlkKG5ld0Nvbm5lY3Rpb24pIDogb2xkRWRnZUlkLFxuICAgICAgICBzb3VyY2U6IG5ld0Nvbm5lY3Rpb24uc291cmNlLFxuICAgICAgICB0YXJnZXQ6IG5ld0Nvbm5lY3Rpb24udGFyZ2V0LFxuICAgICAgICBzb3VyY2VIYW5kbGU6IG5ld0Nvbm5lY3Rpb24uc291cmNlSGFuZGxlLFxuICAgICAgICB0YXJnZXRIYW5kbGU6IG5ld0Nvbm5lY3Rpb24udGFyZ2V0SGFuZGxlLFxuICAgIH07XG4gICAgcmV0dXJuIGVkZ2VzLmZpbHRlcigoZSkgPT4gZS5pZCAhPT0gb2xkRWRnZUlkKS5jb25jYXQoZWRnZSk7XG59O1xuY29uc3QgcG9pbnRUb1JlbmRlcmVyUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0sIHNuYXBUb0dyaWQsIFtzbmFwWCwgc25hcFldKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6ICh4IC0gdHgpIC8gdFNjYWxlLFxuICAgICAgICB5OiAoeSAtIHR5KSAvIHRTY2FsZSxcbiAgICB9O1xuICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBzbmFwWCAqIE1hdGgucm91bmQocG9zaXRpb24ueCAvIHNuYXBYKSxcbiAgICAgICAgICAgIHk6IHNuYXBZICogTWF0aC5yb3VuZChwb3NpdGlvbi55IC8gc25hcFkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb247XG59O1xuY29uc3QgcmVuZGVyZXJQb2ludFRvUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICogdFNjYWxlICsgdHgsXG4gICAgICAgIHk6IHkgKiB0U2NhbGUgKyB0eSxcbiAgICB9O1xufTtcbmNvbnN0IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4gPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0WCA9IChub2RlLndpZHRoID8/IDApICogbm9kZU9yaWdpblswXTtcbiAgICBjb25zdCBvZmZzZXRZID0gKG5vZGUuaGVpZ2h0ID8/IDApICogbm9kZU9yaWdpblsxXTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54IC0gb2Zmc2V0WCxcbiAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55IC0gb2Zmc2V0WSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnBvc2l0aW9uLFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBub2RlLnBvc2l0aW9uQWJzb2x1dGVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHg6IG5vZGUucG9zaXRpb25BYnNvbHV0ZS54IC0gb2Zmc2V0WCxcbiAgICAgICAgICAgICAgICB5OiBub2RlLnBvc2l0aW9uQWJzb2x1dGUueSAtIG9mZnNldFksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHBvc2l0aW9uLFxuICAgIH07XG59O1xuY29uc3QgZ2V0UmVjdE9mTm9kZXMgPSAobm9kZXMsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgYm94ID0gbm9kZXMucmVkdWNlKChjdXJyQm94LCBub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKS5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzT2ZCb3hlcyhjdXJyQm94LCByZWN0VG9Cb3goe1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aDogbm9kZS53aWR0aCB8fCAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCB8fCAwLFxuICAgICAgICB9KSk7XG4gICAgfSwgeyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfSk7XG4gICAgcmV0dXJuIGJveFRvUmVjdChib3gpO1xufTtcbmNvbnN0IGdldE5vZGVzSW5zaWRlID0gKG5vZGVJbnRlcm5hbHMsIHJlY3QsIFt0eCwgdHksIHRTY2FsZV0gPSBbMCwgMCwgMV0sIHBhcnRpYWxseSA9IGZhbHNlLCBcbi8vIHNldCBleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzIGlmIHlvdSB3YW50IHRvIHBheSBhdHRlbnRpb24gdG8gdGhlIG5vZGVzIFwic2VsZWN0YWJsZVwiIGF0dHJpYnV0ZVxuZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyA9IGZhbHNlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgcGFuZVJlY3QgPSB7XG4gICAgICAgIHg6IChyZWN0LnggLSB0eCkgLyB0U2NhbGUsXG4gICAgICAgIHk6IChyZWN0LnkgLSB0eSkgLyB0U2NhbGUsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC8gdFNjYWxlLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gdFNjYWxlLFxuICAgIH07XG4gICAgY29uc3QgdmlzaWJsZU5vZGVzID0gW107XG4gICAgbm9kZUludGVybmFscy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgc2VsZWN0YWJsZSA9IHRydWUsIGhpZGRlbiA9IGZhbHNlIH0gPSBub2RlO1xuICAgICAgICBpZiAoKGV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgJiYgIXNlbGVjdGFibGUpIHx8IGhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSB7XG4gICAgICAgICAgICB4OiBwb3NpdGlvbkFic29sdXRlLngsXG4gICAgICAgICAgICB5OiBwb3NpdGlvbkFic29sdXRlLnksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IHx8IDAsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShwYW5lUmVjdCwgbm9kZVJlY3QpO1xuICAgICAgICBjb25zdCBub3RJbml0aWFsaXplZCA9IHR5cGVvZiB3aWR0aCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGhlaWdodCA9PT0gJ3VuZGVmaW5lZCcgfHwgd2lkdGggPT09IG51bGwgfHwgaGVpZ2h0ID09PSBudWxsO1xuICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgIGNvbnN0IGFyZWEgPSAod2lkdGggfHwgMCkgKiAoaGVpZ2h0IHx8IDApO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBub3RJbml0aWFsaXplZCB8fCBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBhcmVhO1xuICAgICAgICBpZiAoaXNWaXNpYmxlIHx8IG5vZGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZpc2libGVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpc2libGVOb2Rlcztcbn07XG5jb25zdCBnZXRDb25uZWN0ZWRFZGdlcyA9IChub2RlcywgZWRnZXMpID0+IHtcbiAgICBjb25zdCBub2RlSWRzID0gbm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbiAgICByZXR1cm4gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBub2RlSWRzLmluY2x1ZGVzKGVkZ2Uuc291cmNlKSB8fCBub2RlSWRzLmluY2x1ZGVzKGVkZ2UudGFyZ2V0KSk7XG59O1xuY29uc3QgZ2V0VHJhbnNmb3JtRm9yQm91bmRzID0gKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFkZGluZyA9IDAuMSkgPT4ge1xuICAgIGNvbnN0IHhab29tID0gd2lkdGggLyAoYm91bmRzLndpZHRoICogKDEgKyBwYWRkaW5nKSk7XG4gICAgY29uc3QgeVpvb20gPSBoZWlnaHQgLyAoYm91bmRzLmhlaWdodCAqICgxICsgcGFkZGluZykpO1xuICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbih4Wm9vbSwgeVpvb20pO1xuICAgIGNvbnN0IGNsYW1wZWRab29tID0gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWCA9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMjtcbiAgICBjb25zdCBib3VuZHNDZW50ZXJZID0gYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCB4ID0gd2lkdGggLyAyIC0gYm91bmRzQ2VudGVyWCAqIGNsYW1wZWRab29tO1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLyAyIC0gYm91bmRzQ2VudGVyWSAqIGNsYW1wZWRab29tO1xuICAgIHJldHVybiBbeCwgeSwgY2xhbXBlZFpvb21dO1xufTtcbmNvbnN0IGdldEQzVHJhbnNpdGlvbiA9IChzZWxlY3Rpb24sIGR1cmF0aW9uID0gMCkgPT4ge1xuICAgIHJldHVybiBzZWxlY3Rpb24udHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcbn07XG5cbi8vIHRoaXMgZnVuY3Rpb25zIGNvbGxlY3RzIGFsbCBoYW5kbGVzIGFuZCBhZGRzIGFuIGFic29sdXRlIHBvc2l0aW9uXG4vLyBzbyB0aGF0IHdlIGNhbiBsYXRlciBmaW5kIHRoZSBjbG9zZXN0IGhhbmRsZSB0byB0aGUgbW91c2UgcG9zaXRpb25cbmZ1bmN0aW9uIGdldEhhbmRsZXMobm9kZSwgaGFuZGxlQm91bmRzLCB0eXBlLCBjdXJyZW50SGFuZGxlKSB7XG4gICAgcmV0dXJuIChoYW5kbGVCb3VuZHNbdHlwZV0gfHwgW10pLnJlZHVjZSgocmVzLCBoKSA9PiB7XG4gICAgICAgIGlmIChgJHtub2RlLmlkfS0ke2guaWR9LSR7dHlwZX1gICE9PSBjdXJyZW50SGFuZGxlKSB7XG4gICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGguaWQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICB4OiAobm9kZS5wb3NpdGlvbkFic29sdXRlPy54ID8/IDApICsgaC54ICsgaC53aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgeTogKG5vZGUucG9zaXRpb25BYnNvbHV0ZT8ueSA/PyAwKSArIGgueSArIGguaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShldmVudCwgZG9jLCBwb3MsIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZXMsIHZhbGlkYXRvcikge1xuICAgIC8vIHdlIGFsd2F5cyB3YW50IHRvIHByaW9yaXRpemUgdGhlIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIG92ZXIgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgaGFuZGxlLFxuICAgIC8vIGJlY2F1c2UgaXQgY291bGQgYmUgdGhhdCB0aGUgY2VudGVyIG9mIGFub3RoZXIgaGFuZGxlIGlzIGNsb3NlciB0byB0aGUgbW91c2UgcG9pbnRlciB0aGFuIHRoZSBoYW5kbGUgYmVsb3cgdGhlIGN1cnNvclxuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgZG9tTm9kZXMgPSBkb2MuZWxlbWVudHNGcm9tUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgaGFuZGxlQmVsb3cgPSBkb21Ob2Rlcy5maW5kKChlbCkgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdyZWFjdC1mbG93X19oYW5kbGUnKSk7XG4gICAgaWYgKGhhbmRsZUJlbG93KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZU5vZGVJZCA9IGhhbmRsZUJlbG93LmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKTtcbiAgICAgICAgaWYgKGhhbmRsZU5vZGVJZCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUodW5kZWZpbmVkLCBoYW5kbGVCZWxvdyk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZUJlbG93LmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRIYW5kbGVSZXN1bHQgPSB2YWxpZGF0b3IoeyBub2RlSWQ6IGhhbmRsZU5vZGVJZCwgaWQ6IGhhbmRsZUlkLCB0eXBlOiBoYW5kbGVUeXBlIH0pO1xuICAgICAgICAgICAgaWYgKHZhbGlkSGFuZGxlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBoYW5kbGVOb2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBvcy55LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2YWxpZEhhbmRsZVJlc3VsdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIGNvdWxkbid0IGZpbmQgYSBoYW5kbGUgYmVsb3cgdGhlIG1vdXNlIGN1cnNvciB3ZSBsb29rIGZvciB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiYXNlZCBvbiB0aGUgY29ubmVjdGlvblJhZGl1c1xuICAgIGxldCBjbG9zZXN0SGFuZGxlcyA9IFtdO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGhhbmRsZXMuZm9yRWFjaCgoaGFuZGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KChoYW5kbGUueCAtIHBvcy54KSAqKiAyICsgKGhhbmRsZS55IC0gcG9zLnkpICoqIDIpO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gY29ubmVjdGlvblJhZGl1cykge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRIYW5kbGVSZXN1bHQgPSB2YWxpZGF0b3IoaGFuZGxlKTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGVzID0gW3sgaGFuZGxlLCB2YWxpZEhhbmRsZVJlc3VsdCB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gbXVsdGlwbGUgaGFuZGxlcyBhcmUgb24gdGhlIHNhbWUgZGlzdGFuY2Ugd2UgY29sbGVjdCBhbGwgb2YgdGhlbVxuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkSGFuZGxlUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2xvc2VzdEhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGhhbmRsZTogbnVsbCwgdmFsaWRIYW5kbGVSZXN1bHQ6IGRlZmF1bHRSZXN1bHQoKSB9O1xuICAgIH1cbiAgICBpZiAoY2xvc2VzdEhhbmRsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SGFuZGxlc1swXTtcbiAgICB9XG4gICAgY29uc3QgaGFzVmFsaWRIYW5kbGUgPSBjbG9zZXN0SGFuZGxlcy5zb21lKCh7IHZhbGlkSGFuZGxlUmVzdWx0IH0pID0+IHZhbGlkSGFuZGxlUmVzdWx0LmlzVmFsaWQpO1xuICAgIGNvbnN0IGhhc1RhcmdldEhhbmRsZSA9IGNsb3Nlc3RIYW5kbGVzLnNvbWUoKHsgaGFuZGxlIH0pID0+IGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jyk7XG4gICAgLy8gaWYgbXVsdGlwbGUgaGFuZGxlcyBhcmUgbGF5b3V0ZWQgb24gdG9wIG9mIGVhY2ggb3RoZXIgd2UgcHJlZmVyIHRoZSBvbmUgd2l0aCB0eXBlID0gdGFyZ2V0IGFuZCB0aGUgb25lIHRoYXQgaXMgdmFsaWRcbiAgICByZXR1cm4gKGNsb3Nlc3RIYW5kbGVzLmZpbmQoKHsgaGFuZGxlLCB2YWxpZEhhbmRsZVJlc3VsdCB9KSA9PiBoYXNUYXJnZXRIYW5kbGUgPyBoYW5kbGUudHlwZSA9PT0gJ3RhcmdldCcgOiAoaGFzVmFsaWRIYW5kbGUgPyB2YWxpZEhhbmRsZVJlc3VsdC5pc1ZhbGlkIDogdHJ1ZSkpIHx8IGNsb3Nlc3RIYW5kbGVzWzBdKTtcbn1cbmNvbnN0IG51bGxDb25uZWN0aW9uID0geyBzb3VyY2U6IG51bGwsIHRhcmdldDogbnVsbCwgc291cmNlSGFuZGxlOiBudWxsLCB0YXJnZXRIYW5kbGU6IG51bGwgfTtcbmNvbnN0IGRlZmF1bHRSZXN1bHQgPSAoKSA9PiAoe1xuICAgIGhhbmRsZURvbU5vZGU6IG51bGwsXG4gICAgaXNWYWxpZDogZmFsc2UsXG4gICAgY29ubmVjdGlvbjogbnVsbENvbm5lY3Rpb24sXG4gICAgZW5kSGFuZGxlOiBudWxsLFxufSk7XG4vLyBjaGVja3MgaWYgIGFuZCByZXR1cm5zIGNvbm5lY3Rpb24gaW4gZm9tIG9mIGFuIG9iamVjdCB7IHNvdXJjZTogMTIzLCB0YXJnZXQ6IDMxMiB9XG5mdW5jdGlvbiBpc1ZhbGlkSGFuZGxlKGhhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGZyb21Ob2RlSWQsIGZyb21IYW5kbGVJZCwgZnJvbVR5cGUsIGlzVmFsaWRDb25uZWN0aW9uLCBkb2MpIHtcbiAgICBjb25zdCBpc1RhcmdldCA9IGZyb21UeXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBoYW5kbGVUb0NoZWNrID0gZG9jLnF1ZXJ5U2VsZWN0b3IoYC5yZWFjdC1mbG93X19oYW5kbGVbZGF0YS1pZD1cIiR7aGFuZGxlPy5ub2RlSWR9LSR7aGFuZGxlPy5pZH0tJHtoYW5kbGU/LnR5cGV9XCJdYCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAuLi5kZWZhdWx0UmVzdWx0KCksXG4gICAgICAgIGhhbmRsZURvbU5vZGU6IGhhbmRsZVRvQ2hlY2ssXG4gICAgfTtcbiAgICBpZiAoaGFuZGxlVG9DaGVjaykge1xuICAgICAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZSh1bmRlZmluZWQsIGhhbmRsZVRvQ2hlY2spO1xuICAgICAgICBjb25zdCBoYW5kbGVOb2RlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZSA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZScpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZUVuZCA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZWVuZCcpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgc291cmNlOiBpc1RhcmdldCA/IGhhbmRsZU5vZGVJZCA6IGZyb21Ob2RlSWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGlzVGFyZ2V0ID8gaGFuZGxlSWQgOiBmcm9tSGFuZGxlSWQsXG4gICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0ID8gZnJvbU5vZGVJZCA6IGhhbmRsZU5vZGVJZCxcbiAgICAgICAgICAgIHRhcmdldEhhbmRsZTogaXNUYXJnZXQgPyBmcm9tSGFuZGxlSWQgOiBoYW5kbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBpc0Nvbm5lY3RhYmxlID0gY29ubmVjdGFibGUgJiYgY29ubmVjdGFibGVFbmQ7XG4gICAgICAgIC8vIGluIHN0cmljdCBtb2RlIHdlIGRvbid0IGFsbG93IHRhcmdldCB0byB0YXJnZXQgb3Igc291cmNlIHRvIHNvdXJjZSBjb25uZWN0aW9uc1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gaXNDb25uZWN0YWJsZSAmJlxuICAgICAgICAgICAgKGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgICAgICA/IChpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAnc291cmNlJykgfHwgKCFpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAndGFyZ2V0JylcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU5vZGVJZCAhPT0gZnJvbU5vZGVJZCB8fCBoYW5kbGVJZCAhPT0gZnJvbUhhbmRsZUlkKTtcbiAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmRIYW5kbGUgPSB7XG4gICAgICAgICAgICAgICAgbm9kZUlkOiBoYW5kbGVOb2RlSWQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgdHlwZTogaGFuZGxlVHlwZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGlzVmFsaWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVMb29rdXAoeyBub2Rlcywgbm9kZUlkLCBoYW5kbGVJZCwgaGFuZGxlVHlwZSB9KSB7XG4gICAgcmV0dXJuIG5vZGVzLnJlZHVjZSgocmVzLCBub2RlKSA9PiB7XG4gICAgICAgIGlmIChub2RlW2ludGVybmFsc1N5bWJvbF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFuZGxlQm91bmRzIH0gPSBub2RlW2ludGVybmFsc1N5bWJvbF07XG4gICAgICAgICAgICBsZXQgc291cmNlSGFuZGxlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHRhcmdldEhhbmRsZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVCb3VuZHMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VIYW5kbGVzID0gZ2V0SGFuZGxlcyhub2RlLCBoYW5kbGVCb3VuZHMsICdzb3VyY2UnLCBgJHtub2RlSWR9LSR7aGFuZGxlSWR9LSR7aGFuZGxlVHlwZX1gKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRIYW5kbGVzID0gZ2V0SGFuZGxlcyhub2RlLCBoYW5kbGVCb3VuZHMsICd0YXJnZXQnLCBgJHtub2RlSWR9LSR7aGFuZGxlSWR9LSR7aGFuZGxlVHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKC4uLnNvdXJjZUhhbmRsZXMsIC4uLnRhcmdldEhhbmRsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlVHlwZShlZGdlVXBkYXRlclR5cGUsIGhhbmRsZURvbU5vZGUpIHtcbiAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiBlZGdlVXBkYXRlclR5cGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygndGFyZ2V0JykpIHtcbiAgICAgICAgcmV0dXJuICd0YXJnZXQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVEb21Ob2RlPy5jbGFzc0xpc3QuY29udGFpbnMoJ3NvdXJjZScpKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZXNldFJlY2VudEhhbmRsZShoYW5kbGVEb21Ob2RlKSB7XG4gICAgaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LnJlbW92ZSgndmFsaWQnLCAnY29ubmVjdGluZycsICdyZWFjdC1mbG93X19oYW5kbGUtdmFsaWQnLCAncmVhY3QtZmxvd19faGFuZGxlLWNvbm5lY3RpbmcnKTtcbn1cbmZ1bmN0aW9uIGdldENvbm5lY3Rpb25TdGF0dXMoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzLCBpc0hhbmRsZVZhbGlkKSB7XG4gICAgbGV0IGNvbm5lY3Rpb25TdGF0dXMgPSBudWxsO1xuICAgIGlmIChpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXMgPSAndmFsaWQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMgJiYgIWlzSGFuZGxlVmFsaWQpIHtcbiAgICAgICAgY29ubmVjdGlvblN0YXR1cyA9ICdpbnZhbGlkJztcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25TdGF0dXM7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKHsgZXZlbnQsIGhhbmRsZUlkLCBub2RlSWQsIG9uQ29ubmVjdCwgaXNUYXJnZXQsIGdldFN0YXRlLCBzZXRTdGF0ZSwgaXNWYWxpZENvbm5lY3Rpb24sIGVkZ2VVcGRhdGVyVHlwZSwgb25FZGdlVXBkYXRlRW5kLCB9KSB7XG4gICAgLy8gd2hlbiByZWFjdC1mbG93IGlzIHVzZWQgaW5zaWRlIGEgc2hhZG93IHJvb3Qgd2UgY2FuJ3QgdXNlIGRvY3VtZW50XG4gICAgY29uc3QgZG9jID0gZ2V0SG9zdEZvckVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Nb2RlLCBkb21Ob2RlLCBhdXRvUGFuT25Db25uZWN0LCBjb25uZWN0aW9uUmFkaXVzLCBvbkNvbm5lY3RTdGFydCwgcGFuQnksIGdldE5vZGVzLCBjYW5jZWxDb25uZWN0aW9uLCB9ID0gZ2V0U3RhdGUoKTtcbiAgICBsZXQgYXV0b1BhbklkID0gMDtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IGNsaWNrZWRIYW5kbGUgPSBkb2M/LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBjbGlja2VkSGFuZGxlKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIWNvbnRhaW5lckJvdW5kcyB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcmV2QWN0aXZlSGFuZGxlO1xuICAgIGxldCBjb25uZWN0aW9uUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGxldCBoYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICBjb25zdCBoYW5kbGVMb29rdXAgPSBnZXRIYW5kbGVMb29rdXAoe1xuICAgICAgICBub2RlczogZ2V0Tm9kZXMoKSxcbiAgICAgICAgbm9kZUlkLFxuICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgaGFuZGxlVHlwZSxcbiAgICB9KTtcbiAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIG1vdmluZyB0aGUgbW91c2UgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhcyB3aGlsZSBjb25uZWN0aW5nIHdlIG1vdmUgdGhlIGNhbnZhc1xuICAgIGNvbnN0IGF1dG9QYW4gPSAoKSA9PiB7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uQ29ubmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt4TW92ZW1lbnQsIHlNb3ZlbWVudF0gPSBjYWxjQXV0b1Bhbihjb25uZWN0aW9uUG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIHBhbkJ5KHsgeDogeE1vdmVtZW50LCB5OiB5TW92ZW1lbnQgfSk7XG4gICAgICAgIGF1dG9QYW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhdXRvUGFuKTtcbiAgICB9O1xuICAgIHNldFN0YXRlKHtcbiAgICAgICAgY29ubmVjdGlvblBvc2l0aW9uLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiBudWxsLFxuICAgICAgICAvLyBjb25uZWN0aW9uTm9kZUlkIGV0YyB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgaW4gZmF2b3Igb2YgY29ubmVjdGlvblN0YXJ0SGFuZGxlXG4gICAgICAgIGNvbm5lY3Rpb25Ob2RlSWQ6IG5vZGVJZCxcbiAgICAgICAgY29ubmVjdGlvbkhhbmRsZUlkOiBoYW5kbGVJZCxcbiAgICAgICAgY29ubmVjdGlvbkhhbmRsZVR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgIGNvbm5lY3Rpb25TdGFydEhhbmRsZToge1xuICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0aW9uRW5kSGFuZGxlOiBudWxsLFxuICAgIH0pO1xuICAgIG9uQ29ubmVjdFN0YXJ0Py4oZXZlbnQsIHsgbm9kZUlkLCBoYW5kbGVJZCwgaGFuZGxlVHlwZSB9KTtcbiAgICBmdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtIH0gPSBnZXRTdGF0ZSgpO1xuICAgICAgICBjb25uZWN0aW9uUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICBjb25zdCB7IGhhbmRsZSwgdmFsaWRIYW5kbGVSZXN1bHQgfSA9IGdldENsb3Nlc3RIYW5kbGUoZXZlbnQsIGRvYywgcG9pbnRUb1JlbmRlcmVyUG9pbnQoY29ubmVjdGlvblBvc2l0aW9uLCB0cmFuc2Zvcm0sIGZhbHNlLCBbMSwgMV0pLCBjb25uZWN0aW9uUmFkaXVzLCBoYW5kbGVMb29rdXAsIChoYW5kbGUpID0+IGlzVmFsaWRIYW5kbGUoaGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgbm9kZUlkLCBoYW5kbGVJZCwgaXNUYXJnZXQgPyAndGFyZ2V0JyA6ICdzb3VyY2UnLCBpc1ZhbGlkQ29ubmVjdGlvbiwgZG9jKSk7XG4gICAgICAgIGNsb3Nlc3RIYW5kbGUgPSBoYW5kbGU7XG4gICAgICAgIGlmICghYXV0b1BhblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGF1dG9QYW4oKTtcbiAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVEb21Ob2RlID0gdmFsaWRIYW5kbGVSZXN1bHQuaGFuZGxlRG9tTm9kZTtcbiAgICAgICAgY29ubmVjdGlvbiA9IHZhbGlkSGFuZGxlUmVzdWx0LmNvbm5lY3Rpb247XG4gICAgICAgIGlzVmFsaWQgPSB2YWxpZEhhbmRsZVJlc3VsdC5pc1ZhbGlkO1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb25uZWN0aW9uUG9zaXRpb246IGNsb3Nlc3RIYW5kbGUgJiYgaXNWYWxpZFxuICAgICAgICAgICAgICAgID8gcmVuZGVyZXJQb2ludFRvUG9pbnQoe1xuICAgICAgICAgICAgICAgICAgICB4OiBjbG9zZXN0SGFuZGxlLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNsb3Nlc3RIYW5kbGUueSxcbiAgICAgICAgICAgICAgICB9LCB0cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgOiBjb25uZWN0aW9uUG9zaXRpb24sXG4gICAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiBnZXRDb25uZWN0aW9uU3RhdHVzKCEhY2xvc2VzdEhhbmRsZSwgaXNWYWxpZCksXG4gICAgICAgICAgICBjb25uZWN0aW9uRW5kSGFuZGxlOiB2YWxpZEhhbmRsZVJlc3VsdC5lbmRIYW5kbGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNsb3Nlc3RIYW5kbGUgJiYgIWlzVmFsaWQgJiYgIWhhbmRsZURvbU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNldFJlY2VudEhhbmRsZShwcmV2QWN0aXZlSGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5zb3VyY2UgIT09IGNvbm5lY3Rpb24udGFyZ2V0ICYmIGhhbmRsZURvbU5vZGUpIHtcbiAgICAgICAgICAgIHJlc2V0UmVjZW50SGFuZGxlKHByZXZBY3RpdmVIYW5kbGUpO1xuICAgICAgICAgICAgcHJldkFjdGl2ZUhhbmRsZSA9IGhhbmRsZURvbU5vZGU7XG4gICAgICAgICAgICAvLyBAdG9kbzogcmVtb3ZlIHRoZSBvbGQgY2xhc3MgbmFtZXMgXCJyZWFjdC1mbG93X19oYW5kbGUtXCIgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAgICAgICAgaGFuZGxlRG9tTm9kZS5jbGFzc0xpc3QuYWRkKCdjb25uZWN0aW5nJywgJ3JlYWN0LWZsb3dfX2hhbmRsZS1jb25uZWN0aW5nJyk7XG4gICAgICAgICAgICBoYW5kbGVEb21Ob2RlLmNsYXNzTGlzdC50b2dnbGUoJ3ZhbGlkJywgaXNWYWxpZCk7XG4gICAgICAgICAgICBoYW5kbGVEb21Ob2RlLmNsYXNzTGlzdC50b2dnbGUoJ3JlYWN0LWZsb3dfX2hhbmRsZS12YWxpZCcsIGlzVmFsaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIGlmICgoY2xvc2VzdEhhbmRsZSB8fCBoYW5kbGVEb21Ob2RlKSAmJiBjb25uZWN0aW9uICYmIGlzVmFsaWQpIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdD8uKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0J3MgaW1wb3J0YW50IHRvIGdldCBhIGZyZXNoIHJlZmVyZW5jZSBmcm9tIHRoZSBzdG9yZSBoZXJlXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIG9uQ29ubmVjdEVuZFxuICAgICAgICBnZXRTdGF0ZSgpLm9uQ29ubmVjdEVuZD8uKGV2ZW50KTtcbiAgICAgICAgaWYgKGVkZ2VVcGRhdGVyVHlwZSkge1xuICAgICAgICAgICAgb25FZGdlVXBkYXRlRW5kPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0UmVjZW50SGFuZGxlKHByZXZBY3RpdmVIYW5kbGUpO1xuICAgICAgICBjYW5jZWxDb25uZWN0aW9uKCk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgIGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIGhhbmRsZURvbU5vZGUgPSBudWxsO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Qb2ludGVyVXApO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uUG9pbnRlclVwKTtcbiAgICB9XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Qb2ludGVyVXApO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblBvaW50ZXJVcCk7XG59XG5cbmNvbnN0IGFsd2F5c1ZhbGlkID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IHNlbGVjdG9yJGYgPSAocykgPT4gKHtcbiAgICBjb25uZWN0aW9uU3RhcnRIYW5kbGU6IHMuY29ubmVjdGlvblN0YXJ0SGFuZGxlLFxuICAgIGNvbm5lY3RPbkNsaWNrOiBzLmNvbm5lY3RPbkNsaWNrLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiBzLm5vUGFuQ2xhc3NOYW1lLFxufSk7XG5jb25zdCBjb25uZWN0aW5nU2VsZWN0b3IgPSAobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSkgPT4gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uU3RhcnRIYW5kbGU6IHN0YXJ0SGFuZGxlLCBjb25uZWN0aW9uRW5kSGFuZGxlOiBlbmRIYW5kbGUsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBjbGlja0hhbmRsZSwgfSA9IHN0YXRlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3Rpbmc6IChzdGFydEhhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgc3RhcnRIYW5kbGU/LmhhbmRsZUlkID09PSBoYW5kbGVJZCAmJiBzdGFydEhhbmRsZT8udHlwZSA9PT0gdHlwZSkgfHxcbiAgICAgICAgICAgIChlbmRIYW5kbGU/Lm5vZGVJZCA9PT0gbm9kZUlkICYmIGVuZEhhbmRsZT8uaGFuZGxlSWQgPT09IGhhbmRsZUlkICYmIGVuZEhhbmRsZT8udHlwZSA9PT0gdHlwZSksXG4gICAgICAgIGNsaWNrQ29ubmVjdGluZzogY2xpY2tIYW5kbGU/Lm5vZGVJZCA9PT0gbm9kZUlkICYmIGNsaWNrSGFuZGxlPy5oYW5kbGVJZCA9PT0gaGFuZGxlSWQgJiYgY2xpY2tIYW5kbGU/LnR5cGUgPT09IHR5cGUsXG4gICAgfTtcbn07XG5jb25zdCBIYW5kbGUgPSBmb3J3YXJkUmVmKCh7IHR5cGUgPSAnc291cmNlJywgcG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGlzVmFsaWRDb25uZWN0aW9uLCBpc0Nvbm5lY3RhYmxlID0gdHJ1ZSwgaXNDb25uZWN0YWJsZVN0YXJ0ID0gdHJ1ZSwgaXNDb25uZWN0YWJsZUVuZCA9IHRydWUsIGlkLCBvbkNvbm5lY3QsIGNoaWxkcmVuLCBjbGFzc05hbWUsIG9uTW91c2VEb3duLCBvblRvdWNoU3RhcnQsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlSWQgPSBpZCB8fCBudWxsO1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gdHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IHsgY29ubmVjdE9uQ2xpY2ssIG5vUGFuQ2xhc3NOYW1lIH0gPSB1c2VTdG9yZShzZWxlY3RvciRmLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IGNvbm5lY3RpbmcsIGNsaWNrQ29ubmVjdGluZyB9ID0gdXNlU3RvcmUoY29ubmVjdGluZ1NlbGVjdG9yKG5vZGVJZCwgaGFuZGxlSWQsIHR5cGUpLCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEwJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTAnXSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb25Db25uZWN0RXh0ZW5kZWQgPSAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEVkZ2VPcHRpb25zLCBvbkNvbm5lY3Q6IG9uQ29ubmVjdEFjdGlvbiwgaGFzRGVmYXVsdEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBlZGdlUGFyYW1zID0ge1xuICAgICAgICAgICAgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBzZXRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHNldEVkZ2VzKGFkZEVkZ2UoZWRnZVBhcmFtcywgZWRnZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBvbkNvbm5lY3RBY3Rpb24/LihlZGdlUGFyYW1zKTtcbiAgICAgICAgb25Db25uZWN0Py4oZWRnZVBhcmFtcyk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNNb3VzZVRyaWdnZXJlZCA9IGlzTW91c2VFdmVudChldmVudCk7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RhYmxlU3RhcnQgJiYgKChpc01vdXNlVHJpZ2dlcmVkICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCkgfHwgIWlzTW91c2VUcmlnZ2VyZWQpKSB7XG4gICAgICAgICAgICBoYW5kbGVQb2ludGVyRG93bih7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RXh0ZW5kZWQsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICAgICAgICAgIHNldFN0YXRlOiBzdG9yZS5zZXRTdGF0ZSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb24gfHwgc3RvcmUuZ2V0U3RhdGUoKS5pc1ZhbGlkQ29ubmVjdGlvbiB8fCBhbHdheXNWYWxpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01vdXNlVHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICBvbk1vdXNlRG93bj8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFub2RlSWQgfHwgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSAmJiAhaXNDb25uZWN0YWJsZVN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUpIHtcbiAgICAgICAgICAgIG9uQ2xpY2tDb25uZWN0U3RhcnQ/LihldmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlOiB0eXBlIH0pO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogeyBub2RlSWQsIHR5cGUsIGhhbmRsZUlkIH0gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gZ2V0SG9zdEZvckVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyID0gaXNWYWxpZENvbm5lY3Rpb24gfHwgaXNWYWxpZENvbm5lY3Rpb25TdG9yZSB8fCBhbHdheXNWYWxpZDtcbiAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uLCBpc1ZhbGlkIH0gPSBpc1ZhbGlkSGFuZGxlKHtcbiAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgIGlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0sIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS5ub2RlSWQsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLmhhbmRsZUlkIHx8IG51bGwsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLnR5cGUsIGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciwgZG9jKTtcbiAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdEV4dGVuZGVkKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2xpY2tDb25uZWN0RW5kPy4oZXZlbnQpO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBudWxsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLWhhbmRsZWlkXCI6IGhhbmRsZUlkLCBcImRhdGEtbm9kZWlkXCI6IG5vZGVJZCwgXCJkYXRhLWhhbmRsZXBvc1wiOiBwb3NpdGlvbiwgXCJkYXRhLWlkXCI6IGAke25vZGVJZH0tJHtoYW5kbGVJZH0tJHt0eXBlfWAsIGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2hhbmRsZScsXG4gICAgICAgICAgICBgcmVhY3QtZmxvd19faGFuZGxlLSR7cG9zaXRpb259YCxcbiAgICAgICAgICAgICdub2RyYWcnLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiAhaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZXN0YXJ0OiBpc0Nvbm5lY3RhYmxlU3RhcnQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGVlbmQ6IGlzQ29ubmVjdGFibGVFbmQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZzogY2xpY2tDb25uZWN0aW5nLFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2xhc3MgaXMgdXNlZCB0byBzdHlsZSB0aGUgaGFuZGxlIHdoZW4gdGhlIHVzZXIgaXMgY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25pbmRpY2F0b3I6IGlzQ29ubmVjdGFibGUgJiYgKChpc0Nvbm5lY3RhYmxlU3RhcnQgJiYgIWNvbm5lY3RpbmcpIHx8IChpc0Nvbm5lY3RhYmxlRW5kICYmIGNvbm5lY3RpbmcpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCBvbk1vdXNlRG93bjogb25Qb2ludGVyRG93biwgb25Ub3VjaFN0YXJ0OiBvblBvaW50ZXJEb3duLCBvbkNsaWNrOiBjb25uZWN0T25DbGljayA/IG9uQ2xpY2sgOiB1bmRlZmluZWQsIHJlZjogcmVmLCAuLi5yZXN0IH0sIGNoaWxkcmVuKSk7XG59KTtcbkhhbmRsZS5kaXNwbGF5TmFtZSA9ICdIYW5kbGUnO1xudmFyIEhhbmRsZSQxID0gbWVtbyhIYW5kbGUpO1xuXG5jb25zdCBEZWZhdWx0Tm9kZSA9ICh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChIYW5kbGUkMSwgeyB0eXBlOiBcInRhcmdldFwiLCBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSksXG4gICAgICAgIGRhdGE/LmxhYmVsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEhhbmRsZSQxLCB7IHR5cGU6IFwic291cmNlXCIsIHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSkpO1xufTtcbkRlZmF1bHROb2RlLmRpc3BsYXlOYW1lID0gJ0RlZmF1bHROb2RlJztcbnZhciBEZWZhdWx0Tm9kZSQxID0gbWVtbyhEZWZhdWx0Tm9kZSk7XG5cbmNvbnN0IElucHV0Tm9kZSA9ICh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tIH0pID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgIGRhdGE/LmxhYmVsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlJDEsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pKSk7XG5JbnB1dE5vZGUuZGlzcGxheU5hbWUgPSAnSW5wdXROb2RlJztcbnZhciBJbnB1dE5vZGUkMSA9IG1lbW8oSW5wdXROb2RlKTtcblxuY29uc3QgT3V0cHV0Tm9kZSA9ICh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wIH0pID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlJDEsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLFxuICAgIGRhdGE/LmxhYmVsKSk7XG5PdXRwdXROb2RlLmRpc3BsYXlOYW1lID0gJ091dHB1dE5vZGUnO1xudmFyIE91dHB1dE5vZGUkMSA9IG1lbW8oT3V0cHV0Tm9kZSk7XG5cbmNvbnN0IEdyb3VwTm9kZSA9ICgpID0+IG51bGw7XG5Hcm91cE5vZGUuZGlzcGxheU5hbWUgPSAnR3JvdXBOb2RlJztcblxuY29uc3Qgc2VsZWN0b3IkZSA9IChzKSA9PiAoe1xuICAgIHNlbGVjdGVkTm9kZXM6IHMuZ2V0Tm9kZXMoKS5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQpLFxuICAgIHNlbGVjdGVkRWRnZXM6IHMuZWRnZXMuZmlsdGVyKChlKSA9PiBlLnNlbGVjdGVkKSxcbn0pO1xuY29uc3Qgc2VsZWN0SWQgPSAob2JqKSA9PiBvYmouaWQ7XG5mdW5jdGlvbiBhcmVFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIChzaGFsbG93KGEuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkTm9kZXMubWFwKHNlbGVjdElkKSkgJiZcbiAgICAgICAgc2hhbGxvdyhhLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSwgYi5zZWxlY3RlZEVkZ2VzLm1hcChzZWxlY3RJZCkpKTtcbn1cbi8vIFRoaXMgaXMganVzdCBhIGhlbHBlciBjb21wb25lbnQgZm9yIGNhbGxpbmcgdGhlIG9uU2VsZWN0aW9uQ2hhbmdlIGxpc3RlbmVyLlxuLy8gQFRPRE86IE5vdyB0aGF0IHdlIGhhdmUgdGhlIG9uTm9kZXNDaGFuZ2UgYW5kIG9uIEVkZ2VzQ2hhbmdlIGxpc3RlbmVycywgZG8gd2Ugc3RpbGwgbmVlZCB0aGlzIGNvbXBvbmVudD9cbmNvbnN0IFNlbGVjdGlvbkxpc3RlbmVyID0gbWVtbygoeyBvblNlbGVjdGlvbkNoYW5nZSB9KSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZSwgYXJlRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgbm9kZXM6IHNlbGVjdGVkTm9kZXMsIGVkZ2VzOiBzZWxlY3RlZEVkZ2VzIH07XG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlPy4ocGFyYW1zKTtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZT8uKHBhcmFtcyk7XG4gICAgfSwgW3NlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMsIG9uU2VsZWN0aW9uQ2hhbmdlXSk7XG4gICAgcmV0dXJuIG51bGw7XG59KTtcblNlbGVjdGlvbkxpc3RlbmVyLmRpc3BsYXlOYW1lID0gJ1NlbGVjdGlvbkxpc3RlbmVyJztcbmNvbnN0IGNoYW5nZVNlbGVjdG9yID0gKHMpID0+ICEhcy5vblNlbGVjdGlvbkNoYW5nZTtcbmZ1bmN0aW9uIFdyYXBwZXIkMSh7IG9uU2VsZWN0aW9uQ2hhbmdlIH0pIHtcbiAgICBjb25zdCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZSA9IHVzZVN0b3JlKGNoYW5nZVNlbGVjdG9yKTtcbiAgICBpZiAob25TZWxlY3Rpb25DaGFuZ2UgfHwgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0aW9uTGlzdGVuZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3Qgc2VsZWN0b3IkZCA9IChzKSA9PiAoe1xuICAgIHNldE5vZGVzOiBzLnNldE5vZGVzLFxuICAgIHNldEVkZ2VzOiBzLnNldEVkZ2VzLFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiBzLnNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLFxuICAgIHNldE1pblpvb206IHMuc2V0TWluWm9vbSxcbiAgICBzZXRNYXhab29tOiBzLnNldE1heFpvb20sXG4gICAgc2V0VHJhbnNsYXRlRXh0ZW50OiBzLnNldFRyYW5zbGF0ZUV4dGVudCxcbiAgICBzZXROb2RlRXh0ZW50OiBzLnNldE5vZGVFeHRlbnQsXG4gICAgcmVzZXQ6IHMucmVzZXQsXG59KTtcbmZ1bmN0aW9uIHVzZVN0b3JlVXBkYXRlcih2YWx1ZSwgc2V0U3RvcmVTdGF0ZSkge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZXRTdG9yZVN0YXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFt2YWx1ZV0pO1xufVxuLy8gdXBkYXRlcyB3aXRoIHZhbHVlcyBpbiBzdG9yZSB0aGF0IGRvbid0IGhhdmUgYSBkZWRpY2F0ZWQgc2V0dGVyIGZ1bmN0aW9uXG5mdW5jdGlvbiB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoa2V5LCB2YWx1ZSwgc2V0U3RhdGUpIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2V0U3RhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbdmFsdWVdKTtcbn1cbmNvbnN0IFN0b3JlVXBkYXRlciA9ICh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIG9uQ29ubmVjdCwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZCwgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgZWRnZXNGb2N1c2FibGUsIGVkZ2VzVXBkYXRhYmxlLCBlbGV2YXRlTm9kZXNPblNlbGVjdCwgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZUV4dGVudCwgb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBjb25uZWN0aW9uTW9kZSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIHRyYW5zbGF0ZUV4dGVudCwgY29ubmVjdE9uQ2xpY2ssIGRlZmF1bHRFZGdlT3B0aW9ucywgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZywgb25TZWxlY3Rpb25EcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG5vUGFuQ2xhc3NOYW1lLCBub2RlT3JpZ2luLCByZklkLCBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZywgb25FcnJvciwgY29ubmVjdGlvblJhZGl1cywgaXNWYWxpZENvbm5lY3Rpb24sIG5vZGVEcmFnVGhyZXNob2xkLCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZXROb2Rlcywgc2V0RWRnZXMsIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLCBzZXRNaW5ab29tLCBzZXRNYXhab29tLCBzZXRUcmFuc2xhdGVFeHRlbnQsIHNldE5vZGVFeHRlbnQsIHJlc2V0LCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZCwgc2hhbGxvdyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVkZ2VzV2l0aERlZmF1bHRzID0gZGVmYXVsdEVkZ2VzPy5tYXAoKGUpID0+ICh7IC4uLmUsIC4uLmRlZmF1bHRFZGdlT3B0aW9ucyB9KSk7XG4gICAgICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzKGRlZmF1bHROb2RlcywgZWRnZXNXaXRoRGVmYXVsdHMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdkZWZhdWx0RWRnZU9wdGlvbnMnLCBkZWZhdWx0RWRnZU9wdGlvbnMsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2Nvbm5lY3Rpb25Nb2RlJywgY29ubmVjdGlvbk1vZGUsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uQ29ubmVjdCcsIG9uQ29ubmVjdCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Db25uZWN0U3RhcnQnLCBvbkNvbm5lY3RTdGFydCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Db25uZWN0RW5kJywgb25Db25uZWN0RW5kLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkNsaWNrQ29ubmVjdFN0YXJ0Jywgb25DbGlja0Nvbm5lY3RTdGFydCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25DbGlja0Nvbm5lY3RFbmQnLCBvbkNsaWNrQ29ubmVjdEVuZCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignbm9kZXNEcmFnZ2FibGUnLCBub2Rlc0RyYWdnYWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignbm9kZXNDb25uZWN0YWJsZScsIG5vZGVzQ29ubmVjdGFibGUsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ25vZGVzRm9jdXNhYmxlJywgbm9kZXNGb2N1c2FibGUsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2VkZ2VzRm9jdXNhYmxlJywgZWRnZXNGb2N1c2FibGUsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2VkZ2VzVXBkYXRhYmxlJywgZWRnZXNVcGRhdGFibGUsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2VsZW1lbnRzU2VsZWN0YWJsZScsIGVsZW1lbnRzU2VsZWN0YWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZWxldmF0ZU5vZGVzT25TZWxlY3QnLCBlbGV2YXRlTm9kZXNPblNlbGVjdCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignc25hcFRvR3JpZCcsIHNuYXBUb0dyaWQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ3NuYXBHcmlkJywgc25hcEdyaWQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uTm9kZXNDaGFuZ2UnLCBvbk5vZGVzQ2hhbmdlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkVkZ2VzQ2hhbmdlJywgb25FZGdlc0NoYW5nZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignY29ubmVjdE9uQ2xpY2snLCBjb25uZWN0T25DbGljaywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZml0Vmlld09uSW5pdCcsIGZpdFZpZXcsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2ZpdFZpZXdPbkluaXRPcHRpb25zJywgZml0Vmlld09wdGlvbnMsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uTm9kZXNEZWxldGUnLCBvbk5vZGVzRGVsZXRlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkVkZ2VzRGVsZXRlJywgb25FZGdlc0RlbGV0ZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Ob2RlRHJhZycsIG9uTm9kZURyYWcsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uTm9kZURyYWdTdGFydCcsIG9uTm9kZURyYWdTdGFydCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Ob2RlRHJhZ1N0b3AnLCBvbk5vZGVEcmFnU3RvcCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25TZWxlY3Rpb25EcmFnJywgb25TZWxlY3Rpb25EcmFnLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvblNlbGVjdGlvbkRyYWdTdGFydCcsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvblNlbGVjdGlvbkRyYWdTdG9wJywgb25TZWxlY3Rpb25EcmFnU3RvcCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignbm9QYW5DbGFzc05hbWUnLCBub1BhbkNsYXNzTmFtZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignbm9kZU9yaWdpbicsIG5vZGVPcmlnaW4sIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ3JmSWQnLCByZklkLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdhdXRvUGFuT25Db25uZWN0JywgYXV0b1Bhbk9uQ29ubmVjdCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignYXV0b1Bhbk9uTm9kZURyYWcnLCBhdXRvUGFuT25Ob2RlRHJhZywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25FcnJvcicsIG9uRXJyb3IsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2Nvbm5lY3Rpb25SYWRpdXMnLCBjb25uZWN0aW9uUmFkaXVzLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdpc1ZhbGlkQ29ubmVjdGlvbicsIGlzVmFsaWRDb25uZWN0aW9uLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub2RlRHJhZ1RocmVzaG9sZCcsIG5vZGVEcmFnVGhyZXNob2xkLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlU3RvcmVVcGRhdGVyKG5vZGVzLCBzZXROb2Rlcyk7XG4gICAgdXNlU3RvcmVVcGRhdGVyKGVkZ2VzLCBzZXRFZGdlcyk7XG4gICAgdXNlU3RvcmVVcGRhdGVyKG1pblpvb20sIHNldE1pblpvb20pO1xuICAgIHVzZVN0b3JlVXBkYXRlcihtYXhab29tLCBzZXRNYXhab29tKTtcbiAgICB1c2VTdG9yZVVwZGF0ZXIodHJhbnNsYXRlRXh0ZW50LCBzZXRUcmFuc2xhdGVFeHRlbnQpO1xuICAgIHVzZVN0b3JlVXBkYXRlcihub2RlRXh0ZW50LCBzZXROb2RlRXh0ZW50KTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHN0eWxlID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbmNvbnN0IGFyaWFMaXZlU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6IDEsXG4gICAgaGVpZ2h0OiAxLFxuICAgIG1hcmdpbjogLTEsXG4gICAgYm9yZGVyOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIGNsaXA6ICdyZWN0KDBweCwgMHB4LCAwcHgsIDBweCknLFxuICAgIGNsaXBQYXRoOiAnaW5zZXQoMTAwJSknLFxufTtcbmNvbnN0IEFSSUFfTk9ERV9ERVNDX0tFWSA9ICdyZWFjdC1mbG93X19ub2RlLWRlc2MnO1xuY29uc3QgQVJJQV9FREdFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX2VkZ2UtZGVzYyc7XG5jb25zdCBBUklBX0xJVkVfTUVTU0FHRSA9ICdyZWFjdC1mbG93X19hcmlhLWxpdmUnO1xuY29uc3Qgc2VsZWN0b3IkYyA9IChzKSA9PiBzLmFyaWFMaXZlTWVzc2FnZTtcbmZ1bmN0aW9uIEFyaWFMaXZlTWVzc2FnZSh7IHJmSWQgfSkge1xuICAgIGNvbnN0IGFyaWFMaXZlTWVzc2FnZSA9IHVzZVN0b3JlKHNlbGVjdG9yJGMpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0xJVkVfTUVTU0FHRX0tJHtyZklkfWAsIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIsIHN0eWxlOiBhcmlhTGl2ZVN0eWxlIH0sIGFyaWFMaXZlTWVzc2FnZSkpO1xufVxuZnVuY3Rpb24gQTExeURlc2NyaXB0aW9ucyh7IHJmSWQsIGRpc2FibGVLZXlib2FyZEExMXkgfSkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGlkOiBgJHtBUklBX05PREVfREVTQ19LRVl9LSR7cmZJZH1gLCBzdHlsZTogc3R5bGUgfSxcbiAgICAgICAgICAgIFwiUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGEgbm9kZS5cIixcbiAgICAgICAgICAgICFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmICdZb3UgY2FuIHRoZW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIG5vZGUgYXJvdW5kLicsXG4gICAgICAgICAgICBcIiBQcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IGFuZCBlc2NhcGUgdG8gY2FuY2VsLlwiLFxuICAgICAgICAgICAgJyAnKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gLCBzdHlsZTogc3R5bGUgfSwgXCJQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYW4gZWRnZS4gWW91IGNhbiB0aGVuIHByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgb3IgZXNjYXBlIHRvIGNhbmNlbC5cIiksXG4gICAgICAgICFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXJpYUxpdmVNZXNzYWdlLCB7IHJmSWQ6IHJmSWQgfSkpKTtcbn1cblxuLy8gdGhlIGtleWNvZGUgY2FuIGJlIGEgc3RyaW5nICdhJyBvciBhbiBhcnJheSBvZiBzdHJpbmdzIFsnYScsICdhK2QnXVxuLy8gYSBzdHJpbmcgbWVhbnMgYSBzaW5nbGUga2V5ICdhJyBvciBhIGNvbWJpbmF0aW9uIHdoZW4gJysnIGlzIHVzZWQgJ2ErZCdcbi8vIGFuIGFycmF5IG1lYW5zIGRpZmZlcmVudCBwb3NzaWJpbGl0aWVzLiBFeHBsYWluZXI6IFsnYScsICdkK3MnXSBoZXJlIHRoZVxuLy8gdXNlciBjYW4gdXNlIHRoZSBzaW5nbGUga2V5ICdhJyBvciB0aGUgY29tYmluYXRpb24gJ2QnICsgJ3MnXG52YXIgdXNlS2V5UHJlc3MgPSAoa2V5Q29kZSA9IG51bGwsIG9wdGlvbnMgPSB7IGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiB0cnVlIH0pID0+IHtcbiAgICBjb25zdCBba2V5UHJlc3NlZCwgc2V0S2V5UHJlc3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciBpZiBhIG1vZGlmaWVyIGtleSBpcyBwcmVzc2VkIGluIG9yZGVyIHRvIHRyYWNrIGl0XG4gICAgY29uc3QgbW9kaWZpZXJQcmVzc2VkID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwcmVzc2VkIGtleXMgaW4gb3JkZXIgdG8gc3VwcG9ydCBjb21iaW5hdGlvbnNcbiAgICBjb25zdCBwcmVzc2VkS2V5cyA9IHVzZVJlZihuZXcgU2V0KFtdKSk7XG4gICAgLy8ga2V5Q29kZXMgPSBhcnJheSB3aXRoIHNpbmdsZSBrZXlzIFtbJ2EnXV0gb3Iga2V5IGNvbWJpbmF0aW9ucyBbWydhJywgJ3MnXV1cbiAgICAvLyBrZXlzVG9XYXRjaCA9IGFycmF5IHdpdGggYWxsIGtleXMgZmxhdHRlbmVkIFsnYScsICdkJywgJ1NoaWZ0TGVmdCddXG4gICAgLy8gdXNlZCB0byBjaGVjayBpZiB3ZSBzdG9yZSBldmVudC5jb2RlIG9yIGV2ZW50LmtleS4gV2hlbiB0aGUgY29kZSBpcyBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaFxuICAgIC8vIHdlIHVzZSB0aGUgY29kZSBvdGhlcndpc2UgdGhlIGtleS4gRXhwbGFpbmVyOiBXaGVuIHlvdSBwcmVzcyB0aGUgbGVmdCBcImNvbW1hbmRcIiBrZXksIHRoZSBjb2RlIGlzIFwiTWV0YUxlZnRcIlxuICAgIC8vIGFuZCB0aGUga2V5IGlzIFwiTWV0YVwiLiBXZSB3YW50IHVzZXJzIHRvIGJlIGFibGUgdG8gcGFzcyBrZXlzIGFuZCBjb2RlcyBzbyB3ZSBhc3N1bWUgdGhhdCB0aGUga2V5IGlzIG1lYW50IHdoZW5cbiAgICAvLyB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoLlxuICAgIGNvbnN0IFtrZXlDb2Rlcywga2V5c1RvV2F0Y2hdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlDb2RlQXJyID0gQXJyYXkuaXNBcnJheShrZXlDb2RlKSA/IGtleUNvZGUgOiBba2V5Q29kZV07XG4gICAgICAgICAgICBjb25zdCBrZXlzID0ga2V5Q29kZUFyci5maWx0ZXIoKGtjKSA9PiB0eXBlb2Yga2MgPT09ICdzdHJpbmcnKS5tYXAoKGtjKSA9PiBrYy5zcGxpdCgnKycpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXNGbGF0ID0ga2V5cy5yZWR1Y2UoKHJlcywgaXRlbSkgPT4gcmVzLmNvbmNhdCguLi5pdGVtKSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXlzLCBrZXlzRmxhdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtbXSwgW11dO1xuICAgIH0sIFtrZXlDb2RlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucz8udGFyZ2V0IHx8IGRvYztcbiAgICAgICAgaWYgKGtleUNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvd25IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmVudEFjdGlvbiA9ICghbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ICYmICFvcHRpb25zLmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmFkZChldmVudFtrZXlPckNvZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEtleVByZXNzZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHVwSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZlbnRBY3Rpb24gPSAoIW1vZGlmaWVyUHJlc3NlZC5jdXJyZW50IHx8IChtb2RpZmllclByZXNzZWQuY3VycmVudCAmJiAhb3B0aW9ucy5hY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcikpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSW5wdXRET01Ob2RlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmVudEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleU9yQ29kZSA9IHVzZUtleU9yQ29kZShldmVudC5jb2RlLCBrZXlzVG9XYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdLZXkoa2V5Q29kZXMsIHByZXNzZWRLZXlzLmN1cnJlbnQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEtleVByZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmRlbGV0ZShldmVudFtrZXlPckNvZGVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZml4IGZvciBNYWM6IHdoZW4gY21kIGtleSBpcyBwcmVzc2VkLCBrZXl1cCBpcyBub3QgdHJpZ2dlcmVkIGZvciBhbnkgb3RoZXIga2V5LCBzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI3MzgwMDE4L3doZW4tY21kLWtleS1pcy1rZXB0LXByZXNzZWQta2V5dXAtaXMtbm90LXRyaWdnZXJlZC1mb3ItYW55LW90aGVyLWtleVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdNZXRhJykge1xuICAgICAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzZXRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YXJnZXQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICB0YXJnZXQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXBIYW5kbGVyKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRhcmdldD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBba2V5Q29kZSwgc2V0S2V5UHJlc3NlZF0pO1xuICAgIHJldHVybiBrZXlQcmVzc2VkO1xufTtcbi8vIHV0aWxzXG5mdW5jdGlvbiBpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cywgaXNVcCkge1xuICAgIHJldHVybiAoa2V5Q29kZXNcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIGNvbXBhcmUgc2FtZSBzaXplcyBvZiBrZXlDb2RlIGRlZmluaXRpb25zXG4gICAgICAgIC8vIGFuZCBwcmVzc2VkIGtleXMuIFdoZW4gdGhlIHVzZXIgc3BlY2lmaWVkICdNZXRhJyBhcyBhIGtleSBzb21ld2hlcmVcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBhbHNvIGJlIHRydXRoeSB3aXRob3V0IHRoaXMgZmlsdGVyIHdoZW4gdXNlciBwcmVzc2VzICdNZXRhJyArICdyJ1xuICAgICAgICAuZmlsdGVyKChrZXlzKSA9PiBpc1VwIHx8IGtleXMubGVuZ3RoID09PSBwcmVzc2VkS2V5cy5zaXplKVxuICAgICAgICAvLyBzaW5jZSB3ZSB3YW50IHRvIHN1cHBvcnQgbXVsdGlwbGUgcG9zc2liaWxpdGllcyBvbmx5IG9uZSBvZiB0aGVcbiAgICAgICAgLy8gY29tYmluYXRpb25zIG5lZWQgdG8gYmUgcGFydCBvZiB0aGUgcHJlc3NlZCBrZXlzXG4gICAgICAgIC5zb21lKChrZXlzKSA9PiBrZXlzLmV2ZXJ5KChrKSA9PiBwcmVzc2VkS2V5cy5oYXMoaykpKSk7XG59XG5mdW5jdGlvbiB1c2VLZXlPckNvZGUoZXZlbnRDb2RlLCBrZXlzVG9XYXRjaCkge1xuICAgIHJldHVybiBrZXlzVG9XYXRjaC5pbmNsdWRlcyhldmVudENvZGUpID8gJ2NvZGUnIDogJ2tleSc7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVhZWlBvc2l0aW9uKG5vZGUsIG5vZGVJbnRlcm5hbHMsIHJlc3VsdCwgbm9kZU9yaWdpbikge1xuICAgIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChub2RlLnBhcmVudE5vZGUpO1xuICAgIGNvbnN0IHBhcmVudE5vZGVQb3NpdGlvbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4ocGFyZW50Tm9kZSwgbm9kZU9yaWdpbik7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVhZWlBvc2l0aW9uKHBhcmVudE5vZGUsIG5vZGVJbnRlcm5hbHMsIHtcbiAgICAgICAgeDogKHJlc3VsdC54ID8/IDApICsgcGFyZW50Tm9kZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IChyZXN1bHQueSA/PyAwKSArIHBhcmVudE5vZGVQb3NpdGlvbi55LFxuICAgICAgICB6OiAocGFyZW50Tm9kZVtpbnRlcm5hbHNTeW1ib2xdPy56ID8/IDApID4gKHJlc3VsdC56ID8/IDApID8gcGFyZW50Tm9kZVtpbnRlcm5hbHNTeW1ib2xdPy56ID8/IDAgOiByZXN1bHQueiA/PyAwLFxuICAgIH0sIG5vZGVPcmlnaW4pO1xufVxuZnVuY3Rpb24gdXBkYXRlQWJzb2x1dGVOb2RlUG9zaXRpb25zKG5vZGVJbnRlcm5hbHMsIG5vZGVPcmlnaW4sIHBhcmVudE5vZGVzKSB7XG4gICAgbm9kZUludGVybmFscy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIW5vZGVJbnRlcm5hbHMuaGFzKG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyZW50IG5vZGUgJHtub2RlLnBhcmVudE5vZGV9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgfHwgcGFyZW50Tm9kZXM/Lltub2RlLmlkXSkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB6IH0gPSBjYWxjdWxhdGVYWVpQb3NpdGlvbihub2RlLCBub2RlSW50ZXJuYWxzLCB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICB6OiBub2RlW2ludGVybmFsc1N5bWJvbF0/LnogPz8gMCxcbiAgICAgICAgICAgIH0sIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbkFic29sdXRlID0ge1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlW2ludGVybmFsc1N5bWJvbF0ueiA9IHo7XG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZXM/Lltub2RlLmlkXSkge1xuICAgICAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxzU3ltYm9sXS5pc1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVJbnRlcm5hbHMobm9kZXMsIG5vZGVJbnRlcm5hbHMsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0KSB7XG4gICAgY29uc3QgbmV4dE5vZGVJbnRlcm5hbHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcGFyZW50Tm9kZXMgPSB7fTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gZWxldmF0ZU5vZGVzT25TZWxlY3QgPyAxMDAwIDogMDtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHogPSAoaXNOdW1lcmljKG5vZGUuekluZGV4KSA/IG5vZGUuekluZGV4IDogMCkgKyAobm9kZS5zZWxlY3RlZCA/IHNlbGVjdGVkTm9kZVogOiAwKTtcbiAgICAgICAgY29uc3QgY3VyckludGVybmFscyA9IG5vZGVJbnRlcm5hbHMuZ2V0KG5vZGUuaWQpO1xuICAgICAgICBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgICAgICAgICB3aWR0aDogY3VyckludGVybmFscz8ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGN1cnJJbnRlcm5hbHM/LmhlaWdodCxcbiAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiB7XG4gICAgICAgICAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGludGVybmFscy5wYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcGFyZW50Tm9kZXNbbm9kZS5wYXJlbnROb2RlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGludGVybmFscywgaW50ZXJuYWxzU3ltYm9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiBjdXJySW50ZXJuYWxzPy5baW50ZXJuYWxzU3ltYm9sXT8uaGFuZGxlQm91bmRzLFxuICAgICAgICAgICAgICAgIHosXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgbmV4dE5vZGVJbnRlcm5hbHMuc2V0KG5vZGUuaWQsIGludGVybmFscyk7XG4gICAgfSk7XG4gICAgdXBkYXRlQWJzb2x1dGVOb2RlUG9zaXRpb25zKG5leHROb2RlSW50ZXJuYWxzLCBub2RlT3JpZ2luLCBwYXJlbnROb2Rlcyk7XG4gICAgcmV0dXJuIG5leHROb2RlSW50ZXJuYWxzO1xufVxuZnVuY3Rpb24gZml0VmlldyhnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZ2V0Tm9kZXMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIGQzWm9vbSwgZDNTZWxlY3Rpb24sIGZpdFZpZXdPbkluaXREb25lLCBmaXRWaWV3T25Jbml0LCBub2RlT3JpZ2luLCB9ID0gZ2V0KCk7XG4gICAgY29uc3QgaXNJbml0aWFsRml0VmlldyA9IG9wdGlvbnMuaW5pdGlhbCAmJiAhZml0Vmlld09uSW5pdERvbmUgJiYgZml0Vmlld09uSW5pdDtcbiAgICBjb25zdCBkM2luaXRpYWxpemVkID0gZDNab29tICYmIGQzU2VsZWN0aW9uO1xuICAgIGlmIChkM2luaXRpYWxpemVkICYmIChpc0luaXRpYWxGaXRWaWV3IHx8ICFvcHRpb25zLmluaXRpYWwpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gZ2V0Tm9kZXMoKS5maWx0ZXIoKG4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUhpZGRlbk5vZGVzID8gbi53aWR0aCAmJiBuLmhlaWdodCA6ICFuLmhpZGRlbjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5vZGVzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWaXNpYmxlICYmIG9wdGlvbnMubm9kZXMuc29tZSgob3B0aW9uTm9kZSkgPT4gb3B0aW9uTm9kZS5pZCA9PT0gbi5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgbm9kZXNJbml0aWFsaXplZCA9IG5vZGVzLmV2ZXJ5KChuKSA9PiBuLndpZHRoICYmIG4uaGVpZ2h0KTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDAgJiYgbm9kZXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0UmVjdE9mTm9kZXMobm9kZXMsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gZ2V0VHJhbnNmb3JtRm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucy5taW5ab29tID8/IG1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSA/PyBtYXhab29tLCBvcHRpb25zLnBhZGRpbmcgPz8gMC4xKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB6b29tSWRlbnRpdHkudHJhbnNsYXRlKHgsIHkpLnNjYWxlKHpvb20pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLmR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGQzWm9vbS50cmFuc2Zvcm0oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zLmR1cmF0aW9uKSwgbmV4dFRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBuZXh0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWROb2RlU2VsZWN0aW9uQ2hhbmdlKG5vZGVDaGFuZ2VzLCBub2RlSW50ZXJuYWxzKSB7XG4gICAgbm9kZUNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZUludGVybmFscy5zZXQobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgW2ludGVybmFsc1N5bWJvbF06IG5vZGVbaW50ZXJuYWxzU3ltYm9sXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogY2hhbmdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1hcChub2RlSW50ZXJuYWxzKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRFZGdlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VDaGFuZ2VzLCBlZGdlcykge1xuICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gZWRnZUNoYW5nZXMuZmluZCgoY2hhbmdlKSA9PiBjaGFuZ2UuaWQgPT09IGUuaWQpO1xuICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgICBlLnNlbGVjdGVkID0gY2hhbmdlLnNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTm9kZXNBbmRFZGdlc1NlbGVjdGlvbnMoeyBjaGFuZ2VkTm9kZXMsIGNoYW5nZWRFZGdlcywgZ2V0LCBzZXQgfSkge1xuICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgZWRnZXMsIG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2UsIGhhc0RlZmF1bHROb2RlcywgaGFzRGVmYXVsdEVkZ2VzIH0gPSBnZXQoKTtcbiAgICBpZiAoY2hhbmdlZE5vZGVzPy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgc2V0KHsgbm9kZUludGVybmFsczogaGFuZGxlQ29udHJvbGxlZE5vZGVTZWxlY3Rpb25DaGFuZ2UoY2hhbmdlZE5vZGVzLCBub2RlSW50ZXJuYWxzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlZE5vZGVzKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWRFZGdlcz8ubGVuZ3RoKSB7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldCh7IGVkZ2VzOiBoYW5kbGVDb250cm9sbGVkRWRnZVNlbGVjdGlvbkNoYW5nZShjaGFuZ2VkRWRnZXMsIGVkZ2VzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlZEVkZ2VzKTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5jb25zdCBpbml0aWFsVmlld3BvcnRIZWxwZXIgPSB7XG4gICAgem9vbUluOiBub29wLFxuICAgIHpvb21PdXQ6IG5vb3AsXG4gICAgem9vbVRvOiBub29wLFxuICAgIGdldFpvb206ICgpID0+IDEsXG4gICAgc2V0Vmlld3BvcnQ6IG5vb3AsXG4gICAgZ2V0Vmlld3BvcnQ6ICgpID0+ICh7IHg6IDAsIHk6IDAsIHpvb206IDEgfSksXG4gICAgZml0VmlldzogKCkgPT4gZmFsc2UsXG4gICAgc2V0Q2VudGVyOiBub29wLFxuICAgIGZpdEJvdW5kczogbm9vcCxcbiAgICBwcm9qZWN0OiAocG9zaXRpb24pID0+IHBvc2l0aW9uLFxuICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQ6IGZhbHNlLFxufTtcbmNvbnN0IHNlbGVjdG9yJGIgPSAocykgPT4gKHtcbiAgICBkM1pvb206IHMuZDNab29tLFxuICAgIGQzU2VsZWN0aW9uOiBzLmQzU2VsZWN0aW9uLFxufSk7XG5jb25zdCB1c2VWaWV3cG9ydEhlbHBlciA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBkM1pvb20sIGQzU2VsZWN0aW9uIH0gPSB1c2VTdG9yZShzZWxlY3RvciRiLCBzaGFsbG93KTtcbiAgICBjb25zdCB2aWV3cG9ydEhlbHBlckZ1bmN0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24gJiYgZDNab29tKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHpvb21JbjogKG9wdGlvbnMpID0+IGQzWm9vbS5zY2FsZUJ5KGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCAxLjIpLFxuICAgICAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiBkM1pvb20uc2NhbGVCeShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uKSwgMSAvIDEuMiksXG4gICAgICAgICAgICAgICAgem9vbVRvOiAoem9vbUxldmVsLCBvcHRpb25zKSA9PiBkM1pvb20uc2NhbGVUbyhnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uKSwgem9vbUxldmVsKSxcbiAgICAgICAgICAgICAgICBnZXRab29tOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydDogKHRyYW5zZm9ybSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgem9vbV0gPSBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHpvb21JZGVudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zbGF0ZSh0cmFuc2Zvcm0ueCA/PyB4LCB0cmFuc2Zvcm0ueSA/PyB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHRyYW5zZm9ybS56b29tID8/IHpvb20pO1xuICAgICAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCBuZXh0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5LCB6b29tIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaXRWaWV3OiAob3B0aW9ucykgPT4gZml0VmlldyhzdG9yZS5nZXRTdGF0ZSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgc2V0Q2VudGVyOiAoeCwgeSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1heFpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRab29tID0gdHlwZW9mIG9wdGlvbnM/Lnpvb20gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy56b29tIDogbWF4Wm9vbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHdpZHRoIC8gMiAtIHggKiBuZXh0Wm9vbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDIgLSB5ICogbmV4dFpvb207XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHpvb21JZGVudGl0eS50cmFuc2xhdGUoY2VudGVyWCwgY2VudGVyWSkuc2NhbGUobmV4dFpvb20pO1xuICAgICAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZml0Qm91bmRzOiAoYm91bmRzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gZ2V0VHJhbnNmb3JtRm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB6b29tSWRlbnRpdHkudHJhbnNsYXRlKHgsIHkpLnNjYWxlKHpvb20pO1xuICAgICAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvamVjdDogKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwVG9HcmlkLCBzbmFwR3JpZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50VG9SZW5kZXJlclBvaW50KHBvc2l0aW9uLCB0cmFuc2Zvcm0sIHNuYXBUb0dyaWQsIHNuYXBHcmlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbml0aWFsVmlld3BvcnRIZWxwZXI7XG4gICAgfSwgW2QzWm9vbSwgZDNTZWxlY3Rpb25dKTtcbiAgICByZXR1cm4gdmlld3BvcnRIZWxwZXJGdW5jdGlvbnM7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gdXNlUmVhY3RGbG93KCkge1xuICAgIGNvbnN0IHZpZXdwb3J0SGVscGVyID0gdXNlVmlld3BvcnRIZWxwZXIoKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgZ2V0Tm9kZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiBzdG9yZVxuICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgIC5nZXROb2RlcygpXG4gICAgICAgICAgICAubWFwKChuKSA9PiAoeyAuLi5uIH0pKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0Tm9kZSA9IHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGdldEVkZ2VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBnZXRFZGdlID0gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGlkKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2V0Tm9kZXMgPSB1c2VDYWxsYmFjaygocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB7IGdldE5vZGVzLCBzZXROb2RlcywgaGFzRGVmYXVsdE5vZGVzLCBvbk5vZGVzQ2hhbmdlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBub2RlcyA9IGdldE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5leHROb2RlcyA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChub2RlcykgOiBwYXlsb2FkO1xuICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICBzZXROb2RlcyhuZXh0Tm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uTm9kZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBuZXh0Tm9kZXMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBub2Rlcy5tYXAoKG5vZGUpID0+ICh7IHR5cGU6ICdyZW1vdmUnLCBpZDogbm9kZS5pZCB9KSlcbiAgICAgICAgICAgICAgICA6IG5leHROb2Rlcy5tYXAoKG5vZGUpID0+ICh7IGl0ZW06IG5vZGUsIHR5cGU6ICdyZXNldCcgfSkpO1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzZXRFZGdlcyA9IHVzZUNhbGxiYWNrKChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgbmV4dEVkZ2VzID0gdHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicgPyBwYXlsb2FkKGVkZ2VzKSA6IHBheWxvYWQ7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHRFZGdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25FZGdlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5leHRFZGdlcy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IGVkZ2VzLm1hcCgoZWRnZSkgPT4gKHsgdHlwZTogJ3JlbW92ZScsIGlkOiBlZGdlLmlkIH0pKVxuICAgICAgICAgICAgICAgIDogbmV4dEVkZ2VzLm1hcCgoZWRnZSkgPT4gKHsgaXRlbTogZWRnZSwgdHlwZTogJ3Jlc2V0JyB9KSk7XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGFkZE5vZGVzID0gdXNlQ2FsbGJhY2soKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgY29uc3QgeyBnZXROb2Rlcywgc2V0Tm9kZXMsIGhhc0RlZmF1bHROb2Rlcywgb25Ob2Rlc0NoYW5nZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGVzID0gZ2V0Tm9kZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb2RlcyA9IFsuLi5jdXJyZW50Tm9kZXMsIC4uLm5vZGVzXTtcbiAgICAgICAgICAgIHNldE5vZGVzKG5leHROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25Ob2Rlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5vZGVzLm1hcCgobm9kZSkgPT4gKHsgaXRlbTogbm9kZSwgdHlwZTogJ2FkZCcgfSkpO1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBhZGRFZGdlcyA9IHVzZUNhbGxiYWNrKChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10sIHNldEVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIG9uRWRnZXNDaGFuZ2UgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKFsuLi5lZGdlcywgLi4ubmV4dEVkZ2VzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25FZGdlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5leHRFZGdlcy5tYXAoKGVkZ2UpID0+ICh7IGl0ZW06IGVkZ2UsIHR5cGU6ICdhZGQnIH0pKTtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdG9PYmplY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2V0Tm9kZXMsIGVkZ2VzID0gW10sIHRyYW5zZm9ybSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gdHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZXM6IGdldE5vZGVzKCkubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpLFxuICAgICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgem9vbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnRzID0gdXNlQ2FsbGJhY2soKHsgbm9kZXM6IG5vZGVzRGVsZXRlZCwgZWRnZXM6IGVkZ2VzRGVsZXRlZCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgZ2V0Tm9kZXMsIGVkZ2VzLCBoYXNEZWZhdWx0Tm9kZXMsIGhhc0RlZmF1bHRFZGdlcywgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSAobm9kZXNEZWxldGVkIHx8IFtdKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuICAgICAgICBjb25zdCBlZGdlSWRzID0gKGVkZ2VzRGVsZXRlZCB8fCBbXSkubWFwKChlZGdlKSA9PiBlZGdlLmlkKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IGdldE5vZGVzKCkucmVkdWNlKChyZXMsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEhpdCA9ICFub2RlSWRzLmluY2x1ZGVzKG5vZGUuaWQpICYmIG5vZGUucGFyZW50Tm9kZSAmJiByZXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0YWJsZSA9IHR5cGVvZiBub2RlLmRlbGV0YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9kZS5kZWxldGFibGUgOiB0cnVlO1xuICAgICAgICAgICAgaWYgKGRlbGV0YWJsZSAmJiAobm9kZUlkcy5pbmNsdWRlcyhub2RlLmlkKSB8fCBwYXJlbnRIaXQpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGNvbnN0IGRlbGV0YWJsZUVkZ2VzID0gZWRnZXMuZmlsdGVyKChlKSA9PiAodHlwZW9mIGUuZGVsZXRhYmxlID09PSAnYm9vbGVhbicgPyBlLmRlbGV0YWJsZSA6IHRydWUpKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbEhpdEVkZ2VzID0gZGVsZXRhYmxlRWRnZXMuZmlsdGVyKChlKSA9PiBlZGdlSWRzLmluY2x1ZGVzKGUuaWQpKTtcbiAgICAgICAgaWYgKG5vZGVzVG9SZW1vdmUgfHwgaW5pdGlhbEhpdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRFZGdlcyA9IGdldENvbm5lY3RlZEVkZ2VzKG5vZGVzVG9SZW1vdmUsIGRlbGV0YWJsZUVkZ2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzVG9SZW1vdmUgPSBbLi4uaW5pdGlhbEhpdEVkZ2VzLCAuLi5jb25uZWN0ZWRFZGdlc107XG4gICAgICAgICAgICBjb25zdCBlZGdlSWRzVG9SZW1vdmUgPSBlZGdlc1RvUmVtb3ZlLnJlZHVjZSgocmVzLCBlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMuaW5jbHVkZXMoZWRnZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goZWRnZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzIHx8IGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLmZpbHRlcigoZSkgPT4gIWVkZ2VJZHNUb1JlbW92ZS5pbmNsdWRlcyhlLmlkKSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUludGVybmFscy5kZWxldGUobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW50ZXJuYWxzOiBuZXcgTWFwKG5vZGVJbnRlcm5hbHMpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZUlkc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4oZWRnZXNUb1JlbW92ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FZGdlc0NoYW5nZShlZGdlSWRzVG9SZW1vdmUubWFwKChpZCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9uTm9kZXNEZWxldGU/Lihub2Rlc1RvUmVtb3ZlKTtcbiAgICAgICAgICAgICAgICBpZiAob25Ob2Rlc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzVG9SZW1vdmUubWFwKChuKSA9PiAoeyBpZDogbi5pZCwgdHlwZTogJ3JlbW92ZScgfSkpO1xuICAgICAgICAgICAgICAgICAgICBvbk5vZGVzQ2hhbmdlKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0Tm9kZVJlY3QgPSB1c2VDYWxsYmFjaygobm9kZU9yUmVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpc1JlY3QgPyBudWxsIDogc3RvcmUuZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChub2RlT3JSZWN0LmlkKTtcbiAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogbm9kZVRvUmVjdChub2RlKTtcbiAgICAgICAgcmV0dXJuIFtub2RlUmVjdCwgbm9kZSwgaXNSZWN0XTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0SW50ZXJzZWN0aW5nTm9kZXMgPSB1c2VDYWxsYmFjaygobm9kZU9yUmVjdCwgcGFydGlhbGx5ID0gdHJ1ZSwgbm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgW25vZGVSZWN0LCBub2RlLCBpc1JlY3RdID0gZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5vZGVzIHx8IHN0b3JlLmdldFN0YXRlKCkuZ2V0Tm9kZXMoKSkuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZS5pZCB8fCAhbi5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3Qobik7XG4gICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEoY3Vyck5vZGVSZWN0LCBub2RlUmVjdCk7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZU9yUmVjdC53aWR0aCAqIG5vZGVPclJlY3QuaGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgaXNOb2RlSW50ZXJzZWN0aW5nID0gdXNlQ2FsbGJhY2soKG5vZGVPclJlY3QsIGFyZWEsIHBhcnRpYWxseSA9IHRydWUpID0+IHtcbiAgICAgICAgY29uc3QgW25vZGVSZWN0XSA9IGdldE5vZGVSZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICBpZiAoIW5vZGVSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKG5vZGVSZWN0LCBhcmVhKTtcbiAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZU9yUmVjdC53aWR0aCAqIG5vZGVPclJlY3QuaGVpZ2h0O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi52aWV3cG9ydEhlbHBlcixcbiAgICAgICAgICAgIGdldE5vZGVzLFxuICAgICAgICAgICAgZ2V0Tm9kZSxcbiAgICAgICAgICAgIGdldEVkZ2VzLFxuICAgICAgICAgICAgZ2V0RWRnZSxcbiAgICAgICAgICAgIHNldE5vZGVzLFxuICAgICAgICAgICAgc2V0RWRnZXMsXG4gICAgICAgICAgICBhZGROb2RlcyxcbiAgICAgICAgICAgIGFkZEVkZ2VzLFxuICAgICAgICAgICAgdG9PYmplY3QsXG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyxcbiAgICAgICAgICAgIGdldEludGVyc2VjdGluZ05vZGVzLFxuICAgICAgICAgICAgaXNOb2RlSW50ZXJzZWN0aW5nLFxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgdmlld3BvcnRIZWxwZXIsXG4gICAgICAgIGdldE5vZGVzLFxuICAgICAgICBnZXROb2RlLFxuICAgICAgICBnZXRFZGdlcyxcbiAgICAgICAgZ2V0RWRnZSxcbiAgICAgICAgc2V0Tm9kZXMsXG4gICAgICAgIHNldEVkZ2VzLFxuICAgICAgICBhZGROb2RlcyxcbiAgICAgICAgYWRkRWRnZXMsXG4gICAgICAgIHRvT2JqZWN0LFxuICAgICAgICBkZWxldGVFbGVtZW50cyxcbiAgICAgICAgZ2V0SW50ZXJzZWN0aW5nTm9kZXMsXG4gICAgICAgIGlzTm9kZUludGVyc2VjdGluZyxcbiAgICBdKTtcbn1cblxuY29uc3QgZGVsZXRlS2V5T3B0aW9ucyA9IHsgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXI6IGZhbHNlIH07XG52YXIgdXNlR2xvYmFsS2V5SGFuZGxlciA9ICh7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSB9KSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgZGVsZXRlRWxlbWVudHMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGRlbGV0ZUtleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhkZWxldGVLZXlDb2RlLCBkZWxldGVLZXlPcHRpb25zKTtcbiAgICBjb25zdCBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhtdWx0aVNlbGVjdGlvbktleUNvZGUpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkZWxldGVLZXlQcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBnZXROb2RlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBnZXROb2RlcygpLmZpbHRlcigobm9kZSkgPT4gbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEVkZ2VzID0gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIGRlbGV0ZUVsZW1lbnRzKHsgbm9kZXM6IHNlbGVjdGVkTm9kZXMsIGVkZ2VzOiBzZWxlY3RlZEVkZ2VzIH0pO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGVsZXRlS2V5UHJlc3NlZF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbXVsdGlTZWxlY3Rpb25BY3RpdmU6IG11bHRpU2VsZWN0aW9uS2V5UHJlc3NlZCB9KTtcbiAgICB9LCBbbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkXSk7XG59O1xuXG5mdW5jdGlvbiB1c2VSZXNpemVIYW5kbGVyKHJlbmRlcmVyTm9kZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlbmRlcmVyTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGdldERpbWVuc2lvbnMocmVuZGVyZXJOb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHNpemUuaGVpZ2h0ID09PSAwIHx8IHNpemUud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA0JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDQnXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgd2lkdGg6IHNpemUud2lkdGggfHwgNTAwLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IHx8IDUwMCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgICAgIGlmIChyZW5kZXJlck5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdXBkYXRlRGltZW5zaW9ucygpKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVuZGVyZXJOb2RlLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgICAgICAgICBpZiAocmVzaXplT2JzZXJ2ZXIgJiYgcmVuZGVyZXJOb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUocmVuZGVyZXJOb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn1cblxuY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAqL1xuY29uc3Qgdmlld0NoYW5nZWQgPSAocHJldlZpZXdwb3J0LCBldmVudFRyYW5zZm9ybSkgPT4gcHJldlZpZXdwb3J0LnggIT09IGV2ZW50VHJhbnNmb3JtLnggfHwgcHJldlZpZXdwb3J0LnkgIT09IGV2ZW50VHJhbnNmb3JtLnkgfHwgcHJldlZpZXdwb3J0Lnpvb20gIT09IGV2ZW50VHJhbnNmb3JtLms7XG5jb25zdCBldmVudFRvRmxvd1RyYW5zZm9ybSA9IChldmVudFRyYW5zZm9ybSkgPT4gKHtcbiAgICB4OiBldmVudFRyYW5zZm9ybS54LFxuICAgIHk6IGV2ZW50VHJhbnNmb3JtLnksXG4gICAgem9vbTogZXZlbnRUcmFuc2Zvcm0uayxcbn0pO1xuY29uc3QgaXNXcmFwcGVkV2l0aENsYXNzID0gKGV2ZW50LCBjbGFzc05hbWUpID0+IGV2ZW50LnRhcmdldC5jbG9zZXN0KGAuJHtjbGFzc05hbWV9YCk7XG5jb25zdCBpc1JpZ2h0Q2xpY2tQYW4gPSAocGFuT25EcmFnLCB1c2VkQnV0dG9uKSA9PiB1c2VkQnV0dG9uID09PSAyICYmIEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMik7XG5jb25zdCB3aGVlbERlbHRhID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZmFjdG9yID0gZXZlbnQuY3RybEtleSAmJiBpc01hY09zKCkgPyAxMCA6IDE7XG4gICAgcmV0dXJuIC1ldmVudC5kZWx0YVkgKiAoZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKiBmYWN0b3I7XG59O1xuY29uc3Qgc2VsZWN0b3IkYSA9IChzKSA9PiAoe1xuICAgIGQzWm9vbTogcy5kM1pvb20sXG4gICAgZDNTZWxlY3Rpb246IHMuZDNTZWxlY3Rpb24sXG4gICAgZDNab29tSGFuZGxlcjogcy5kM1pvb21IYW5kbGVyLFxuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbn0pO1xuY29uc3QgWm9vbVBhbmUgPSAoeyBvbk1vdmUsIG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQsIG9uUGFuZUNvbnRleHRNZW51LCB6b29tT25TY3JvbGwgPSB0cnVlLCB6b29tT25QaW5jaCA9IHRydWUsIHBhbk9uU2Nyb2xsID0gZmFsc2UsIHBhbk9uU2Nyb2xsU3BlZWQgPSAwLjUsIHBhbk9uU2Nyb2xsTW9kZSA9IFBhbk9uU2Nyb2xsTW9kZS5GcmVlLCB6b29tT25Eb3VibGVDbGljayA9IHRydWUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgcGFuT25EcmFnID0gdHJ1ZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIGNoaWxkcmVuLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgfSkgPT4ge1xuICAgIGNvbnN0IHRpbWVySWQgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgaXNab29taW5nT3JQYW5uaW5nID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCB6b29tZWRXaXRoUmlnaHRNb3VzZUJ1dHRvbiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgem9vbVBhbmUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgcHJldlRyYW5zZm9ybSA9IHVzZVJlZih7IHg6IDAsIHk6IDAsIHpvb206IDAgfSk7XG4gICAgY29uc3QgeyBkM1pvb20sIGQzU2VsZWN0aW9uLCBkM1pvb21IYW5kbGVyLCB1c2VyU2VsZWN0aW9uQWN0aXZlIH0gPSB1c2VTdG9yZShzZWxlY3RvciRhLCBzaGFsbG93KTtcbiAgICBjb25zdCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyh6b29tQWN0aXZhdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IG1vdXNlQnV0dG9uID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IGlzUGFuU2Nyb2xsaW5nID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBwYW5TY3JvbGxUaW1lb3V0ID0gdXNlUmVmKCk7XG4gICAgdXNlUmVzaXplSGFuZGxlcih6b29tUGFuZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHpvb21QYW5lLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJib3ggPSB6b29tUGFuZS5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgZDNab29tSW5zdGFuY2UgPSB6b29tKCkuc2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKS50cmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdCh6b29tUGFuZS5jdXJyZW50KS5jYWxsKGQzWm9vbUluc3RhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUcmFuc2Zvcm0gPSB6b29tSWRlbnRpdHlcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKGRlZmF1bHRWaWV3cG9ydC54LCBkZWZhdWx0Vmlld3BvcnQueSlcbiAgICAgICAgICAgICAgICAuc2NhbGUoY2xhbXAoZGVmYXVsdFZpZXdwb3J0Lnpvb20sIG1pblpvb20sIG1heFpvb20pKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgW2Jib3gud2lkdGgsIGJib3guaGVpZ2h0XSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW5lZFRyYW5zZm9ybSA9IGQzWm9vbUluc3RhbmNlLmNvbnN0cmFpbigpKHVwZGF0ZWRUcmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLnRyYW5zZm9ybShzZWxlY3Rpb24sIGNvbnN0cmFpbmVkVHJhbnNmb3JtKTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLndoZWVsRGVsdGEod2hlZWxEZWx0YSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZDNab29tOiBkM1pvb21JbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBkM1NlbGVjdGlvbjogc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGQzWm9vbUhhbmRsZXI6IHNlbGVjdGlvbi5vbignd2hlZWwuem9vbScpLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcGFzcyB0cmFuc2Zvcm0gYmVjYXVzZSB6b29tIGhhbmRsZXIgaXMgbm90IHJlZ2lzdGVyZWQgd2hlbiB3ZSBzZXQgdGhlIGluaXRpYWwgdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBbY29uc3RyYWluZWRUcmFuc2Zvcm0ueCwgY29uc3RyYWluZWRUcmFuc2Zvcm0ueSwgY29uc3RyYWluZWRUcmFuc2Zvcm0ua10sXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogem9vbVBhbmUuY3VycmVudC5jbG9zZXN0KCcucmVhY3QtZmxvdycpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uICYmIGQzWm9vbSkge1xuICAgICAgICAgICAgaWYgKHBhbk9uU2Nyb2xsICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQgJiYgIXVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKS5rIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF9pc01hY09zID0gaXNNYWNPcygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWNvcyBzZXRzIGN0cmxLZXk9dHJ1ZSBmb3IgcGluY2ggZ2VzdHVyZSBvbiBhIHRyYWNrcGFkXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIHpvb21PblBpbmNoICYmIF9pc01hY09zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50ZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGluY2hEZWx0YSA9IHdoZWVsRGVsdGEoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgem9vbSA9IGN1cnJlbnRab29tICogTWF0aC5wb3coMiwgcGluY2hEZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBkM1pvb20uc2NhbGVUbyhkM1NlbGVjdGlvbiwgem9vbSwgcG9pbnQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZSBzY3JvbGwgc3BlZWQgaW4gZmlyZWZveFxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlZm94OiBkZWx0YU1vZGUgPT09IDE7IGNocm9tZTogZGVsdGFNb2RlID09PSAwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhTm9ybWFsaXplID0gZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMjAgOiAxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFYID0gcGFuT25TY3JvbGxNb2RlID09PSBQYW5PblNjcm9sbE1vZGUuVmVydGljYWwgPyAwIDogZXZlbnQuZGVsdGFYICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YVkgPSBwYW5PblNjcm9sbE1vZGUgPT09IFBhbk9uU2Nyb2xsTW9kZS5Ib3Jpem9udGFsID8gMCA6IGV2ZW50LmRlbHRhWSAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGVuYWJsZXMgdmVydGljYWwgc2Nyb2xsaW5nIHdpdGggc2hpZnQgKyBzY3JvbGwgb24gd2luZG93c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pc01hY09zICYmIGV2ZW50LnNoaWZ0S2V5ICYmIHBhbk9uU2Nyb2xsTW9kZSAhPT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVggPSBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZDNab29tLnRyYW5zbGF0ZUJ5KGQzU2VsZWN0aW9uLCAtKGRlbHRhWCAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIC0oZGVsdGFZIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gZXZlbnRUb0Zsb3dUcmFuc2Zvcm0oZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlU3RhcnQsIG9uVmlld3BvcnRDaGFuZ2UsIG9uVmlld3BvcnRDaGFuZ2VFbmQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwYW5TY3JvbGxUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcGFuIG9uIHNjcm9sbCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGUgZXZlbnQgY2FsbHMgb24gb3VyIG93blxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1c2UgdGhlIHN0YXJ0LCB6b29tIGFuZCBlbmQgZXZlbnRzIGZyb20gZDMtem9vbVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHN0YXJ0IGFuZCBtb3ZlIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHNjcm9sbCBldmVudCBhbmQgbm90IG9uY2UgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUGFuU2Nyb2xsaW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFuU2Nyb2xsaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlU3RhcnQ/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VTdGFydD8uKG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFuU2Nyb2xsaW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW92ZT8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5TY3JvbGxUaW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdmVFbmQ/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlRW5kPy4obmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1BhblNjcm9sbGluZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxNTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkM1pvb21IYW5kbGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJywgZnVuY3Rpb24gKGV2ZW50LCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudFNjcm9sbGluZyB8fCBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBkM1pvb21IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQsIGQpO1xuICAgICAgICAgICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICBwYW5PblNjcm9sbE1vZGUsXG4gICAgICAgIGQzU2VsZWN0aW9uLFxuICAgICAgICBkM1pvb20sXG4gICAgICAgIGQzWm9vbUhhbmRsZXIsXG4gICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgIG9uTW92ZVN0YXJ0LFxuICAgICAgICBvbk1vdmUsXG4gICAgICAgIG9uTW92ZUVuZCxcbiAgICBdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZDNab29tKSB7XG4gICAgICAgICAgICBkM1pvb20ub24oJ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFldmVudC5zb3VyY2VFdmVudCB8fCBldmVudC5zb3VyY2VFdmVudC5pbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciBpdCBoZXJlLCBiZWNhdXNlIGl0J3MgYWx3YXlzIDAgaW4gdGhlIFwiem9vbVwiIGV2ZW50XG4gICAgICAgICAgICAgICAgbW91c2VCdXR0b24uY3VycmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50Py5idXR0b247XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlU3RhcnQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmxvd1RyYW5zZm9ybSA9IGV2ZW50VG9GbG93VHJhbnNmb3JtKGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgaXNab29taW5nT3JQYW5uaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZUcmFuc2Zvcm0uY3VycmVudCA9IGZsb3dUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHBhbmVEcmFnZ2luZzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZVN0YXJ0Py4oZmxvd1RyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgb25Nb3ZlU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgZmxvd1RyYW5zZm9ybSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkM1pvb20sIG9uTW92ZVN0YXJ0XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGQzWm9vbSkge1xuICAgICAgICAgICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgIWlzWm9vbWluZ09yUGFubmluZy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgZDNab29tLm9uKCd6b29tJywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGQzWm9vbS5vbignem9vbScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2UgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgdHJhbnNmb3JtOiBbZXZlbnQudHJhbnNmb3JtLngsIGV2ZW50LnRyYW5zZm9ybS55LCBldmVudC50cmFuc2Zvcm0ua10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHpvb21lZFdpdGhSaWdodE1vdXNlQnV0dG9uLmN1cnJlbnQgPSAhIShvblBhbmVDb250ZXh0TWVudSAmJiBpc1JpZ2h0Q2xpY2tQYW4ocGFuT25EcmFnLCBtb3VzZUJ1dHRvbi5jdXJyZW50ID8/IDApKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChvbk1vdmUgfHwgb25WaWV3cG9ydENoYW5nZSkgJiYgIWV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxvd1RyYW5zZm9ybSA9IGV2ZW50VG9GbG93VHJhbnNmb3JtKGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4oZmxvd1RyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudC5zb3VyY2VFdmVudCwgZmxvd1RyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFt1c2VyU2VsZWN0aW9uQWN0aXZlLCBkM1pvb20sIG9uTW92ZSwgcGFuT25EcmFnLCBvblBhbmVDb250ZXh0TWVudV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkM1pvb20pIHtcbiAgICAgICAgICAgIGQzWm9vbS5vbignZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFldmVudC5zb3VyY2VFdmVudCB8fCBldmVudC5zb3VyY2VFdmVudC5pbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlzWm9vbWluZ09yUGFubmluZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBwYW5lRHJhZ2dpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvblBhbmVDb250ZXh0TWVudSAmJlxuICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2tQYW4ocGFuT25EcmFnLCBtb3VzZUJ1dHRvbi5jdXJyZW50ID8/IDApICYmXG4gICAgICAgICAgICAgICAgICAgICF6b29tZWRXaXRoUmlnaHRNb3VzZUJ1dHRvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51KGV2ZW50LnNvdXJjZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgem9vbWVkV2l0aFJpZ2h0TW91c2VCdXR0b24uY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICgob25Nb3ZlRW5kIHx8IG9uVmlld3BvcnRDaGFuZ2VFbmQpICYmIHZpZXdDaGFuZ2VkKHByZXZUcmFuc2Zvcm0uY3VycmVudCwgZXZlbnQudHJhbnNmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbG93VHJhbnNmb3JtID0gZXZlbnRUb0Zsb3dUcmFuc2Zvcm0oZXZlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zZm9ybS5jdXJyZW50ID0gZmxvd1RyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVySWQuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZUVuZD8uKGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlRW5kPy4oZXZlbnQuc291cmNlRXZlbnQsIGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBwYW5PblNjcm9sbCA/IDE1MCA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2QzWm9vbSwgcGFuT25TY3JvbGwsIHBhbk9uRHJhZywgb25Nb3ZlRW5kLCBvblBhbmVDb250ZXh0TWVudV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkM1pvb20pIHtcbiAgICAgICAgICAgIGQzWm9vbS5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgem9vbVNjcm9sbCA9IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCB6b29tT25TY3JvbGw7XG4gICAgICAgICAgICAgICAgY29uc3QgcGluY2hab29tID0gem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleTtcbiAgICAgICAgICAgICAgICBpZiAoKHBhbk9uRHJhZyA9PT0gdHJ1ZSB8fCAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygxKSkpICYmXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID09PSAnbW91c2Vkb3duJyAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCAncmVhY3QtZmxvd19fbm9kZScpIHx8IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgJ3JlYWN0LWZsb3dfX2VkZ2UnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIGFsbCBpbnRlcmFjdGlvbnMgYXJlIGRpc2FibGVkLCB3ZSBwcmV2ZW50IGFsbCB6b29tIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmICghcGFuT25EcmFnICYmICF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhem9vbU9uRG91YmxlQ2xpY2sgJiYgIXpvb21PblBpbmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIGEgc2VsZWN0aW9uIHdlIHByZXZlbnQgYWxsIG90aGVyIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgem9vbSBvbiBkb3VibGUgY2xpY2sgaXMgZGlzYWJsZWQsIHdlIHByZXZlbnQgdGhlIGRvdWJsZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIGlmICghem9vbU9uRG91YmxlQ2xpY2sgJiYgZXZlbnQudHlwZSA9PT0gJ2RibGNsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3doZWVsIGNsYXNzLCB3ZSBwcmV2ZW50IHpvb21pbmdcbiAgICAgICAgICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vcGFuIGNsYXNzLCB3ZSBwcmV2ZW50IHBhbm5pbmdcbiAgICAgICAgICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1BhbkNsYXNzTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCghcGFuT25TY3JvbGwgJiYgZXZlbnQudHlwZSAhPT0gJ3doZWVsJykgfHwgKHBhbk9uU2Nyb2xsICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBubyBzY3JvbGwgaGFuZGxpbmcgZW5hYmxlZCwgd2UgcHJldmVudCBhbGwgd2hlZWwgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhcGluY2hab29tICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBub3QgbW92YWJsZSwgd2UgcHJldmVudCBkcmFnZ2luZyBpdCB3aXRoIG1vdXNlc3RhcnQgb3IgdG91Y2hzdGFydFxuICAgICAgICAgICAgICAgIGlmICghcGFuT25EcmFnICYmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgb25seSBtb3ZhYmxlIHVzaW5nIGFsbG93ZWQgY2xpY2tzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGFsbG93IHJpZ2h0IGNsaWNrcyBpZiBwYW4gb24gZHJhZyBpcyBzZXQgdG8gcmlnaHQgY2xpY2tcbiAgICAgICAgICAgICAgICBjb25zdCBidXR0b25BbGxvd2VkID0gKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSkgfHwgIWV2ZW50LmJ1dHRvbiB8fCBldmVudC5idXR0b24gPD0gMTtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGZpbHRlciBmb3IgZDMtem9vbVxuICAgICAgICAgICAgICAgIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgYnV0dG9uQWxsb3dlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBkM1pvb20sXG4gICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICBlbGVtZW50c1NlbGVjdGFibGUsXG4gICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fcmVuZGVyZXJcIiwgcmVmOiB6b29tUGFuZSwgc3R5bGU6IGNvbnRhaW5lclN0eWxlIH0sIGNoaWxkcmVuKSk7XG59O1xuXG5jb25zdCBzZWxlY3RvciQ5ID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBzLnVzZXJTZWxlY3Rpb25SZWN0LFxufSk7XG5mdW5jdGlvbiBVc2VyU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvblJlY3QgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDksIHNoYWxsb3cpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fc2VsZWN0aW9uIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHVzZXJTZWxlY3Rpb25SZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB1c2VyU2VsZWN0aW9uUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt1c2VyU2VsZWN0aW9uUmVjdC54fXB4LCAke3VzZXJTZWxlY3Rpb25SZWN0Lnl9cHgpYCxcbiAgICAgICAgfSB9KSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVBhcmVudEV4cGFuZChyZXMsIHVwZGF0ZUl0ZW0pIHtcbiAgICBjb25zdCBwYXJlbnQgPSByZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gdXBkYXRlSXRlbS5wYXJlbnROb2RlKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZFdpZHRoID0gdXBkYXRlSXRlbS5wb3NpdGlvbi54ICsgdXBkYXRlSXRlbS53aWR0aCAtIHBhcmVudC53aWR0aDtcbiAgICAgICAgY29uc3QgZXh0ZW5kSGVpZ2h0ID0gdXBkYXRlSXRlbS5wb3NpdGlvbi55ICsgdXBkYXRlSXRlbS5oZWlnaHQgLSBwYXJlbnQuaGVpZ2h0O1xuICAgICAgICBpZiAoZXh0ZW5kV2lkdGggPiAwIHx8IGV4dGVuZEhlaWdodCA+IDAgfHwgdXBkYXRlSXRlbS5wb3NpdGlvbi54IDwgMCB8fCB1cGRhdGVJdGVtLnBvc2l0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3R5bGUgPSB7IC4uLnBhcmVudC5zdHlsZSB9IHx8IHt9O1xuICAgICAgICAgICAgcGFyZW50LnN0eWxlLndpZHRoID0gcGFyZW50LnN0eWxlLndpZHRoID8/IHBhcmVudC53aWR0aDtcbiAgICAgICAgICAgIHBhcmVudC5zdHlsZS5oZWlnaHQgPSBwYXJlbnQuc3R5bGUuaGVpZ2h0ID8/IHBhcmVudC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnN0eWxlLndpZHRoICs9IGV4dGVuZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuZEhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ICs9IGV4dGVuZEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVJdGVtLnBvc2l0aW9uLnggPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeERpZmYgPSBNYXRoLmFicyh1cGRhdGVJdGVtLnBvc2l0aW9uLngpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wb3NpdGlvbi54ID0gcGFyZW50LnBvc2l0aW9uLnggLSB4RGlmZjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUud2lkdGggKz0geERpZmY7XG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVJdGVtLnBvc2l0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeURpZmYgPSBNYXRoLmFicyh1cGRhdGVJdGVtLnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wb3NpdGlvbi55ID0gcGFyZW50LnBvc2l0aW9uLnkgLSB5RGlmZjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ICs9IHlEaWZmO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ucG9zaXRpb24ueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQud2lkdGggPSBwYXJlbnQuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBwYXJlbnQuaGVpZ2h0ID0gcGFyZW50LnN0eWxlLmhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlbGVtZW50cykge1xuICAgIC8vIHdlIG5lZWQgdGhpcyBoYWNrIHRvIGhhbmRsZSB0aGUgc2V0Tm9kZXMgYW5kIHNldEVkZ2VzIGZ1bmN0aW9uIG9mIHRoZSB1c2VSZWFjdEZsb3cgaG9vayBmb3IgY29udHJvbGxlZCBmbG93c1xuICAgIGlmIChjaGFuZ2VzLnNvbWUoKGMpID0+IGMudHlwZSA9PT0gJ3Jlc2V0JykpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZmlsdGVyKChjKSA9PiBjLnR5cGUgPT09ICdyZXNldCcpLm1hcCgoYykgPT4gYy5pdGVtKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdEVsZW1lbnRzID0gY2hhbmdlcy5maWx0ZXIoKGMpID0+IGMudHlwZSA9PT0gJ2FkZCcpLm1hcCgoYykgPT4gYy5pdGVtKTtcbiAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYW5nZXMgPSBjaGFuZ2VzLmZpbHRlcigoYykgPT4gYy5pZCA9PT0gaXRlbS5pZCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVJdGVtID0geyAuLi5pdGVtIH07XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudENoYW5nZSBvZiBjdXJyZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFuZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtLnNlbGVjdGVkID0gY3VycmVudENoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ucG9zaXRpb24gPSBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uQWJzb2x1dGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5wb3NpdGlvbkFic29sdXRlID0gY3VycmVudENoYW5nZS5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0uZHJhZ2dpbmcgPSBjdXJyZW50Q2hhbmdlLmRyYWdnaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUl0ZW0uZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlUGFyZW50RXhwYW5kKHJlcywgdXBkYXRlSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLmRpbWVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS53aWR0aCA9IGN1cnJlbnRDaGFuZ2UuZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtLmhlaWdodCA9IGN1cnJlbnRDaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRDaGFuZ2UudXBkYXRlU3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5zdHlsZSA9IHsgLi4uKHVwZGF0ZUl0ZW0uc3R5bGUgfHwge30pLCAuLi5jdXJyZW50Q2hhbmdlLmRpbWVuc2lvbnMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudENoYW5nZS5yZXNpemluZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5yZXNpemluZyA9IGN1cnJlbnRDaGFuZ2UucmVzaXppbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlSXRlbS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXJlbnRFeHBhbmQocmVzLCB1cGRhdGVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2godXBkYXRlSXRlbSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgaW5pdEVsZW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbn1cbmNvbnN0IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZSA9IChpZCwgc2VsZWN0ZWQpID0+ICh7XG4gICAgaWQsXG4gICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgc2VsZWN0ZWQsXG59KTtcbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkNoYW5nZXMoaXRlbXMsIHNlbGVjdGVkSWRzKSB7XG4gICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgocmVzLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbGxCZVNlbGVjdGVkID0gc2VsZWN0ZWRJZHMuaW5jbHVkZXMoaXRlbS5pZCk7XG4gICAgICAgIGlmICghaXRlbS5zZWxlY3RlZCAmJiB3aWxsQmVTZWxlY3RlZCkge1xuICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0uc2VsZWN0ZWQgJiYgIXdpbGxCZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBUaGUgdXNlciBzZWxlY3Rpb24gcmVjdGFuZ2xlIGdldHMgZGlzcGxheWVkIHdoZW4gYSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyBzaGlmdFxuICovXG5jb25zdCB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBjb250YWluZXJSZWYpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9O1xufTtcbmNvbnN0IHNlbGVjdG9yJDggPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBkcmFnZ2luZzogcy5wYW5lRHJhZ2dpbmcsXG59KTtcbmNvbnN0IFBhbmUgPSBtZW1vKCh7IGlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5PbkRyYWcsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljaywgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBjaGlsZHJlbiwgfSkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgcHJldlNlbGVjdGVkTm9kZXNDb3VudCA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0ZWRFZGdlc0NvdW50ID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBkcmFnZ2luZyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkOCwgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVzZXRVc2VyU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLCB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCB9KTtcbiAgICAgICAgcHJldlNlbGVjdGVkTm9kZXNDb3VudC5jdXJyZW50ID0gMDtcbiAgICAgICAgcHJldlNlbGVjdGVkRWRnZXNDb3VudC5jdXJyZW50ID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzZXRTZWxlY3RlZEVsZW1lbnRzLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb250YWluZXJCb3VuZHMuY3VycmVudCA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzU2VsZWN0YWJsZSB8fFxuICAgICAgICAgICAgIWlzU2VsZWN0aW5nIHx8XG4gICAgICAgICAgICBldmVudC5idXR0b24gIT09IDAgfHxcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICFjb250YWluZXJCb3VuZHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB4LFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogeSxcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgb25TZWxlY3Rpb25TdGFydD8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIG5vZGVJbnRlcm5hbHMsIGVkZ2VzLCB0cmFuc2Zvcm0sIG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2UsIG5vZGVPcmlnaW4sIGdldE5vZGVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIWlzU2VsZWN0aW5nIHx8ICFjb250YWluZXJCb3VuZHMuY3VycmVudCB8fCAhdXNlclNlbGVjdGlvblJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHVzZXJTZWxlY3Rpb25BY3RpdmU6IHRydWUsIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgbW91c2VQb3MgPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IHVzZXJTZWxlY3Rpb25SZWN0LnN0YXJ0WCA/PyAwO1xuICAgICAgICBjb25zdCBzdGFydFkgPSB1c2VyU2VsZWN0aW9uUmVjdC5zdGFydFkgPz8gMDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgLi4udXNlclNlbGVjdGlvblJlY3QsXG4gICAgICAgICAgICB4OiBtb3VzZVBvcy54IDwgc3RhcnRYID8gbW91c2VQb3MueCA6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgPCBzdGFydFkgPyBtb3VzZVBvcy55IDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlUG9zLnggLSBzdGFydFgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhtb3VzZVBvcy55IC0gc3RhcnRZKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBnZXROb2RlcygpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXNJbnNpZGUobm9kZUludGVybmFscywgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWRnZUlkcyA9IGdldENvbm5lY3RlZEVkZ2VzKHNlbGVjdGVkTm9kZXMsIGVkZ2VzKS5tYXAoKGUpID0+IGUuaWQpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVzLm1hcCgobikgPT4gbi5pZCk7XG4gICAgICAgIGlmIChwcmV2U2VsZWN0ZWROb2Rlc0NvdW50LmN1cnJlbnQgIT09IHNlbGVjdGVkTm9kZUlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByZXZTZWxlY3RlZE5vZGVzQ291bnQuY3VycmVudCA9IHNlbGVjdGVkTm9kZUlkcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2Rlcywgc2VsZWN0ZWROb2RlSWRzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9uTm9kZXNDaGFuZ2U/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlNlbGVjdGVkRWRnZXNDb3VudC5jdXJyZW50ICE9PSBzZWxlY3RlZEVkZ2VJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmV2U2VsZWN0ZWRFZGdlc0NvdW50LmN1cnJlbnQgPSBzZWxlY3RlZEVkZ2VJZHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZXMsIHNlbGVjdGVkRWRnZUlkcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG5leHRVc2VyU2VsZWN0UmVjdCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIGNsaWNrIGZ1bmN0aW9ucyB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIGlmXG4gICAgICAgIC8vIHRoZSB1c2VyIGRpZCBub3QgbW92ZSB0aGUgbW91c2UuXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IHByZXZTZWxlY3RlZE5vZGVzQ291bnQuY3VycmVudCA+IDAgfSk7XG4gICAgICAgIHJlc2V0VXNlclNlbGVjdGlvbigpO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogcHJldlNlbGVjdGVkTm9kZXNDb3VudC5jdXJyZW50ID4gMCB9KTtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uRW5kPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0VXNlclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgY29uc3QgaGFzQWN0aXZlU2VsZWN0aW9uID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZScsIHsgZHJhZ2dpbmcsIHNlbGVjdGlvbjogaXNTZWxlY3RpbmcgfV0pLCBvbkNsaWNrOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpLCBvbkNvbnRleHRNZW51OiB3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpLCBvbldoZWVsOiB3cmFwSGFuZGxlcihvbldoZWVsLCBjb250YWluZXIpLCBvbk1vdXNlRW50ZXI6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IHVuZGVmaW5lZCA6IG9uUGFuZU1vdXNlRW50ZXIsIG9uTW91c2VEb3duOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvbk1vdXNlRG93biA6IHVuZGVmaW5lZCwgb25Nb3VzZU1vdmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uTW91c2VNb3ZlIDogb25QYW5lTW91c2VNb3ZlLCBvbk1vdXNlVXA6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uTW91c2VVcCA6IHVuZGVmaW5lZCwgb25Nb3VzZUxlYXZlOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvbk1vdXNlTGVhdmUgOiBvblBhbmVNb3VzZUxlYXZlLCByZWY6IGNvbnRhaW5lciwgc3R5bGU6IGNvbnRhaW5lclN0eWxlIH0sXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFVzZXJTZWxlY3Rpb24sIG51bGwpKSk7XG59KTtcblBhbmUuZGlzcGxheU5hbWUgPSAnUGFuZSc7XG5cbmZ1bmN0aW9uIGlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUludGVybmFscykge1xuICAgIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1BhcmVudFNlbGVjdGVkKHBhcmVudE5vZGUsIG5vZGVJbnRlcm5hbHMpO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0b3IodGFyZ2V0LCBzZWxlY3Rvciwgbm9kZVJlZikge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/Lm1hdGNoZXMoc2VsZWN0b3IpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBub2RlUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gbG9va3MgZm9yIGFsbCBzZWxlY3RlZCBub2RlcyBhbmQgY3JlYXRlZCBhIE5vZGVEcmFnSXRlbSBmb3IgZWFjaCBvZiB0aGVtXG5mdW5jdGlvbiBnZXREcmFnSXRlbXMobm9kZUludGVybmFscywgbm9kZXNEcmFnZ2FibGUsIG1vdXNlUG9zLCBub2RlSWQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlSW50ZXJuYWxzLnZhbHVlcygpKVxuICAgICAgICAuZmlsdGVyKChuKSA9PiAobi5zZWxlY3RlZCB8fCBuLmlkID09PSBub2RlSWQpICYmXG4gICAgICAgICghbi5wYXJlbnROb2RlIHx8ICFpc1BhcmVudFNlbGVjdGVkKG4sIG5vZGVJbnRlcm5hbHMpKSAmJlxuICAgICAgICAobi5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBuLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKSlcbiAgICAgICAgLm1hcCgobikgPT4gKHtcbiAgICAgICAgaWQ6IG4uaWQsXG4gICAgICAgIHBvc2l0aW9uOiBuLnBvc2l0aW9uIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBuLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICB4OiBtb3VzZVBvcy54IC0gKG4ucG9zaXRpb25BYnNvbHV0ZT8ueCA/PyAwKSxcbiAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgLSAobi5wb3NpdGlvbkFic29sdXRlPy55ID8/IDApLFxuICAgICAgICB9LFxuICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVudDogbi5leHRlbnQsXG4gICAgICAgIHBhcmVudE5vZGU6IG4ucGFyZW50Tm9kZSxcbiAgICAgICAgd2lkdGg6IG4ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbi5oZWlnaHQsXG4gICAgICAgIGV4cGFuZFBhcmVudDogbi5leHBhbmRQYXJlbnQsXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gY2xhbXBOb2RlRXh0ZW50KG5vZGUsIGV4dGVudCkge1xuICAgIGlmICghZXh0ZW50IHx8IGV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9XG4gICAgcmV0dXJuIFtleHRlbnRbMF0sIFtleHRlbnRbMV1bMF0gLSAobm9kZS53aWR0aCB8fCAwKSwgZXh0ZW50WzFdWzFdIC0gKG5vZGUuaGVpZ2h0IHx8IDApXV07XG59XG5mdW5jdGlvbiBjYWxjTmV4dFBvc2l0aW9uKG5vZGUsIG5leHRQb3NpdGlvbiwgbm9kZUludGVybmFscywgbm9kZUV4dGVudCwgbm9kZU9yaWdpbiA9IFswLCAwXSwgb25FcnJvcikge1xuICAgIGNvbnN0IGNsYW1wZWROb2RlRXh0ZW50ID0gY2xhbXBOb2RlRXh0ZW50KG5vZGUsIG5vZGUuZXh0ZW50IHx8IG5vZGVFeHRlbnQpO1xuICAgIGxldCBjdXJyZW50RXh0ZW50ID0gY2xhbXBlZE5vZGVFeHRlbnQ7XG4gICAgaWYgKG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyAmJiAhbm9kZS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLndpZHRoICYmIG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlSW50ZXJuYWxzLmdldChub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHBhcmVudCwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIGN1cnJlbnRFeHRlbnQgPVxuICAgICAgICAgICAgICAgIHBhcmVudCAmJiBpc051bWVyaWMocGFyZW50WCkgJiYgaXNOdW1lcmljKHBhcmVudFkpICYmIGlzTnVtZXJpYyhwYXJlbnQud2lkdGgpICYmIGlzTnVtZXJpYyhwYXJlbnQuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYICsgbm9kZS53aWR0aCAqIG5vZGVPcmlnaW5bMF0sIHBhcmVudFkgKyBub2RlLmhlaWdodCAqIG5vZGVPcmlnaW5bMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFggKyBwYXJlbnQud2lkdGggLSBub2RlLndpZHRoICsgbm9kZS53aWR0aCAqIG5vZGVPcmlnaW5bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50WSArIHBhcmVudC5oZWlnaHQgLSBub2RlLmhlaWdodCArIG5vZGUuaGVpZ2h0ICogbm9kZU9yaWdpblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50RXh0ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNSddKCkpO1xuICAgICAgICAgICAgY3VycmVudEV4dGVudCA9IGNsYW1wZWROb2RlRXh0ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUuZXh0ZW50ICYmIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLmV4dGVudCAhPT0gJ3BhcmVudCcpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZUludGVybmFscy5nZXQobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHBhcmVudCwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgY3VycmVudEV4dGVudCA9IFtcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFswXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzBdWzFdICsgcGFyZW50WV0sXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMV1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFsxXVsxXSArIHBhcmVudFldLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBsZXQgcGFyZW50UG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICBwYXJlbnRQb3NpdGlvbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4ocGFyZW50Tm9kZSwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IGN1cnJlbnRFeHRlbnQgJiYgY3VycmVudEV4dGVudCAhPT0gJ3BhcmVudCdcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgY3VycmVudEV4dGVudClcbiAgICAgICAgOiBuZXh0UG9zaXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uQWJzb2x1dGUueCAtIHBhcmVudFBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBwb3NpdGlvbkFic29sdXRlLnkgLSBwYXJlbnRQb3NpdGlvbi55LFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgIH07XG59XG4vLyByZXR1cm5zIHR3byBwYXJhbXM6XG4vLyAxLiB0aGUgZHJhZ2dlZCBub2RlIChvciB0aGUgZmlyc3Qgb2YgdGhlIGxpc3QsIGlmIHdlIGFyZSBkcmFnZ2luZyBhIG5vZGUgc2VsZWN0aW9uKVxuLy8gMi4gYXJyYXkgb2Ygc2VsZWN0ZWQgbm9kZXMgKGZvciBtdWx0aSBzZWxlY3Rpb25zKVxuZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHsgbm9kZUlkLCBkcmFnSXRlbXMsIG5vZGVJbnRlcm5hbHMsIH0pIHtcbiAgICBjb25zdCBleHRlbnRlZERyYWdJdGVtcyA9IGRyYWdJdGVtcy5tYXAoKG4pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KG4uaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuLnBvc2l0aW9uLFxuICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogbi5wb3NpdGlvbkFic29sdXRlLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBbbm9kZUlkID8gZXh0ZW50ZWREcmFnSXRlbXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZUlkKSA6IGV4dGVudGVkRHJhZ0l0ZW1zWzBdLCBleHRlbnRlZERyYWdJdGVtc107XG59XG5cbmNvbnN0IGdldEhhbmRsZUJvdW5kcyA9IChzZWxlY3Rvciwgbm9kZUVsZW1lbnQsIHpvb20sIG5vZGVPcmlnaW4pID0+IHtcbiAgICBjb25zdCBoYW5kbGVzID0gbm9kZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgaWYgKCFoYW5kbGVzIHx8ICFoYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlc0FycmF5ID0gQXJyYXkuZnJvbShoYW5kbGVzKTtcbiAgICBjb25zdCBub2RlQm91bmRzID0gbm9kZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgbm9kZU9mZnNldCA9IHtcbiAgICAgICAgeDogbm9kZUJvdW5kcy53aWR0aCAqIG5vZGVPcmlnaW5bMF0sXG4gICAgICAgIHk6IG5vZGVCb3VuZHMuaGVpZ2h0ICogbm9kZU9yaWdpblsxXSxcbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVzQXJyYXkubWFwKChoYW5kbGUpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlQm91bmRzID0gaGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZXBvcycpLFxuICAgICAgICAgICAgeDogKGhhbmRsZUJvdW5kcy5sZWZ0IC0gbm9kZUJvdW5kcy5sZWZ0IC0gbm9kZU9mZnNldC54KSAvIHpvb20sXG4gICAgICAgICAgICB5OiAoaGFuZGxlQm91bmRzLnRvcCAtIG5vZGVCb3VuZHMudG9wIC0gbm9kZU9mZnNldC55KSAvIHpvb20sXG4gICAgICAgICAgICAuLi5nZXREaW1lbnNpb25zKGhhbmRsZSksXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZ2V0TW91c2VIYW5kbGVyKGlkLCBnZXRTdGF0ZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVyID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBoYW5kbGVyXG4gICAgICAgIDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXZlbnQsIHsgLi4ubm9kZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbn1cbi8vIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgYnlcbi8vIDEuIHRoZSBjbGljayBoYW5kbGVyIHdoZW4gbm9kZSBpcyBub3QgZHJhZ2dhYmxlIG9yIHNlbGVjdE5vZGVzT25EcmFnID0gZmFsc2Vcbi8vIG9yXG4vLyAyLiB0aGUgb24gZHJhZyBzdGFydCBoYW5kbGVyIHdoZW4gbm9kZSBpcyBkcmFnZ2FibGUgYW5kIHNlbGVjdE5vZGVzT25EcmFnID0gdHJ1ZVxuZnVuY3Rpb24gaGFuZGxlTm9kZUNsaWNrKHsgaWQsIHN0b3JlLCB1bnNlbGVjdCA9IGZhbHNlLCBub2RlUmVmLCB9KSB7XG4gICAgY29uc3QgeyBhZGRTZWxlY3RlZE5vZGVzLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG11bHRpU2VsZWN0aW9uQWN0aXZlLCBub2RlSW50ZXJuYWxzLCBvbkVycm9yIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDEyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTInXShpZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIGlmICghbm9kZS5zZWxlY3RlZCkge1xuICAgICAgICBhZGRTZWxlY3RlZE5vZGVzKFtpZF0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh1bnNlbGVjdCB8fCAobm9kZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkpIHtcbiAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgbm9kZXM6IFtub2RlXSwgZWRnZXM6IFtdIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gbm9kZVJlZj8uY3VycmVudD8uYmx1cigpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZUdldFBvaW50ZXJQb3NpdGlvbigpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgLy8gcmV0dXJucyB0aGUgcG9pbnRlciBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIFJGIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgY29uc3QgZ2V0UG9pbnRlclBvc2l0aW9uID0gdXNlQ2FsbGJhY2soKHsgc291cmNlRXZlbnQgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHggPSBzb3VyY2VFdmVudC50b3VjaGVzID8gc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYIDogc291cmNlRXZlbnQuY2xpZW50WDtcbiAgICAgICAgY29uc3QgeSA9IHNvdXJjZUV2ZW50LnRvdWNoZXMgPyBzb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFkgOiBzb3VyY2VFdmVudC5jbGllbnRZO1xuICAgICAgICBjb25zdCBwb2ludGVyUG9zID0ge1xuICAgICAgICAgICAgeDogKHggLSB0cmFuc2Zvcm1bMF0pIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgeTogKHkgLSB0cmFuc2Zvcm1bMV0pIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBuZWVkIHRoZSBzbmFwcGVkIHBvc2l0aW9uIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gc2tpcCB1bm5lY2Vzc2FyeSBkcmFnIGV2ZW50c1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeFNuYXBwZWQ6IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQocG9pbnRlclBvcy54IC8gc25hcEdyaWRbMF0pIDogcG9pbnRlclBvcy54LFxuICAgICAgICAgICAgeVNuYXBwZWQ6IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSAqIE1hdGgucm91bmQocG9pbnRlclBvcy55IC8gc25hcEdyaWRbMV0pIDogcG9pbnRlclBvcy55LFxuICAgICAgICAgICAgLi4ucG9pbnRlclBvcyxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGdldFBvaW50ZXJQb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gd3JhcFNlbGVjdGlvbkRyYWdGdW5jKHNlbGVjdGlvbkZ1bmMpIHtcbiAgICByZXR1cm4gKGV2ZW50LCBfLCBub2RlcykgPT4gc2VsZWN0aW9uRnVuYz8uKGV2ZW50LCBub2Rlcyk7XG59XG5mdW5jdGlvbiB1c2VEcmFnKHsgbm9kZVJlZiwgZGlzYWJsZWQgPSBmYWxzZSwgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3Rvciwgbm9kZUlkLCBpc1NlbGVjdGFibGUsIHNlbGVjdE5vZGVzT25EcmFnLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGRyYWdJdGVtcyA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgbGFzdFBvcyA9IHVzZVJlZih7IHg6IG51bGwsIHk6IG51bGwgfSk7XG4gICAgY29uc3QgYXV0b1BhbklkID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBtb3VzZVBvc2l0aW9uID0gdXNlUmVmKHsgeDogMCwgeTogMCB9KTtcbiAgICBjb25zdCBkcmFnRXZlbnQgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgYXV0b1BhblN0YXJ0ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRyYWdTdGFydGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBnZXRQb2ludGVyUG9zaXRpb24gPSB1c2VHZXRQb2ludGVyUG9zaXRpb24oKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZj8uY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0KG5vZGVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVOb2RlcyA9ICh7IHgsIHkgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgb25Ob2RlRHJhZywgb25TZWxlY3Rpb25EcmFnLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBub2RlRXh0ZW50LCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgb25FcnJvciwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50ID0geyB4LCB5IH07XG4gICAgICAgICAgICAgICAgbGV0IGhhc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBub2Rlc0JveCA9IHsgeDogMCwgeTogMCwgeDI6IDAsIHkyOiAwIH07XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5jdXJyZW50Lmxlbmd0aCA+IDEgJiYgbm9kZUV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gZ2V0UmVjdE9mTm9kZXMoZHJhZ0l0ZW1zLmN1cnJlbnQsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc0JveCA9IHJlY3RUb0JveChyZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLmN1cnJlbnQgPSBkcmFnSXRlbXMuY3VycmVudC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0geyB4OiB4IC0gbi5kaXN0YW5jZS54LCB5OiB5IC0gbi5kaXN0YW5jZS55IH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueCA9IHNuYXBHcmlkWzBdICogTWF0aC5yb3VuZChuZXh0UG9zaXRpb24ueCAvIHNuYXBHcmlkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIHNlbGVjdGlvbiB3aXRoIG11bHRpcGxlIG5vZGVzIGFuZCBhIG5vZGUgZXh0ZW50IGlzIHNldCwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIG5vZGUgZXh0ZW50IGZvciBlYWNoIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFzZWQgb24gaXRzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIG5vZGUgc3RheXMgYXQgaXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbbm9kZUV4dGVudFswXVswXSwgbm9kZUV4dGVudFswXVsxXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbbm9kZUV4dGVudFsxXVswXSwgbm9kZUV4dGVudFsxXVsxXV0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuY3VycmVudC5sZW5ndGggPiAxICYmIG5vZGVFeHRlbnQgJiYgIW4uZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnRbMF1bMF0gPSBuLnBvc2l0aW9uQWJzb2x1dGUueCAtIG5vZGVzQm94LnggKyBub2RlRXh0ZW50WzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWROb2RlRXh0ZW50WzFdWzBdID0gbi5wb3NpdGlvbkFic29sdXRlLnggKyAobi53aWR0aCA/PyAwKSAtIG5vZGVzQm94LngyICsgbm9kZUV4dGVudFsxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkTm9kZUV4dGVudFswXVsxXSA9IG4ucG9zaXRpb25BYnNvbHV0ZS55IC0gbm9kZXNCb3gueSArIG5vZGVFeHRlbnRbMF1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnRbMV1bMV0gPSBuLnBvc2l0aW9uQWJzb2x1dGUueSArIChuLmhlaWdodCA/PyAwKSAtIG5vZGVzQm94LnkyICsgbm9kZUV4dGVudFsxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkUG9zID0gY2FsY05leHRQb3NpdGlvbihuLCBuZXh0UG9zaXRpb24sIG5vZGVJbnRlcm5hbHMsIGFkanVzdGVkTm9kZUV4dGVudCwgbm9kZU9yaWdpbiwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBmaXJlIGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gaGFzQ2hhbmdlIHx8IG4ucG9zaXRpb24ueCAhPT0gdXBkYXRlZFBvcy5wb3NpdGlvbi54IHx8IG4ucG9zaXRpb24ueSAhPT0gdXBkYXRlZFBvcy5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgICAgICBuLnBvc2l0aW9uID0gdXBkYXRlZFBvcy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbi5wb3NpdGlvbkFic29sdXRlID0gdXBkYXRlZFBvcy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLmN1cnJlbnQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRHJhZyA9IG5vZGVJZCA/IG9uTm9kZURyYWcgOiB3cmFwU2VsZWN0aW9uRHJhZ0Z1bmMob25TZWxlY3Rpb25EcmFnKTtcbiAgICAgICAgICAgICAgICBpZiAob25EcmFnICYmIGRyYWdFdmVudC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgbm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtczogZHJhZ0l0ZW1zLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25EcmFnKGRyYWdFdmVudC5jdXJyZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhdXRvUGFuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbeE1vdmVtZW50LCB5TW92ZW1lbnRdID0gY2FsY0F1dG9QYW4obW91c2VQb3NpdGlvbi5jdXJyZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHhNb3ZlbWVudCAhPT0gMCB8fCB5TW92ZW1lbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHBhbkJ5IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UG9zLmN1cnJlbnQueCA9IChsYXN0UG9zLmN1cnJlbnQueCA/PyAwKSAtIHhNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50LnkgPSAobGFzdFBvcy5jdXJyZW50LnkgPz8gMCkgLSB5TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYW5CeSh7IHg6IHhNb3ZlbWVudCwgeTogeU1vdmVtZW50IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVOb2RlcyhsYXN0UG9zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF1dG9QYW5JZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RHJhZyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVzRHJhZ2dhYmxlLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG9uTm9kZURyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RhcnQsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uU3RhcnQgPSBub2RlSWQgPyBvbk5vZGVEcmFnU3RhcnQgOiB3cmFwU2VsZWN0aW9uRHJhZ0Z1bmMob25TZWxlY3Rpb25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmICgoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc1NlbGVjdGFibGUpICYmICFtdWx0aVNlbGVjdGlvbkFjdGl2ZSAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlSW50ZXJuYWxzLmdldChub2RlSWQpPy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNldCBzZWxlY3RlZCBub2RlcyB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZUlkICYmIGlzU2VsZWN0YWJsZSAmJiBzZWxlY3ROb2Rlc09uRHJhZykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZjogbm9kZVJlZixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MuY3VycmVudCA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLmN1cnJlbnQgPSBnZXREcmFnSXRlbXMobm9kZUludGVybmFscywgbm9kZXNEcmFnZ2FibGUsIHBvaW50ZXJQb3MsIG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uU3RhcnQgJiYgZHJhZ0l0ZW1zLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBub2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zOiBkcmFnSXRlbXMuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvblN0YXJ0KGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkcmFnSGFuZGxlciA9IGRyYWcoKVxuICAgICAgICAgICAgICAgICAgICAub24oJ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlRHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50ID0gcG9pbnRlclBvcztcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLmN1cnJlbnQgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVBvc2l0aW9uLmN1cnJlbnQgPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF1dG9QYW5Pbk5vZGVEcmFnLCBub2RlRHJhZ1RocmVzaG9sZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZC5jdXJyZW50ICYmIGRyYWdTdGFydGVkLmN1cnJlbnQgJiYgYXV0b1Bhbk9uTm9kZURyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHBvaW50ZXJQb3MueFNuYXBwZWQgLSAobGFzdFBvcz8uY3VycmVudD8ueCA/PyAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludGVyUG9zLnlTbmFwcGVkIC0gKGxhc3RQb3M/LmN1cnJlbnQ/LnkgPz8gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG5vZGVEcmFnVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGV2ZW50cyB3aXRob3V0IG1vdmVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICgobGFzdFBvcy5jdXJyZW50LnggIT09IHBvaW50ZXJQb3MueFNuYXBwZWQgfHwgbGFzdFBvcy5jdXJyZW50LnkgIT09IHBvaW50ZXJQb3MueVNuYXBwZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50LmN1cnJlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlUG9zaXRpb24uY3VycmVudCA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKHBvaW50ZXJQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvUGFuU3RhcnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXBkYXRlTm9kZVBvc2l0aW9ucywgbm9kZUludGVybmFscywgb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZ1N0b3AgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvblN0b3AgPSBub2RlSWQgPyBvbk5vZGVEcmFnU3RvcCA6IHdyYXBTZWxlY3Rpb25EcmFnRnVuYyhvblNlbGVjdGlvbkRyYWdTdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLmN1cnJlbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25TdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBub2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtczogZHJhZ0l0ZW1zLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdG9wKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICFldmVudC5idXR0b24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghbm9EcmFnQ2xhc3NOYW1lIHx8ICFoYXNTZWxlY3Rvcih0YXJnZXQsIGAuJHtub0RyYWdDbGFzc05hbWV9YCwgbm9kZVJlZikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWhhbmRsZVNlbGVjdG9yIHx8IGhhc1NlbGVjdG9yKHRhcmdldCwgaGFuZGxlU2VsZWN0b3IsIG5vZGVSZWYpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRHJhZ2dhYmxlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5jYWxsKGRyYWdIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgbm9kZVJlZixcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgaGFuZGxlU2VsZWN0b3IsXG4gICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgc3RvcmUsXG4gICAgICAgIG5vZGVJZCxcbiAgICAgICAgc2VsZWN0Tm9kZXNPbkRyYWcsXG4gICAgICAgIGdldFBvaW50ZXJQb3NpdGlvbixcbiAgICBdKTtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG59XG5cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vZGVQb3NpdGlvbnMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IHVzZUNhbGxiYWNrKChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlSW50ZXJuYWxzLCBub2RlRXh0ZW50LCB1cGRhdGVOb2RlUG9zaXRpb25zLCBnZXROb2Rlcywgc25hcFRvR3JpZCwgc25hcEdyaWQsIG9uRXJyb3IsIG5vZGVzRHJhZ2dhYmxlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXMoKS5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQgJiYgKG4uZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbi5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSkpO1xuICAgICAgICAvLyBieSBkZWZhdWx0IGEgbm9kZSBtb3ZlcyA1cHggb24gZWFjaCBrZXkgcHJlc3MsIG9yIDIwcHggaWYgc2hpZnQgaXMgcHJlc3NlZFxuICAgICAgICAvLyBpZiBzbmFwIGdyaWQgaXMgZW5hYmxlZCwgd2UgdXNlIHRoYXQgZm9yIHRoZSB2ZWxvY2l0eS5cbiAgICAgICAgY29uc3QgeFZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMF0gOiA1O1xuICAgICAgICBjb25zdCB5VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSA6IDU7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IHBhcmFtcy5pc1NoaWZ0UHJlc3NlZCA/IDQgOiAxO1xuICAgICAgICBjb25zdCBwb3NpdGlvbkRpZmZYID0gcGFyYW1zLnggKiB4VmVsbyAqIGZhY3RvcjtcbiAgICAgICAgY29uc3QgcG9zaXRpb25EaWZmWSA9IHBhcmFtcy55ICogeVZlbG8gKiBmYWN0b3I7XG4gICAgICAgIGNvbnN0IG5vZGVVcGRhdGVzID0gc2VsZWN0ZWROb2Rlcy5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgIGlmIChuLnBvc2l0aW9uQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB7IHg6IG4ucG9zaXRpb25BYnNvbHV0ZS54ICsgcG9zaXRpb25EaWZmWCwgeTogbi5wb3NpdGlvbkFic29sdXRlLnkgKyBwb3NpdGlvbkRpZmZZIH07XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnggPSBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQobmV4dFBvc2l0aW9uLnggLyBzbmFwR3JpZFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUsIHBvc2l0aW9uIH0gPSBjYWxjTmV4dFBvc2l0aW9uKG4sIG5leHRQb3NpdGlvbiwgbm9kZUludGVybmFscywgbm9kZUV4dGVudCwgdW5kZWZpbmVkLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBuLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgbi5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhub2RlVXBkYXRlcywgdHJ1ZSwgZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXBkYXRlUG9zaXRpb25zO1xufVxuXG5jb25zdCBhcnJvd0tleURpZmZzID0ge1xuICAgIEFycm93VXA6IHsgeDogMCwgeTogLTEgfSxcbiAgICBBcnJvd0Rvd246IHsgeDogMCwgeTogMSB9LFxuICAgIEFycm93TGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICAgIEFycm93UmlnaHQ6IHsgeDogMSwgeTogMCB9LFxufTtcbnZhciB3cmFwTm9kZSA9IChOb2RlQ29tcG9uZW50KSA9PiB7XG4gICAgY29uc3QgTm9kZVdyYXBwZXIgPSAoeyBpZCwgdHlwZSwgZGF0YSwgeFBvcywgeVBvcywgeFBvc09yaWdpbiwgeVBvc09yaWdpbiwgc2VsZWN0ZWQsIG9uQ2xpY2ssIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudSwgb25Eb3VibGVDbGljaywgc3R5bGUsIGNsYXNzTmFtZSwgaXNEcmFnZ2FibGUsIGlzU2VsZWN0YWJsZSwgaXNDb25uZWN0YWJsZSwgaXNGb2N1c2FibGUsIHNlbGVjdE5vZGVzT25EcmFnLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhpZGRlbiwgcmVzaXplT2JzZXJ2ZXIsIGRyYWdIYW5kbGUsIHpJbmRleCwgaXNQYXJlbnQsIG5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGluaXRpYWxpemVkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBhcmlhTGFiZWwsIHJmSWQsIH0pID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgICAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2U291cmNlUG9zaXRpb24gPSB1c2VSZWYoc291cmNlUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwcmV2VGFyZ2V0UG9zaXRpb24gPSB1c2VSZWYodGFyZ2V0UG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwcmV2VHlwZSA9IHVzZVJlZih0eXBlKTtcbiAgICAgICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGlzU2VsZWN0YWJsZSB8fCBpc0RyYWdnYWJsZSB8fCBvbkNsaWNrIHx8IG9uTW91c2VFbnRlciB8fCBvbk1vdXNlTW92ZSB8fCBvbk1vdXNlTGVhdmU7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IHVzZVVwZGF0ZU5vZGVQb3NpdGlvbnMoKTtcbiAgICAgICAgY29uc3Qgb25Nb3VzZUVudGVySGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIGNvbnN0IG9uTW91c2VNb3ZlSGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgY29uc3Qgb25Nb3VzZUxlYXZlSGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIGNvbnN0IG9uQ29udGV4dE1lbnVIYW5kbGVyID0gZ2V0TW91c2VIYW5kbGVyKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Db250ZXh0TWVudSk7XG4gICAgICAgIGNvbnN0IG9uRG91YmxlQ2xpY2tIYW5kbGVyID0gZ2V0TW91c2VIYW5kbGVyKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Eb3VibGVDbGljayk7XG4gICAgICAgIGNvbnN0IG9uU2VsZWN0Tm9kZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RhYmxlICYmICghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzRHJhZ2dhYmxlIHx8IG5vZGVEcmFnVGhyZXNob2xkID4gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhbmRsZXIgZ2V0cyBjYWxsZWQgd2l0aGluIHRoZSBkcmFnIHN0YXJ0IGV2ZW50IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9dHJ1ZVxuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUludGVybmFscy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgLi4ubm9kZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzSW5wdXRET01Ob2RlKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVLZXlib2FyZEExMXkgJiZcbiAgICAgICAgICAgICAgICBpc0RyYWdnYWJsZSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGVkICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZTogYE1vdmVkIHNlbGVjdGVkIG5vZGUgJHtldmVudC5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdBcnJvdycsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9LiBOZXcgcG9zaXRpb24sIHg6ICR7fn54UG9zfSwgeTogJHt+fnlQb3N9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICB4OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLnksXG4gICAgICAgICAgICAgICAgICAgIGlzU2hpZnRQcmVzc2VkOiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgJiYgIWhpZGRlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKGN1cnJOb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gcmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShjdXJyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtoaWRkZW5dKTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSByZS1pbml0aWFsaXplIHRoZSBub2RlXG4gICAgICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IHByZXZUeXBlLmN1cnJlbnQgIT09IHR5cGU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQb3NDaGFuZ2VkID0gcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgIT09IHNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zQ2hhbmdlZCA9IHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ICE9PSB0YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgJiYgKHR5cGVDaGFuZ2VkIHx8IHNvdXJjZVBvc0NoYW5nZWQgfHwgdGFyZ2V0UG9zQ2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlR5cGUuY3VycmVudCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQb3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ID0gc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRQb3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ID0gdGFyZ2V0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkudXBkYXRlTm9kZURpbWVuc2lvbnMoW3sgaWQsIG5vZGVFbGVtZW50OiBub2RlUmVmLmN1cnJlbnQsIGZvcmNlVXBkYXRlOiB0cnVlIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW2lkLCB0eXBlLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb25dKTtcbiAgICAgICAgY29uc3QgZHJhZ2dpbmcgPSB1c2VEcmFnKHtcbiAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICBkaXNhYmxlZDogaGlkZGVuIHx8ICFpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgICAgIGhhbmRsZVNlbGVjdG9yOiBkcmFnSGFuZGxlLFxuICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgICAgIHNlbGVjdE5vZGVzT25EcmFnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX25vZGUnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19ub2RlLSR7dHlwZX1gLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBvdmVyd3JpdGFibGUgYnkgcGFzc2luZyBgbm9wYW5gIGFzIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgICAgICBbbm9QYW5DbGFzc05hbWVdOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogaXNQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgcmVmOiBub2RlUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4UG9zT3JpZ2lufXB4LCR7eVBvc09yaWdpbn1weClgLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGhhc1BvaW50ZXJFdmVudHMgPyAnYWxsJyA6ICdub25lJyxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpbml0aWFsaXplZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgfSwgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fbm9kZS0ke2lkfWAsIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVySGFuZGxlciwgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlSGFuZGxlciwgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmVIYW5kbGVyLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51SGFuZGxlciwgb25DbGljazogb25TZWxlY3ROb2RlSGFuZGxlciwgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGlja0hhbmRsZXIsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGlzRm9jdXNhYmxlID8gJ2J1dHRvbicgOiB1bmRlZmluZWQsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwgeyB2YWx1ZTogaWQgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE5vZGVDb21wb25lbnQsIHsgaWQ6IGlkLCBkYXRhOiBkYXRhLCB0eXBlOiB0eXBlLCB4UG9zOiB4UG9zLCB5UG9zOiB5UG9zLCBzZWxlY3RlZDogc2VsZWN0ZWQsIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRyYWdIYW5kbGU6IGRyYWdIYW5kbGUsIHpJbmRleDogekluZGV4IH0pKSkpO1xuICAgIH07XG4gICAgTm9kZVdyYXBwZXIuZGlzcGxheU5hbWUgPSAnTm9kZVdyYXBwZXInO1xuICAgIHJldHVybiBtZW1vKE5vZGVXcmFwcGVyKTtcbn07XG5cbi8qKlxuICogVGhlIG5vZGVzIHNlbGVjdGlvbiByZWN0YW5nbGUgZ2V0cyBkaXNwbGF5ZWQgd2hlbiBhIHVzZXJcbiAqIG1hZGUgYSBzZWxlY3Rpb24gd2l0aCBvbiBvciBzZXZlcmFsIG5vZGVzXG4gKi9cbmNvbnN0IHNlbGVjdG9yJDcgPSAocykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzLmdldE5vZGVzKCkuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nZXRSZWN0T2ZOb2RlcyhzZWxlY3RlZE5vZGVzLCBzLm5vZGVPcmlnaW4pLFxuICAgICAgICB0cmFuc2Zvcm1TdHJpbmc6IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgfTtcbn07XG5mdW5jdGlvbiBOb2Rlc1NlbGVjdGlvbih7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4OiBsZWZ0LCB5OiB0b3AsIHRyYW5zZm9ybVN0cmluZywgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNywgc2hhbGxvdyk7XG4gICAgY29uc3QgdXBkYXRlUG9zaXRpb25zID0gdXNlVXBkYXRlTm9kZVBvc2l0aW9ucygpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICBub2RlUmVmLmN1cnJlbnQ/LmZvY3VzKHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZUtleWJvYXJkQTExeV0pO1xuICAgIHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgIH0pO1xuICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gb25TZWxlY3Rpb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZXMoKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgb25TZWxlY3Rpb25Db250ZXh0TWVudShldmVudCwgc2VsZWN0ZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgdXBkYXRlUG9zaXRpb25zKHtcbiAgICAgICAgICAgICAgICB4OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueCxcbiAgICAgICAgICAgICAgICB5OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueSxcbiAgICAgICAgICAgICAgICBpc1NoaWZ0UHJlc3NlZDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uJywgJ3JlYWN0LWZsb3dfX2NvbnRhaW5lcicsIG5vUGFuQ2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVN0cmluZyxcbiAgICAgICAgfSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBub2RlUmVmLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24tcmVjdFwiLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51LCB0YWJJbmRleDogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IC0xLCBvbktleURvd246IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiBvbktleURvd24sIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgfSB9KSkpO1xufVxudmFyIE5vZGVzU2VsZWN0aW9uJDEgPSBtZW1vKE5vZGVzU2VsZWN0aW9uKTtcblxuY29uc3Qgc2VsZWN0b3IkNiA9IChzKSA9PiBzLm5vZGVzU2VsZWN0aW9uQWN0aXZlO1xuY29uc3QgRmxvd1JlbmRlcmVyID0gKHsgY2hpbGRyZW4sIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIGRlbGV0ZUtleUNvZGUsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWc6IF9wYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCBwcmV2ZW50U2Nyb2xsaW5nLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkgPT4ge1xuICAgIGNvbnN0IG5vZGVzU2VsZWN0aW9uQWN0aXZlID0gdXNlU3RvcmUoc2VsZWN0b3IkNik7XG4gICAgY29uc3Qgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHNlbGVjdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MocGFuQWN0aXZhdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IHBhbk9uRHJhZyA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PbkRyYWc7XG4gICAgY29uc3QgaXNTZWxlY3RpbmcgPSBzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IChzZWxlY3Rpb25PbkRyYWcgJiYgcGFuT25EcmFnICE9PSB0cnVlKTtcbiAgICB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlIH0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChab29tUGFuZSwgeyBvbk1vdmU6IG9uTW92ZSwgb25Nb3ZlU3RhcnQ6IG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQ6IG9uTW92ZUVuZCwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWc6ICFzZWxlY3Rpb25LZXlQcmVzc2VkICYmIHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFuZSwgeyBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBpc1NlbGVjdGluZzogISFpc1NlbGVjdGluZywgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSB9LFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZSAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChOb2Rlc1NlbGVjdGlvbiQxLCB7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KSkpKSk7XG59O1xuRmxvd1JlbmRlcmVyLmRpc3BsYXlOYW1lID0gJ0Zsb3dSZW5kZXJlcic7XG52YXIgRmxvd1JlbmRlcmVyJDEgPSBtZW1vKEZsb3dSZW5kZXJlcik7XG5cbmZ1bmN0aW9uIHVzZVZpc2libGVOb2Rlcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IG9ubHlSZW5kZXJWaXNpYmxlXG4gICAgICAgID8gZ2V0Tm9kZXNJbnNpZGUocy5ub2RlSW50ZXJuYWxzLCB7IHg6IDAsIHk6IDAsIHdpZHRoOiBzLndpZHRoLCBoZWlnaHQ6IHMuaGVpZ2h0IH0sIHMudHJhbnNmb3JtLCB0cnVlKVxuICAgICAgICA6IHMuZ2V0Tm9kZXMoKSwgW29ubHlSZW5kZXJWaXNpYmxlXSkpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZVR5cGVzKG5vZGVUeXBlcykge1xuICAgIGNvbnN0IHN0YW5kYXJkVHlwZXMgPSB7XG4gICAgICAgIGlucHV0OiB3cmFwTm9kZSgobm9kZVR5cGVzLmlucHV0IHx8IElucHV0Tm9kZSQxKSksXG4gICAgICAgIGRlZmF1bHQ6IHdyYXBOb2RlKChub2RlVHlwZXMuZGVmYXVsdCB8fCBEZWZhdWx0Tm9kZSQxKSksXG4gICAgICAgIG91dHB1dDogd3JhcE5vZGUoKG5vZGVUeXBlcy5vdXRwdXQgfHwgT3V0cHV0Tm9kZSQxKSksXG4gICAgICAgIGdyb3VwOiB3cmFwTm9kZSgobm9kZVR5cGVzLmdyb3VwIHx8IEdyb3VwTm9kZSkpLFxuICAgIH07XG4gICAgY29uc3Qgd3JhcHBlZFR5cGVzID0ge307XG4gICAgY29uc3Qgc3BlY2lhbFR5cGVzID0gT2JqZWN0LmtleXMobm9kZVR5cGVzKVxuICAgICAgICAuZmlsdGVyKChrKSA9PiAhWydpbnB1dCcsICdkZWZhdWx0JywgJ291dHB1dCcsICdncm91cCddLmluY2x1ZGVzKGspKVxuICAgICAgICAucmVkdWNlKChyZXMsIGtleSkgPT4ge1xuICAgICAgICByZXNba2V5XSA9IHdyYXBOb2RlKChub2RlVHlwZXNba2V5XSB8fCBEZWZhdWx0Tm9kZSQxKSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgd3JhcHBlZFR5cGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGFuZGFyZFR5cGVzLFxuICAgICAgICAuLi5zcGVjaWFsVHlwZXMsXG4gICAgfTtcbn1cbmNvbnN0IGdldFBvc2l0aW9uV2l0aE9yaWdpbiA9ICh7IHgsIHksIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgfSkgPT4ge1xuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfVxuICAgIGlmIChvcmlnaW5bMF0gPCAwIHx8IG9yaWdpblsxXSA8IDAgfHwgb3JpZ2luWzBdID4gMSB8fCBvcmlnaW5bMV0gPiAxKSB7XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAtIHdpZHRoICogb3JpZ2luWzBdLFxuICAgICAgICB5OiB5IC0gaGVpZ2h0ICogb3JpZ2luWzFdLFxuICAgIH07XG59O1xuXG5jb25zdCBzZWxlY3RvciQ1ID0gKHMpID0+ICh7XG4gICAgbm9kZXNEcmFnZ2FibGU6IHMubm9kZXNEcmFnZ2FibGUsXG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIG5vZGVzRm9jdXNhYmxlOiBzLm5vZGVzRm9jdXNhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgdXBkYXRlTm9kZURpbWVuc2lvbnM6IHMudXBkYXRlTm9kZURpbWVuc2lvbnMsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5jb25zdCBOb2RlUmVuZGVyZXIgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCB1cGRhdGVOb2RlRGltZW5zaW9ucywgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNSwgc2hhbGxvdyk7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VWaXNpYmxlTm9kZXMocHJvcHMub25seVJlbmRlclZpc2libGVFbGVtZW50cyk7XG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJSZWYgPSB1c2VSZWYoKTtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBlbnRyaWVzLm1hcCgoZW50cnkpID0+ICh7XG4gICAgICAgICAgICAgICAgaWQ6IGVudHJ5LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKSxcbiAgICAgICAgICAgICAgICBub2RlRWxlbWVudDogZW50cnkudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdXBkYXRlTm9kZURpbWVuc2lvbnModXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50ID0gb2JzZXJ2ZXI7XG4gICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyUmVmPy5jdXJyZW50Py5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc1wiLCBzdHlsZTogY29udGFpbmVyU3R5bGUgfSwgbm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgIGxldCBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgICAgIGlmICghcHJvcHMubm9kZVR5cGVzW25vZGVUeXBlXSkge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMyddKG5vZGVUeXBlKSk7XG4gICAgICAgICAgICBub2RlVHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBOb2RlQ29tcG9uZW50ID0gKHByb3BzLm5vZGVUeXBlc1tub2RlVHlwZV0gfHwgcHJvcHMubm9kZVR5cGVzLmRlZmF1bHQpO1xuICAgICAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICEhKG5vZGUuZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbm9kZS5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9ICEhKG5vZGUuc2VsZWN0YWJsZSB8fCAoZWxlbWVudHNTZWxlY3RhYmxlICYmIHR5cGVvZiBub2RlLnNlbGVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSAhIShub2RlLmNvbm5lY3RhYmxlIHx8IChub2Rlc0Nvbm5lY3RhYmxlICYmIHR5cGVvZiBub2RlLmNvbm5lY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgICAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKG5vZGUuZm9jdXNhYmxlIHx8IChub2Rlc0ZvY3VzYWJsZSAmJiB0eXBlb2Ygbm9kZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IHByb3BzLm5vZGVFeHRlbnRcbiAgICAgICAgICAgID8gY2xhbXBQb3NpdGlvbihub2RlLnBvc2l0aW9uQWJzb2x1dGUsIHByb3BzLm5vZGVFeHRlbnQpXG4gICAgICAgICAgICA6IG5vZGUucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgY29uc3QgcG9zWCA9IGNsYW1wZWRQb3NpdGlvbj8ueCA/PyAwO1xuICAgICAgICBjb25zdCBwb3NZID0gY2xhbXBlZFBvc2l0aW9uPy55ID8/IDA7XG4gICAgICAgIGNvbnN0IHBvc09yaWdpbiA9IGdldFBvc2l0aW9uV2l0aE9yaWdpbih7XG4gICAgICAgICAgICB4OiBwb3NYLFxuICAgICAgICAgICAgeTogcG9zWSxcbiAgICAgICAgICAgIHdpZHRoOiBub2RlLndpZHRoID8/IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICBvcmlnaW46IHByb3BzLm5vZGVPcmlnaW4sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm9kZUNvbXBvbmVudCwgeyBrZXk6IG5vZGUuaWQsIGlkOiBub2RlLmlkLCBjbGFzc05hbWU6IG5vZGUuY2xhc3NOYW1lLCBzdHlsZTogbm9kZS5zdHlsZSwgdHlwZTogbm9kZVR5cGUsIGRhdGE6IG5vZGUuZGF0YSwgc291cmNlUG9zaXRpb246IG5vZGUuc291cmNlUG9zaXRpb24gfHwgUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbjogbm9kZS50YXJnZXRQb3NpdGlvbiB8fCBQb3NpdGlvbi5Ub3AsIGhpZGRlbjogbm9kZS5oaWRkZW4sIHhQb3M6IHBvc1gsIHlQb3M6IHBvc1ksIHhQb3NPcmlnaW46IHBvc09yaWdpbi54LCB5UG9zT3JpZ2luOiBwb3NPcmlnaW4ueSwgc2VsZWN0Tm9kZXNPbkRyYWc6IHByb3BzLnNlbGVjdE5vZGVzT25EcmFnLCBvbkNsaWNrOiBwcm9wcy5vbk5vZGVDbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk5vZGVNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogcHJvcHMub25Ob2RlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IHByb3BzLm9uTm9kZU1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnU6IHByb3BzLm9uTm9kZUNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrOiBwcm9wcy5vbk5vZGVEb3VibGVDbGljaywgc2VsZWN0ZWQ6ICEhbm9kZS5zZWxlY3RlZCwgaXNEcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLCBpc1NlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSwgaXNGb2N1c2FibGU6IGlzRm9jdXNhYmxlLCByZXNpemVPYnNlcnZlcjogcmVzaXplT2JzZXJ2ZXIsIGRyYWdIYW5kbGU6IG5vZGUuZHJhZ0hhbmRsZSwgekluZGV4OiBub2RlW2ludGVybmFsc1N5bWJvbF0/LnogPz8gMCwgaXNQYXJlbnQ6ICEhbm9kZVtpbnRlcm5hbHNTeW1ib2xdPy5pc1BhcmVudCwgbm9EcmFnQ2xhc3NOYW1lOiBwcm9wcy5ub0RyYWdDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBwcm9wcy5ub1BhbkNsYXNzTmFtZSwgaW5pdGlhbGl6ZWQ6ICEhbm9kZS53aWR0aCAmJiAhIW5vZGUuaGVpZ2h0LCByZklkOiBwcm9wcy5yZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBwcm9wcy5kaXNhYmxlS2V5Ym9hcmRBMTF5LCBhcmlhTGFiZWw6IG5vZGUuYXJpYUxhYmVsIH0pKTtcbiAgICB9KSkpO1xufTtcbk5vZGVSZW5kZXJlci5kaXNwbGF5TmFtZSA9ICdOb2RlUmVuZGVyZXInO1xudmFyIE5vZGVSZW5kZXJlciQxID0gbWVtbyhOb2RlUmVuZGVyZXIpO1xuXG5jb25zdCBzaGlmdFggPSAoeCwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5MZWZ0KVxuICAgICAgICByZXR1cm4geCAtIHNoaWZ0O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpXG4gICAgICAgIHJldHVybiB4ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHg7XG59O1xuY29uc3Qgc2hpZnRZID0gKHksIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uVG9wKVxuICAgICAgICByZXR1cm4geSAtIHNoaWZ0O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uQm90dG9tKVxuICAgICAgICByZXR1cm4geSArIHNoaWZ0O1xuICAgIHJldHVybiB5O1xufTtcbmNvbnN0IEVkZ2VVcGRhdGVyQ2xhc3NOYW1lID0gJ3JlYWN0LWZsb3dfX2VkZ2V1cGRhdGVyJztcbmNvbnN0IEVkZ2VBbmNob3IgPSAoeyBwb3NpdGlvbiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzID0gMTAsIG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VPdXQsIHR5cGUsIH0pID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgb25Nb3VzZURvd246IG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlciwgb25Nb3VzZU91dDogb25Nb3VzZU91dCwgY2xhc3NOYW1lOiBjYyhbRWRnZVVwZGF0ZXJDbGFzc05hbWUsIGAke0VkZ2VVcGRhdGVyQ2xhc3NOYW1lfS0ke3R5cGV9YF0pLCBjeDogc2hpZnRYKGNlbnRlclgsIHJhZGl1cywgcG9zaXRpb24pLCBjeTogc2hpZnRZKGNlbnRlclksIHJhZGl1cywgcG9zaXRpb24pLCByOiByYWRpdXMsIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLCBmaWxsOiBcInRyYW5zcGFyZW50XCIgfSkpO1xuXG5jb25zdCBhbHdheXNWYWxpZENvbm5lY3Rpb24gPSAoKSA9PiB0cnVlO1xudmFyIHdyYXBFZGdlID0gKEVkZ2VDb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBFZGdlV3JhcHBlciA9ICh7IGlkLCBjbGFzc05hbWUsIHR5cGUsIGRhdGEsIG9uQ2xpY2ssIG9uRWRnZURvdWJsZUNsaWNrLCBzZWxlY3RlZCwgYW5pbWF0ZWQsIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIHNvdXJjZSwgdGFyZ2V0LCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGVsZW1lbnRzU2VsZWN0YWJsZSwgaGlkZGVuLCBzb3VyY2VIYW5kbGVJZCwgdGFyZ2V0SGFuZGxlSWQsIG9uQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgZWRnZVVwZGF0ZXJSYWRpdXMsIG9uRWRnZVVwZGF0ZSwgb25FZGdlVXBkYXRlU3RhcnQsIG9uRWRnZVVwZGF0ZUVuZCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcmZJZCwgYXJpYUxhYmVsLCBpc0ZvY3VzYWJsZSwgaXNVcGRhdGFibGUsIHBhdGhPcHRpb25zLCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgICAgIGNvbnN0IFt1cGRhdGVIb3Zlciwgc2V0VXBkYXRlSG92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICBjb25zdCBbdXBkYXRpbmcsIHNldFVwZGF0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgICAgICBjb25zdCBtYXJrZXJTdGFydFVybCA9IHVzZU1lbW8oKCkgPT4gYHVybCgjJHtnZXRNYXJrZXJJZChtYXJrZXJTdGFydCwgcmZJZCl9KWAsIFttYXJrZXJTdGFydCwgcmZJZF0pO1xuICAgICAgICBjb25zdCBtYXJrZXJFbmRVcmwgPSB1c2VNZW1vKCgpID0+IGB1cmwoIyR7Z2V0TWFya2VySWQobWFya2VyRW5kLCByZklkKX0pYCwgW21hcmtlckVuZCwgcmZJZF0pO1xuICAgICAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkVkZ2VDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgYWRkU2VsZWN0ZWRFZGdlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBlZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBpZCk7XG4gICAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudHNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgbm9kZXM6IFtdLCBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNlbGVjdGVkRWRnZXMoW2lkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCBlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25FZGdlRG91YmxlQ2xpY2tIYW5kbGVyID0gZ2V0TW91c2VIYW5kbGVyJDEoaWQsIHN0b3JlLmdldFN0YXRlLCBvbkVkZ2VEb3VibGVDbGljayk7XG4gICAgICAgIGNvbnN0IG9uRWRnZUNvbnRleHRNZW51ID0gZ2V0TW91c2VIYW5kbGVyJDEoaWQsIHN0b3JlLmdldFN0YXRlLCBvbkNvbnRleHRNZW51KTtcbiAgICAgICAgY29uc3Qgb25FZGdlTW91c2VFbnRlciA9IGdldE1vdXNlSGFuZGxlciQxKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgY29uc3Qgb25FZGdlTW91c2VNb3ZlID0gZ2V0TW91c2VIYW5kbGVyJDEoaWQsIHN0b3JlLmdldFN0YXRlLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgIGNvbnN0IG9uRWRnZU1vdXNlTGVhdmUgPSBnZXRNb3VzZUhhbmRsZXIkMShpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUVkZ2VVcGRhdGVyID0gKGV2ZW50LCBpc1NvdXJjZUhhbmRsZSkgPT4ge1xuICAgICAgICAgICAgLy8gYXZvaWQgdHJpZ2dlcmluZyBlZGdlIHVwZGF0ZXIgaWYgbW91c2UgYnRuIGlzIG5vdCBsZWZ0XG4gICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uU3RvcmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlSWQgPSBpc1NvdXJjZUhhbmRsZSA/IHRhcmdldCA6IHNvdXJjZTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUlkID0gKGlzU291cmNlSGFuZGxlID8gdGFyZ2V0SGFuZGxlSWQgOiBzb3VyY2VIYW5kbGVJZCkgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVR5cGUgPSBpc1NvdXJjZUhhbmRsZSA/ICd0YXJnZXQnIDogJ3NvdXJjZSc7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGlzVmFsaWRDb25uZWN0aW9uU3RvcmUgfHwgYWx3YXlzVmFsaWRDb25uZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgaXNUYXJnZXQgPSBpc1NvdXJjZUhhbmRsZTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBlZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBpZCk7XG4gICAgICAgICAgICBzZXRVcGRhdGluZyh0cnVlKTtcbiAgICAgICAgICAgIG9uRWRnZVVwZGF0ZVN0YXJ0Py4oZXZlbnQsIGVkZ2UsIGhhbmRsZVR5cGUpO1xuICAgICAgICAgICAgY29uc3QgX29uRWRnZVVwZGF0ZUVuZCA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRVcGRhdGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgb25FZGdlVXBkYXRlRW5kPy4oZXZ0LCBlZGdlLCBoYW5kbGVUeXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbkNvbm5lY3RFZGdlID0gKGNvbm5lY3Rpb24pID0+IG9uRWRnZVVwZGF0ZT8uKGVkZ2UsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgaGFuZGxlUG9pbnRlckRvd24oe1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGhhbmRsZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q6IG9uQ29ubmVjdEVkZ2UsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICAgICAgICAgIHNldFN0YXRlOiBzdG9yZS5zZXRTdGF0ZSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBlZGdlVXBkYXRlclR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgICAgICAgICAgb25FZGdlVXBkYXRlRW5kOiBfb25FZGdlVXBkYXRlRW5kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRWRnZVVwZGF0ZXJTb3VyY2VNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB0cnVlKTtcbiAgICAgICAgY29uc3Qgb25FZGdlVXBkYXRlclRhcmdldE1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgY29uc3Qgb25FZGdlVXBkYXRlck1vdXNlRW50ZXIgPSAoKSA9PiBzZXRVcGRhdGVIb3Zlcih0cnVlKTtcbiAgICAgICAgY29uc3Qgb25FZGdlVXBkYXRlck1vdXNlT3V0ID0gKCkgPT4gc2V0VXBkYXRlSG92ZXIoZmFsc2UpO1xuICAgICAgICBjb25zdCBpbmFjdGl2ZSA9ICFlbGVtZW50c1NlbGVjdGFibGUgJiYgIW9uQ2xpY2s7XG4gICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRTZWxlY3Rpb25LZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkgJiYgZWxlbWVudHNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIGFkZFNlbGVjdGVkRWRnZXMsIGVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgICAgICBpZiAodW5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IGVkZ2VzOiBbZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gaWQpXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNlbGVjdGVkRWRnZXMoW2lkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2VkZ2UnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19lZGdlLSR7dHlwZX1gLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7IHNlbGVjdGVkLCBhbmltYXRlZCwgaW5hY3RpdmUsIHVwZGF0aW5nOiB1cGRhdGVIb3ZlciB9LFxuICAgICAgICAgICAgXSksIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbkRvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGlja0hhbmRsZXIsIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25LZXlEb3duOiBpc0ZvY3VzYWJsZSA/IG9uS2V5RG93biA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IHVuZGVmaW5lZCwgcm9sZTogaXNGb2N1c2FibGUgPyAnYnV0dG9uJyA6ICdpbWcnLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fZWRnZS0ke2lkfWAsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwgPT09IG51bGwgPyB1bmRlZmluZWQgOiBhcmlhTGFiZWwgPyBhcmlhTGFiZWwgOiBgRWRnZSBmcm9tICR7c291cmNlfSB0byAke3RhcmdldH1gLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogaXNGb2N1c2FibGUgPyBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gIDogdW5kZWZpbmVkLCByZWY6IGVkZ2VSZWYgfSxcbiAgICAgICAgICAgICF1cGRhdGluZyAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlQ29tcG9uZW50LCB7IGlkOiBpZCwgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCBzZWxlY3RlZDogc2VsZWN0ZWQsIGFuaW1hdGVkOiBhbmltYXRlZCwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIGRhdGE6IGRhdGEsIHN0eWxlOiBzdHlsZSwgc291cmNlWDogc291cmNlWCwgc291cmNlWTogc291cmNlWSwgdGFyZ2V0WDogdGFyZ2V0WCwgdGFyZ2V0WTogdGFyZ2V0WSwgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIHNvdXJjZUhhbmRsZUlkOiBzb3VyY2VIYW5kbGVJZCwgdGFyZ2V0SGFuZGxlSWQ6IHRhcmdldEhhbmRsZUlkLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnRVcmwsIG1hcmtlckVuZDogbWFya2VyRW5kVXJsLCBwYXRoT3B0aW9uczogcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpLFxuICAgICAgICAgICAgaXNVcGRhdGFibGUgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgKGlzVXBkYXRhYmxlID09PSAnc291cmNlJyB8fCBpc1VwZGF0YWJsZSA9PT0gdHJ1ZSkgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGNlbnRlclg6IHNvdXJjZVgsIGNlbnRlclk6IHNvdXJjZVksIHJhZGl1czogZWRnZVVwZGF0ZXJSYWRpdXMsIG9uTW91c2VEb3duOiBvbkVkZ2VVcGRhdGVyU291cmNlTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uRWRnZVVwZGF0ZXJNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbkVkZ2VVcGRhdGVyTW91c2VPdXQsIHR5cGU6IFwic291cmNlXCIgfSkpLFxuICAgICAgICAgICAgICAgIChpc1VwZGF0YWJsZSA9PT0gJ3RhcmdldCcgfHwgaXNVcGRhdGFibGUgPT09IHRydWUpICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBjZW50ZXJYOiB0YXJnZXRYLCBjZW50ZXJZOiB0YXJnZXRZLCByYWRpdXM6IGVkZ2VVcGRhdGVyUmFkaXVzLCBvbk1vdXNlRG93bjogb25FZGdlVXBkYXRlclRhcmdldE1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvbkVkZ2VVcGRhdGVyTW91c2VFbnRlciwgb25Nb3VzZU91dDogb25FZGdlVXBkYXRlck1vdXNlT3V0LCB0eXBlOiBcInRhcmdldFwiIH0pKSkpKSk7XG4gICAgfTtcbiAgICBFZGdlV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdFZGdlV3JhcHBlcic7XG4gICAgcmV0dXJuIG1lbW8oRWRnZVdyYXBwZXIpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlRWRnZVR5cGVzKGVkZ2VUeXBlcykge1xuICAgIGNvbnN0IHN0YW5kYXJkVHlwZXMgPSB7XG4gICAgICAgIGRlZmF1bHQ6IHdyYXBFZGdlKChlZGdlVHlwZXMuZGVmYXVsdCB8fCBCZXppZXJFZGdlKSksXG4gICAgICAgIHN0cmFpZ2h0OiB3cmFwRWRnZSgoZWRnZVR5cGVzLmJlemllciB8fCBTdHJhaWdodEVkZ2UpKSxcbiAgICAgICAgc3RlcDogd3JhcEVkZ2UoKGVkZ2VUeXBlcy5zdGVwIHx8IFN0ZXBFZGdlKSksXG4gICAgICAgIHNtb290aHN0ZXA6IHdyYXBFZGdlKChlZGdlVHlwZXMuc3RlcCB8fCBTbW9vdGhTdGVwRWRnZSkpLFxuICAgICAgICBzaW1wbGViZXppZXI6IHdyYXBFZGdlKChlZGdlVHlwZXMuc2ltcGxlYmV6aWVyIHx8IFNpbXBsZUJlemllckVkZ2UpKSxcbiAgICB9O1xuICAgIGNvbnN0IHdyYXBwZWRUeXBlcyA9IHt9O1xuICAgIGNvbnN0IHNwZWNpYWxUeXBlcyA9IE9iamVjdC5rZXlzKGVkZ2VUeXBlcylcbiAgICAgICAgLmZpbHRlcigoaykgPT4gIVsnZGVmYXVsdCcsICdiZXppZXInXS5pbmNsdWRlcyhrKSlcbiAgICAgICAgLnJlZHVjZSgocmVzLCBrZXkpID0+IHtcbiAgICAgICAgcmVzW2tleV0gPSB3cmFwRWRnZSgoZWRnZVR5cGVzW2tleV0gfHwgQmV6aWVyRWRnZSkpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHdyYXBwZWRUeXBlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhbmRhcmRUeXBlcyxcbiAgICAgICAgLi4uc3BlY2lhbFR5cGVzLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVQb3NpdGlvbihwb3NpdGlvbiwgbm9kZVJlY3QsIGhhbmRsZSA9IG51bGwpIHtcbiAgICBjb25zdCB4ID0gKGhhbmRsZT8ueCB8fCAwKSArIG5vZGVSZWN0Lng7XG4gICAgY29uc3QgeSA9IChoYW5kbGU/LnkgfHwgMCkgKyBub2RlUmVjdC55O1xuICAgIGNvbnN0IHdpZHRoID0gaGFuZGxlPy53aWR0aCB8fCBub2RlUmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBoYW5kbGU/LmhlaWdodCB8fCBub2RlUmVjdC5oZWlnaHQ7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlRvcDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCArIHdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCArIHdpZHRoLFxuICAgICAgICAgICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgeTogeSArIGhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uTGVmdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SGFuZGxlKGJvdW5kcywgaGFuZGxlSWQpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJvdW5kcy5sZW5ndGggPT09IDEgfHwgIWhhbmRsZUlkKSB7XG4gICAgICAgIHJldHVybiBib3VuZHNbMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZUlkKSB7XG4gICAgICAgIHJldHVybiBib3VuZHMuZmluZCgoZCkgPT4gZC5pZCA9PT0gaGFuZGxlSWQpIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgZ2V0RWRnZVBvc2l0aW9ucyA9IChzb3VyY2VOb2RlUmVjdCwgc291cmNlSGFuZGxlLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0Tm9kZVJlY3QsIHRhcmdldEhhbmRsZSwgdGFyZ2V0UG9zaXRpb24pID0+IHtcbiAgICBjb25zdCBzb3VyY2VIYW5kbGVQb3MgPSBnZXRIYW5kbGVQb3NpdGlvbihzb3VyY2VQb3NpdGlvbiwgc291cmNlTm9kZVJlY3QsIHNvdXJjZUhhbmRsZSk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlUG9zID0gZ2V0SGFuZGxlUG9zaXRpb24odGFyZ2V0UG9zaXRpb24sIHRhcmdldE5vZGVSZWN0LCB0YXJnZXRIYW5kbGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZVg6IHNvdXJjZUhhbmRsZVBvcy54LFxuICAgICAgICBzb3VyY2VZOiBzb3VyY2VIYW5kbGVQb3MueSxcbiAgICAgICAgdGFyZ2V0WDogdGFyZ2V0SGFuZGxlUG9zLngsXG4gICAgICAgIHRhcmdldFk6IHRhcmdldEhhbmRsZVBvcy55LFxuICAgIH07XG59O1xuZnVuY3Rpb24gaXNFZGdlVmlzaWJsZSh7IHNvdXJjZVBvcywgdGFyZ2V0UG9zLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm0sIH0pIHtcbiAgICBjb25zdCBlZGdlQm94ID0ge1xuICAgICAgICB4OiBNYXRoLm1pbihzb3VyY2VQb3MueCwgdGFyZ2V0UG9zLngpLFxuICAgICAgICB5OiBNYXRoLm1pbihzb3VyY2VQb3MueSwgdGFyZ2V0UG9zLnkpLFxuICAgICAgICB4MjogTWF0aC5tYXgoc291cmNlUG9zLnggKyBzb3VyY2VXaWR0aCwgdGFyZ2V0UG9zLnggKyB0YXJnZXRXaWR0aCksXG4gICAgICAgIHkyOiBNYXRoLm1heChzb3VyY2VQb3MueSArIHNvdXJjZUhlaWdodCwgdGFyZ2V0UG9zLnkgKyB0YXJnZXRIZWlnaHQpLFxuICAgIH07XG4gICAgaWYgKGVkZ2VCb3gueCA9PT0gZWRnZUJveC54Mikge1xuICAgICAgICBlZGdlQm94LngyICs9IDE7XG4gICAgfVxuICAgIGlmIChlZGdlQm94LnkgPT09IGVkZ2VCb3gueTIpIHtcbiAgICAgICAgZWRnZUJveC55MiArPSAxO1xuICAgIH1cbiAgICBjb25zdCB2aWV3Qm94ID0gcmVjdFRvQm94KHtcbiAgICAgICAgeDogKDAgLSB0cmFuc2Zvcm1bMF0pIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICB5OiAoMCAtIHRyYW5zZm9ybVsxXSkgLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiB3aWR0aCAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyB0cmFuc2Zvcm1bMl0sXG4gICAgfSk7XG4gICAgY29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2aWV3Qm94LngyLCBlZGdlQm94LngyKSAtIE1hdGgubWF4KHZpZXdCb3gueCwgZWRnZUJveC54KSk7XG4gICAgY29uc3QgeU92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2aWV3Qm94LnkyLCBlZGdlQm94LnkyKSAtIE1hdGgubWF4KHZpZXdCb3gueSwgZWRnZUJveC55KSk7XG4gICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gTWF0aC5jZWlsKHhPdmVybGFwICogeU92ZXJsYXApO1xuICAgIHJldHVybiBvdmVybGFwcGluZ0FyZWEgPiAwO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZURhdGEobm9kZSkge1xuICAgIGNvbnN0IGhhbmRsZUJvdW5kcyA9IG5vZGU/LltpbnRlcm5hbHNTeW1ib2xdPy5oYW5kbGVCb3VuZHMgfHwgbnVsbDtcbiAgICBjb25zdCBpc1ZhbGlkID0gaGFuZGxlQm91bmRzICYmXG4gICAgICAgIG5vZGU/LndpZHRoICYmXG4gICAgICAgIG5vZGU/LmhlaWdodCAmJlxuICAgICAgICB0eXBlb2Ygbm9kZT8ucG9zaXRpb25BYnNvbHV0ZT8ueCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIG5vZGU/LnBvc2l0aW9uQWJzb2x1dGU/LnkgIT09ICd1bmRlZmluZWQnO1xuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHg6IG5vZGU/LnBvc2l0aW9uQWJzb2x1dGU/LnggfHwgMCxcbiAgICAgICAgICAgIHk6IG5vZGU/LnBvc2l0aW9uQWJzb2x1dGU/LnkgfHwgMCxcbiAgICAgICAgICAgIHdpZHRoOiBub2RlPy53aWR0aCB8fCAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlPy5oZWlnaHQgfHwgMCxcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlQm91bmRzLFxuICAgICAgICAhIWlzVmFsaWQsXG4gICAgXTtcbn1cblxuY29uc3QgZGVmYXVsdEVkZ2VUcmVlID0gW3sgbGV2ZWw6IDAsIGlzTWF4TGV2ZWw6IHRydWUsIGVkZ2VzOiBbXSB9XTtcbmZ1bmN0aW9uIGdyb3VwRWRnZXNCeVpMZXZlbChlZGdlcywgbm9kZUludGVybmFscywgZWxldmF0ZUVkZ2VzT25TZWxlY3QgPSBmYWxzZSkge1xuICAgIGxldCBtYXhMZXZlbCA9IC0xO1xuICAgIGNvbnN0IGxldmVsTG9va3VwID0gZWRnZXMucmVkdWNlKCh0cmVlLCBlZGdlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc1pJbmRleCA9IGlzTnVtZXJpYyhlZGdlLnpJbmRleCk7XG4gICAgICAgIGxldCB6ID0gaGFzWkluZGV4ID8gZWRnZS56SW5kZXggOiAwO1xuICAgICAgICBpZiAoZWxldmF0ZUVkZ2VzT25TZWxlY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gbm9kZUludGVybmFscy5nZXQoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgICAgY29uc3QgZWRnZU9yQ29ubmVjdGVkTm9kZVNlbGVjdGVkID0gZWRnZS5zZWxlY3RlZCB8fCB0YXJnZXROb2RlPy5zZWxlY3RlZCB8fCBzb3VyY2VOb2RlPy5zZWxlY3RlZDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkWkluZGV4ID0gTWF0aC5tYXgoc291cmNlTm9kZT8uW2ludGVybmFsc1N5bWJvbF0/LnogfHwgMCwgdGFyZ2V0Tm9kZT8uW2ludGVybmFsc1N5bWJvbF0/LnogfHwgMCwgMTAwMCk7XG4gICAgICAgICAgICB6ID0gKGhhc1pJbmRleCA/IGVkZ2UuekluZGV4IDogMCkgKyAoZWRnZU9yQ29ubmVjdGVkTm9kZVNlbGVjdGVkID8gc2VsZWN0ZWRaSW5kZXggOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZVt6XSkge1xuICAgICAgICAgICAgdHJlZVt6XS5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJlZVt6XSA9IFtlZGdlXTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZXZlbCA9IHogPiBtYXhMZXZlbCA/IHogOiBtYXhMZXZlbDtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGVkZ2VUcmVlID0gT2JqZWN0LmVudHJpZXMobGV2ZWxMb29rdXApLm1hcCgoW2tleSwgZWRnZXNdKSA9PiB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gK2tleTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBpc01heExldmVsOiBsZXZlbCA9PT0gbWF4TGV2ZWwsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgaWYgKGVkZ2VUcmVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEVkZ2VUcmVlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZVRyZWU7XG59XG5mdW5jdGlvbiB1c2VWaXNpYmxlRWRnZXMob25seVJlbmRlclZpc2libGUsIG5vZGVJbnRlcm5hbHMsIGVsZXZhdGVFZGdlc09uU2VsZWN0KSB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4ge1xuICAgICAgICBpZiAoIW9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5lZGdlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcy5lZGdlcy5maWx0ZXIoKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChlLnNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gbm9kZUludGVybmFscy5nZXQoZS50YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIChzb3VyY2VOb2RlPy53aWR0aCAmJlxuICAgICAgICAgICAgICAgIHNvdXJjZU5vZGU/LmhlaWdodCAmJlxuICAgICAgICAgICAgICAgIHRhcmdldE5vZGU/LndpZHRoICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZT8uaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgaXNFZGdlVmlzaWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVBvczogc291cmNlTm9kZS5wb3NpdGlvbkFic29sdXRlIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRQb3M6IHRhcmdldE5vZGUucG9zaXRpb25BYnNvbHV0ZSB8fCB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlV2lkdGg6IHNvdXJjZU5vZGUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUhlaWdodDogc291cmNlTm9kZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoOiB0YXJnZXROb2RlLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQ6IHRhcmdldE5vZGUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtvbmx5UmVuZGVyVmlzaWJsZSwgbm9kZUludGVybmFsc10pKTtcbiAgICByZXR1cm4gZ3JvdXBFZGdlc0J5WkxldmVsKGVkZ2VzLCBub2RlSW50ZXJuYWxzLCBlbGV2YXRlRWRnZXNPblNlbGVjdCk7XG59XG5cbmNvbnN0IEFycm93U3ltYm9sID0gKHsgY29sb3IgPSAnbm9uZScsIHN0cm9rZVdpZHRoID0gMSB9KSA9PiB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIGZpbGw6IFwibm9uZVwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDRcIiB9KSk7XG59O1xuY29uc3QgQXJyb3dDbG9zZWRTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgfSwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDQgLTUsLTRcIiB9KSk7XG59O1xuY29uc3QgTWFya2VyU3ltYm9scyA9IHtcbiAgICBbTWFya2VyVHlwZS5BcnJvd106IEFycm93U3ltYm9sLFxuICAgIFtNYXJrZXJUeXBlLkFycm93Q2xvc2VkXTogQXJyb3dDbG9zZWRTeW1ib2wsXG59O1xuZnVuY3Rpb24gdXNlTWFya2VyU3ltYm9sKHR5cGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ltYm9sID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbEV4aXN0cyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNYXJrZXJTeW1ib2xzLCB0eXBlKTtcbiAgICAgICAgaWYgKCFzeW1ib2xFeGlzdHMpIHtcbiAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDknLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwOSddKHR5cGUpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXJrZXJTeW1ib2xzW3R5cGVdO1xuICAgIH0sIFt0eXBlXSk7XG4gICAgcmV0dXJuIHN5bWJvbDtcbn1cblxuY29uc3QgTWFya2VyID0gKHsgaWQsIHR5cGUsIGNvbG9yLCB3aWR0aCA9IDEyLjUsIGhlaWdodCA9IDEyLjUsIG1hcmtlclVuaXRzID0gJ3N0cm9rZVdpZHRoJywgc3Ryb2tlV2lkdGgsIG9yaWVudCA9ICdhdXRvLXN0YXJ0LXJldmVyc2UnLCB9KSA9PiB7XG4gICAgY29uc3QgU3ltYm9sID0gdXNlTWFya2VyU3ltYm9sKHR5cGUpO1xuICAgIGlmICghU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtYXJrZXJcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXJyb3doZWFkXCIsIGlkOiBpZCwgbWFya2VyV2lkdGg6IGAke3dpZHRofWAsIG1hcmtlckhlaWdodDogYCR7aGVpZ2h0fWAsIHZpZXdCb3g6IFwiLTEwIC0xMCAyMCAyMFwiLCBtYXJrZXJVbml0czogbWFya2VyVW5pdHMsIG9yaWVudDogb3JpZW50LCByZWZYOiBcIjBcIiwgcmVmWTogXCIwXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTeW1ib2wsIHsgY29sb3I6IGNvbG9yLCBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggfSkpKTtcbn07XG5jb25zdCBtYXJrZXJTZWxlY3RvciA9ICh7IGRlZmF1bHRDb2xvciwgcmZJZCB9KSA9PiAocykgPT4ge1xuICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgIHJldHVybiBzLmVkZ2VzXG4gICAgICAgIC5yZWR1Y2UoKG1hcmtlcnMsIGVkZ2UpID0+IHtcbiAgICAgICAgW2VkZ2UubWFya2VyU3RhcnQsIGVkZ2UubWFya2VyRW5kXS5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrZXIgJiYgdHlwZW9mIG1hcmtlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJJZCA9IGdldE1hcmtlcklkKG1hcmtlciwgcmZJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZHMuaW5jbHVkZXMobWFya2VySWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7IGlkOiBtYXJrZXJJZCwgY29sb3I6IG1hcmtlci5jb2xvciB8fCBkZWZhdWx0Q29sb3IsIC4uLm1hcmtlciB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2gobWFya2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKTtcbn07XG4vLyB3aGVuIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIGEgcGFnZSBhbmQgeW91IGhpZGUgdGhlIGZpcnN0IG9uZSwgdGhlIG90aGVyIG9uZXMgaGF2ZSBubyBtYXJrZXJzIGFueW1vcmVcbi8vIHdoZW4gdGhleSBkbyBoYXZlIG1hcmtlcnMgd2l0aCB0aGUgc2FtZSBpZHMuIFRvIHByZXZlbnQgdGhpcyB0aGUgdXNlciBjYW4gcGFzcyBhIHVuaXF1ZSBpZCB0byB0aGUgcmVhY3QgZmxvdyB3cmFwcGVyXG4vLyB0aGF0IHdlIGNhbiB0aGVuIHVzZSBmb3IgY3JlYXRpbmcgb3VyIHVuaXF1ZSBtYXJrZXIgaWRzXG5jb25zdCBNYXJrZXJEZWZpbml0aW9ucyA9ICh7IGRlZmF1bHRDb2xvciwgcmZJZCB9KSA9PiB7XG4gICAgY29uc3QgbWFya2VycyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKG1hcmtlclNlbGVjdG9yKHsgZGVmYXVsdENvbG9yLCByZklkIH0pLCBbZGVmYXVsdENvbG9yLCByZklkXSksIFxuICAgIC8vIHRoZSBpZCBpbmNsdWRlcyBhbGwgbWFya2VyIG9wdGlvbnMsIHNvIHdlIGp1c3QgbmVlZCB0byBsb29rIGF0IHRoYXQgcGFydCBvZiB0aGUgbWFya2VyXG4gICAgKGEsIGIpID0+ICEoYS5sZW5ndGggIT09IGIubGVuZ3RoIHx8IGEuc29tZSgobSwgaSkgPT4gbS5pZCAhPT0gYltpXS5pZCkpKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIG1hcmtlcnMubWFwKChtYXJrZXIpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtlciwgeyBpZDogbWFya2VyLmlkLCBrZXk6IG1hcmtlci5pZCwgdHlwZTogbWFya2VyLnR5cGUsIGNvbG9yOiBtYXJrZXIuY29sb3IsIHdpZHRoOiBtYXJrZXIud2lkdGgsIGhlaWdodDogbWFya2VyLmhlaWdodCwgbWFya2VyVW5pdHM6IG1hcmtlci5tYXJrZXJVbml0cywgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCwgb3JpZW50OiBtYXJrZXIub3JpZW50IH0pKSkpKTtcbn07XG5NYXJrZXJEZWZpbml0aW9ucy5kaXNwbGF5TmFtZSA9ICdNYXJrZXJEZWZpbml0aW9ucyc7XG52YXIgTWFya2VyRGVmaW5pdGlvbnMkMSA9IG1lbW8oTWFya2VyRGVmaW5pdGlvbnMpO1xuXG5jb25zdCBzZWxlY3RvciQ0ID0gKHMpID0+ICh7XG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIGVkZ2VzRm9jdXNhYmxlOiBzLmVkZ2VzRm9jdXNhYmxlLFxuICAgIGVkZ2VzVXBkYXRhYmxlOiBzLmVkZ2VzVXBkYXRhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgd2lkdGg6IHMud2lkdGgsXG4gICAgaGVpZ2h0OiBzLmhlaWdodCxcbiAgICBjb25uZWN0aW9uTW9kZTogcy5jb25uZWN0aW9uTW9kZSxcbiAgICBub2RlSW50ZXJuYWxzOiBzLm5vZGVJbnRlcm5hbHMsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5jb25zdCBFZGdlUmVuZGVyZXIgPSAoeyBkZWZhdWx0TWFya2VyQ29sb3IsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIGVsZXZhdGVFZGdlc09uU2VsZWN0LCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIG9uRWRnZUNsaWNrLCBlZGdlVXBkYXRlclJhZGl1cywgb25FZGdlRG91YmxlQ2xpY2ssIG9uRWRnZVVwZGF0ZVN0YXJ0LCBvbkVkZ2VVcGRhdGVFbmQsIGNoaWxkcmVuLCB9KSA9PiB7XG4gICAgY29uc3QgeyBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgd2lkdGgsIGhlaWdodCwgY29ubmVjdGlvbk1vZGUsIG5vZGVJbnRlcm5hbHMsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDQsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVkZ2VUcmVlID0gdXNlVmlzaWJsZUVkZ2VzKG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG5vZGVJbnRlcm5hbHMsIGVsZXZhdGVFZGdlc09uU2VsZWN0KTtcbiAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGVkZ2VUcmVlLm1hcCgoeyBsZXZlbCwgZWRnZXMsIGlzTWF4TGV2ZWwgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBrZXk6IGxldmVsLCBzdHlsZTogeyB6SW5kZXg6IGxldmVsIH0sIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlcyByZWFjdC1mbG93X19jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgaXNNYXhMZXZlbCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtlckRlZmluaXRpb25zJDEsIHsgZGVmYXVsdENvbG9yOiBkZWZhdWx0TWFya2VyQ29sb3IsIHJmSWQ6IHJmSWQgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCBudWxsLCBlZGdlcy5tYXAoKGVkZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc291cmNlTm9kZVJlY3QsIHNvdXJjZUhhbmRsZUJvdW5kcywgc291cmNlSXNWYWxpZF0gPSBnZXROb2RlRGF0YShub2RlSW50ZXJuYWxzLmdldChlZGdlLnNvdXJjZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt0YXJnZXROb2RlUmVjdCwgdGFyZ2V0SGFuZGxlQm91bmRzLCB0YXJnZXRJc1ZhbGlkXSA9IGdldE5vZGVEYXRhKG5vZGVJbnRlcm5hbHMuZ2V0KGVkZ2UudGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VJc1ZhbGlkIHx8ICF0YXJnZXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZWRnZVR5cGUgPSBlZGdlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgIGlmICghZWRnZVR5cGVzW2VkZ2VUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yPy4oJzAxMScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDExJ10oZWRnZVR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IEVkZ2VDb21wb25lbnQgPSBlZGdlVHlwZXNbZWRnZVR5cGVdIHx8IGVkZ2VUeXBlcy5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY29ubmVjdGlvbiB0eXBlIGlzIGxvb3NlIHdlIGNhbiBkZWZpbmUgYWxsIGhhbmRsZXMgYXMgc291cmNlcyBhbmQgY29ubmVjdCBzb3VyY2UgLT4gc291cmNlXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZUhhbmRsZXMgPSBjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICAgICAgICAgID8gdGFyZ2V0SGFuZGxlQm91bmRzLnRhcmdldFxuICAgICAgICAgICAgICAgICAgICA6ICh0YXJnZXRIYW5kbGVCb3VuZHMudGFyZ2V0ID8/IFtdKS5jb25jYXQodGFyZ2V0SGFuZGxlQm91bmRzLnNvdXJjZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlSGFuZGxlID0gZ2V0SGFuZGxlKHNvdXJjZUhhbmRsZUJvdW5kcy5zb3VyY2UsIGVkZ2Uuc291cmNlSGFuZGxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRIYW5kbGUgPSBnZXRIYW5kbGUodGFyZ2V0Tm9kZUhhbmRsZXMsIGVkZ2UudGFyZ2V0SGFuZGxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IHNvdXJjZUhhbmRsZT8ucG9zaXRpb24gfHwgUG9zaXRpb24uQm90dG9tO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gdGFyZ2V0SGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Ub3A7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGb2N1c2FibGUgPSAhIShlZGdlLmZvY3VzYWJsZSB8fCAoZWRnZXNGb2N1c2FibGUgJiYgdHlwZW9mIGVkZ2UuZm9jdXNhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVXBkYXRhYmxlID0gdHlwZW9mIG9uRWRnZVVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgKGVkZ2UudXBkYXRhYmxlIHx8IChlZGdlc1VwZGF0YWJsZSAmJiB0eXBlb2YgZWRnZS51cGRhdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VIYW5kbGUgfHwgIXRhcmdldEhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yPy4oJzAwOCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA4J10oc291cmNlSGFuZGxlLCBlZGdlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSA9IGdldEVkZ2VQb3NpdGlvbnMoc291cmNlTm9kZVJlY3QsIHNvdXJjZUhhbmRsZSwgc291cmNlUG9zaXRpb24sIHRhcmdldE5vZGVSZWN0LCB0YXJnZXRIYW5kbGUsIHRhcmdldFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRnZUNvbXBvbmVudCwgeyBrZXk6IGVkZ2UuaWQsIGlkOiBlZGdlLmlkLCBjbGFzc05hbWU6IGNjKFtlZGdlLmNsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWVdKSwgdHlwZTogZWRnZVR5cGUsIGRhdGE6IGVkZ2UuZGF0YSwgc2VsZWN0ZWQ6ICEhZWRnZS5zZWxlY3RlZCwgYW5pbWF0ZWQ6ICEhZWRnZS5hbmltYXRlZCwgaGlkZGVuOiAhIWVkZ2UuaGlkZGVuLCBsYWJlbDogZWRnZS5sYWJlbCwgbGFiZWxTdHlsZTogZWRnZS5sYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogZWRnZS5sYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBlZGdlLmxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGVkZ2UubGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGVkZ2UubGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IGVkZ2Uuc3R5bGUsIHNvdXJjZTogZWRnZS5zb3VyY2UsIHRhcmdldDogZWRnZS50YXJnZXQsIHNvdXJjZUhhbmRsZUlkOiBlZGdlLnNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlSWQ6IGVkZ2UudGFyZ2V0SGFuZGxlLCBtYXJrZXJFbmQ6IGVkZ2UubWFya2VyRW5kLCBtYXJrZXJTdGFydDogZWRnZS5tYXJrZXJTdGFydCwgc291cmNlWDogc291cmNlWCwgc291cmNlWTogc291cmNlWSwgdGFyZ2V0WDogdGFyZ2V0WCwgdGFyZ2V0WTogdGFyZ2V0WSwgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBvbkVkZ2VVcGRhdGU6IG9uRWRnZVVwZGF0ZSwgb25Db250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbkNsaWNrOiBvbkVkZ2VDbGljaywgZWRnZVVwZGF0ZXJSYWRpdXM6IGVkZ2VVcGRhdGVyUmFkaXVzLCBvbkVkZ2VEb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uRWRnZVVwZGF0ZVN0YXJ0OiBvbkVkZ2VVcGRhdGVTdGFydCwgb25FZGdlVXBkYXRlRW5kOiBvbkVkZ2VVcGRhdGVFbmQsIHJmSWQ6IHJmSWQsIGFyaWFMYWJlbDogZWRnZS5hcmlhTGFiZWwsIGlzRm9jdXNhYmxlOiBpc0ZvY3VzYWJsZSwgaXNVcGRhdGFibGU6IGlzVXBkYXRhYmxlLCBwYXRoT3B0aW9uczogJ3BhdGhPcHRpb25zJyBpbiBlZGdlID8gZWRnZS5wYXRoT3B0aW9ucyA6IHVuZGVmaW5lZCwgaW50ZXJhY3Rpb25XaWR0aDogZWRnZS5pbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICAgICAgICAgIH0pKSkpKSxcbiAgICAgICAgY2hpbGRyZW4pKTtcbn07XG5FZGdlUmVuZGVyZXIuZGlzcGxheU5hbWUgPSAnRWRnZVJlbmRlcmVyJztcbnZhciBFZGdlUmVuZGVyZXIkMSA9IG1lbW8oRWRnZVJlbmRlcmVyKTtcblxuY29uc3Qgc2VsZWN0b3IkMyA9IChzKSA9PiBgdHJhbnNsYXRlKCR7cy50cmFuc2Zvcm1bMF19cHgsJHtzLnRyYW5zZm9ybVsxXX1weCkgc2NhbGUoJHtzLnRyYW5zZm9ybVsyXX0pYDtcbmZ1bmN0aW9uIFZpZXdwb3J0KHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHVzZVN0b3JlKHNlbGVjdG9yJDMpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X192aWV3cG9ydCByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHsgdHJhbnNmb3JtIH0gfSwgY2hpbGRyZW4pKTtcbn1cblxuZnVuY3Rpb24gdXNlT25Jbml0SGFuZGxlcihvbkluaXQpIHtcbiAgICBjb25zdCByZkluc3RhbmNlID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0luaXRpYWxpemVkLmN1cnJlbnQgJiYgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkICYmIG9uSW5pdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvbkluaXQocmZJbnN0YW5jZSksIDEpO1xuICAgICAgICAgICAgaXNJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkluaXQsIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZF0pO1xufVxuXG5jb25zdCBvcHBvc2l0ZVBvc2l0aW9uID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogUG9zaXRpb24uUmlnaHQsXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogUG9zaXRpb24uTGVmdCxcbiAgICBbUG9zaXRpb24uVG9wXTogUG9zaXRpb24uQm90dG9tLFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiBQb3NpdGlvbi5Ub3AsXG59O1xuY29uc3QgQ29ubmVjdGlvbkxpbmUgPSAoeyBub2RlSWQsIGhhbmRsZVR5cGUsIHN0eWxlLCB0eXBlID0gQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllciwgQ3VzdG9tQ29tcG9uZW50LCBjb25uZWN0aW9uU3RhdHVzLCB9KSA9PiB7XG4gICAgY29uc3QgeyBmcm9tTm9kZSwgaGFuZGxlSWQsIHRvWCwgdG9ZLCBjb25uZWN0aW9uTW9kZSB9ID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+ICh7XG4gICAgICAgIGZyb21Ob2RlOiBzLm5vZGVJbnRlcm5hbHMuZ2V0KG5vZGVJZCksXG4gICAgICAgIGhhbmRsZUlkOiBzLmNvbm5lY3Rpb25IYW5kbGVJZCxcbiAgICAgICAgdG9YOiAocy5jb25uZWN0aW9uUG9zaXRpb24ueCAtIHMudHJhbnNmb3JtWzBdKSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB0b1k6IChzLmNvbm5lY3Rpb25Qb3NpdGlvbi55IC0gcy50cmFuc2Zvcm1bMV0pIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIH0pLCBbbm9kZUlkXSksIHNoYWxsb3cpO1xuICAgIGNvbnN0IGZyb21IYW5kbGVCb3VuZHMgPSBmcm9tTm9kZT8uW2ludGVybmFsc1N5bWJvbF0/LmhhbmRsZUJvdW5kcztcbiAgICBsZXQgaGFuZGxlQm91bmRzID0gZnJvbUhhbmRsZUJvdW5kcz8uW2hhbmRsZVR5cGVdO1xuICAgIGlmIChjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuTG9vc2UpIHtcbiAgICAgICAgaGFuZGxlQm91bmRzID0gaGFuZGxlQm91bmRzID8gaGFuZGxlQm91bmRzIDogZnJvbUhhbmRsZUJvdW5kcz8uW2hhbmRsZVR5cGUgPT09ICdzb3VyY2UnID8gJ3RhcmdldCcgOiAnc291cmNlJ107XG4gICAgfVxuICAgIGlmICghZnJvbU5vZGUgfHwgIWhhbmRsZUJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGhhbmRsZUlkID8gaGFuZGxlQm91bmRzLmZpbmQoKGQpID0+IGQuaWQgPT09IGhhbmRsZUlkKSA6IGhhbmRsZUJvdW5kc1swXTtcbiAgICBjb25zdCBmcm9tSGFuZGxlWCA9IGZyb21IYW5kbGUgPyBmcm9tSGFuZGxlLnggKyBmcm9tSGFuZGxlLndpZHRoIC8gMiA6IChmcm9tTm9kZS53aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgZnJvbUhhbmRsZVkgPSBmcm9tSGFuZGxlID8gZnJvbUhhbmRsZS55ICsgZnJvbUhhbmRsZS5oZWlnaHQgLyAyIDogZnJvbU5vZGUuaGVpZ2h0ID8/IDA7XG4gICAgY29uc3QgZnJvbVggPSAoZnJvbU5vZGUucG9zaXRpb25BYnNvbHV0ZT8ueCA/PyAwKSArIGZyb21IYW5kbGVYO1xuICAgIGNvbnN0IGZyb21ZID0gKGZyb21Ob2RlLnBvc2l0aW9uQWJzb2x1dGU/LnkgPz8gMCkgKyBmcm9tSGFuZGxlWTtcbiAgICBjb25zdCBmcm9tUG9zaXRpb24gPSBmcm9tSGFuZGxlPy5wb3NpdGlvbjtcbiAgICBjb25zdCB0b1Bvc2l0aW9uID0gZnJvbVBvc2l0aW9uID8gb3Bwb3NpdGVQb3NpdGlvbltmcm9tUG9zaXRpb25dIDogbnVsbDtcbiAgICBpZiAoIWZyb21Qb3NpdGlvbiB8fCAhdG9Qb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKEN1c3RvbUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tQ29tcG9uZW50LCB7IGNvbm5lY3Rpb25MaW5lVHlwZTogdHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZTogc3R5bGUsIGZyb21Ob2RlOiBmcm9tTm9kZSwgZnJvbUhhbmRsZTogZnJvbUhhbmRsZSwgZnJvbVg6IGZyb21YLCBmcm9tWTogZnJvbVksIHRvWDogdG9YLCB0b1k6IHRvWSwgZnJvbVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sIHRvUG9zaXRpb246IHRvUG9zaXRpb24sIGNvbm5lY3Rpb25TdGF0dXM6IGNvbm5lY3Rpb25TdGF0dXMgfSkpO1xuICAgIH1cbiAgICBsZXQgZEF0dHIgPSAnJztcbiAgICBjb25zdCBwYXRoUGFyYW1zID0ge1xuICAgICAgICBzb3VyY2VYOiBmcm9tWCxcbiAgICAgICAgc291cmNlWTogZnJvbVksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFg6IHRvWCxcbiAgICAgICAgdGFyZ2V0WTogdG9ZLFxuICAgICAgICB0YXJnZXRQb3NpdGlvbjogdG9Qb3NpdGlvbixcbiAgICB9O1xuICAgIGlmICh0eXBlID09PSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyKSB7XG4gICAgICAgIC8vIHdlIGFzc3VtZSB0aGUgZGVzdGluYXRpb24gcG9zaXRpb24gaXMgb3Bwb3NpdGUgdG8gdGhlIHNvdXJjZSBwb3NpdGlvblxuICAgICAgICBbZEF0dHJdID0gZ2V0QmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gQ29ubmVjdGlvbkxpbmVUeXBlLlN0ZXApIHtcbiAgICAgICAgW2RBdHRyXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgIC4uLnBhdGhQYXJhbXMsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBDb25uZWN0aW9uTGluZVR5cGUuU21vb3RoU3RlcCkge1xuICAgICAgICBbZEF0dHJdID0gZ2V0U21vb3RoU3RlcFBhdGgocGF0aFBhcmFtcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IENvbm5lY3Rpb25MaW5lVHlwZS5TaW1wbGVCZXppZXIpIHtcbiAgICAgICAgW2RBdHRyXSA9IGdldFNpbXBsZUJlemllclBhdGgocGF0aFBhcmFtcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkQXR0ciA9IGBNJHtmcm9tWH0sJHtmcm9tWX0gJHt0b1h9LCR7dG9ZfWA7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IGRBdHRyLCBmaWxsOiBcIm5vbmVcIiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb24tcGF0aFwiLCBzdHlsZTogc3R5bGUgfSk7XG59O1xuQ29ubmVjdGlvbkxpbmUuZGlzcGxheU5hbWUgPSAnQ29ubmVjdGlvbkxpbmUnO1xuY29uc3Qgc2VsZWN0b3IkMiA9IChzKSA9PiAoe1xuICAgIG5vZGVJZDogcy5jb25uZWN0aW9uTm9kZUlkLFxuICAgIGhhbmRsZVR5cGU6IHMuY29ubmVjdGlvbkhhbmRsZVR5cGUsXG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25TdGF0dXM6IHMuY29ubmVjdGlvblN0YXR1cyxcbiAgICB3aWR0aDogcy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxufSk7XG5mdW5jdGlvbiBDb25uZWN0aW9uTGluZVdyYXBwZXIoeyBjb250YWluZXJTdHlsZSwgc3R5bGUsIHR5cGUsIGNvbXBvbmVudCB9KSB7XG4gICAgY29uc3QgeyBub2RlSWQsIGhhbmRsZVR5cGUsIG5vZGVzQ29ubmVjdGFibGUsIHdpZHRoLCBoZWlnaHQsIGNvbm5lY3Rpb25TdGF0dXMgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSAhIShub2RlSWQgJiYgaGFuZGxlVHlwZSAmJiB3aWR0aCAmJiBub2Rlc0Nvbm5lY3RhYmxlKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHN0eWxlOiBjb250YWluZXJTdHlsZSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2VzIHJlYWN0LWZsb3dfX2Nvbm5lY3Rpb25saW5lIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2Nvbm5lY3Rpb24nLCBjb25uZWN0aW9uU3RhdHVzXSkgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGlvbkxpbmUsIHsgbm9kZUlkOiBub2RlSWQsIGhhbmRsZVR5cGU6IGhhbmRsZVR5cGUsIHN0eWxlOiBzdHlsZSwgdHlwZTogdHlwZSwgQ3VzdG9tQ29tcG9uZW50OiBjb21wb25lbnQsIGNvbm5lY3Rpb25TdGF0dXM6IGNvbm5lY3Rpb25TdGF0dXMgfSkpKSk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB1c2VOb2RlT3JFZGdlVHlwZXMobm9kZU9yRWRnZVR5cGVzLCBjcmVhdGVUeXBlcykge1xuICAgIGNvbnN0IHR5cGVzS2V5c1JlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgdHlwZXNQYXJzZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlS2V5cyA9IE9iamVjdC5rZXlzKG5vZGVPckVkZ2VUeXBlcyk7XG4gICAgICAgICAgICBpZiAoc2hhbGxvdyh0eXBlc0tleXNSZWYuY3VycmVudCwgdHlwZUtleXMpKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAyJ10oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlc0tleXNSZWYuY3VycmVudCA9IHR5cGVLZXlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVUeXBlcyhub2RlT3JFZGdlVHlwZXMpO1xuICAgIH0sIFtub2RlT3JFZGdlVHlwZXNdKTtcbiAgICByZXR1cm4gdHlwZXNQYXJzZWQ7XG59XG5cbmNvbnN0IEdyYXBoVmlldyA9ICh7IG5vZGVUeXBlcywgZWRnZVR5cGVzLCBvbk1vdmUsIG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQsIG9uSW5pdCwgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljaywgb25FZGdlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZGVsZXRlS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZWxlbWVudHNTZWxlY3RhYmxlLCBzZWxlY3ROb2Rlc09uRHJhZywgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIGRlZmF1bHRNYXJrZXJDb2xvciwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZywgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudSwgb25FZGdlVXBkYXRlLCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCBlZGdlVXBkYXRlclJhZGl1cywgb25FZGdlVXBkYXRlU3RhcnQsIG9uRWRnZVVwZGF0ZUVuZCwgbm9EcmFnQ2xhc3NOYW1lLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZWxldmF0ZUVkZ2VzT25TZWxlY3QsIGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHJmSWQsIH0pID0+IHtcbiAgICBjb25zdCBub2RlVHlwZXNXcmFwcGVkID0gdXNlTm9kZU9yRWRnZVR5cGVzKG5vZGVUeXBlcywgY3JlYXRlTm9kZVR5cGVzKTtcbiAgICBjb25zdCBlZGdlVHlwZXNXcmFwcGVkID0gdXNlTm9kZU9yRWRnZVR5cGVzKGVkZ2VUeXBlcywgY3JlYXRlRWRnZVR5cGVzKTtcbiAgICB1c2VPbkluaXRIYW5kbGVyKG9uSW5pdCk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEZsb3dSZW5kZXJlciQxLCB7IG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgb25Nb3ZlOiBvbk1vdmUsIG9uTW92ZVN0YXJ0OiBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kOiBvbk1vdmVFbmQsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFZpZXdwb3J0LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlUmVuZGVyZXIkMSwgeyBlZGdlVHlwZXM6IGVkZ2VUeXBlc1dyYXBwZWQsIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VVcGRhdGU6IG9uRWRnZVVwZGF0ZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgb25FZGdlQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlVXBkYXRlU3RhcnQ6IG9uRWRnZVVwZGF0ZVN0YXJ0LCBvbkVkZ2VVcGRhdGVFbmQ6IG9uRWRnZVVwZGF0ZUVuZCwgZWRnZVVwZGF0ZXJSYWRpdXM6IGVkZ2VVcGRhdGVyUmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBlbGV2YXRlRWRnZXNPblNlbGVjdDogISFlbGV2YXRlRWRnZXNPblNlbGVjdCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZDogcmZJZCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGlvbkxpbmVXcmFwcGVyLCB7IHN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCB0eXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbnRhaW5lclN0eWxlOiBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlIH0pKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyXCIgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE5vZGVSZW5kZXJlciQxLCB7IG5vZGVUeXBlczogbm9kZVR5cGVzV3JhcHBlZCwgb25Ob2RlQ2xpY2s6IG9uTm9kZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXI6IG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZTogb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlOiBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudTogb25Ob2RlQ29udGV4dE1lbnUsIHNlbGVjdE5vZGVzT25EcmFnOiBzZWxlY3ROb2Rlc09uRHJhZywgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgcmZJZDogcmZJZCB9KSkpKTtcbn07XG5HcmFwaFZpZXcuZGlzcGxheU5hbWUgPSAnR3JhcGhWaWV3JztcbnZhciBHcmFwaFZpZXckMSA9IG1lbW8oR3JhcGhWaWV3KTtcblxuY29uc3QgaW5maW5pdGVFeHRlbnQgPSBbXG4gICAgW051bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXSxcbiAgICBbTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLFxuXTtcbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICByZklkOiAnMScsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIHRyYW5zZm9ybTogWzAsIDAsIDFdLFxuICAgIG5vZGVJbnRlcm5hbHM6IG5ldyBNYXAoKSxcbiAgICBlZGdlczogW10sXG4gICAgb25Ob2Rlc0NoYW5nZTogbnVsbCxcbiAgICBvbkVkZ2VzQ2hhbmdlOiBudWxsLFxuICAgIGhhc0RlZmF1bHROb2RlczogZmFsc2UsXG4gICAgaGFzRGVmYXVsdEVkZ2VzOiBmYWxzZSxcbiAgICBkM1pvb206IG51bGwsXG4gICAgZDNTZWxlY3Rpb246IG51bGwsXG4gICAgZDNab29tSGFuZGxlcjogdW5kZWZpbmVkLFxuICAgIG1pblpvb206IDAuNSxcbiAgICBtYXhab29tOiAyLFxuICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgbm9kZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBudWxsLFxuICAgIGNvbm5lY3Rpb25Ob2RlSWQ6IG51bGwsXG4gICAgY29ubmVjdGlvbkhhbmRsZUlkOiBudWxsLFxuICAgIGNvbm5lY3Rpb25IYW5kbGVUeXBlOiAnc291cmNlJyxcbiAgICBjb25uZWN0aW9uUG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICAgIGNvbm5lY3Rpb25TdGF0dXM6IG51bGwsXG4gICAgY29ubmVjdGlvbk1vZGU6IENvbm5lY3Rpb25Nb2RlLlN0cmljdCxcbiAgICBkb21Ob2RlOiBudWxsLFxuICAgIHBhbmVEcmFnZ2luZzogZmFsc2UsXG4gICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgbm9kZU9yaWdpbjogWzAsIDBdLFxuICAgIG5vZGVEcmFnVGhyZXNob2xkOiAwLFxuICAgIHNuYXBHcmlkOiBbMTUsIDE1XSxcbiAgICBzbmFwVG9HcmlkOiBmYWxzZSxcbiAgICBub2Rlc0RyYWdnYWJsZTogdHJ1ZSxcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiB0cnVlLFxuICAgIG5vZGVzRm9jdXNhYmxlOiB0cnVlLFxuICAgIGVkZ2VzRm9jdXNhYmxlOiB0cnVlLFxuICAgIGVkZ2VzVXBkYXRhYmxlOiB0cnVlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogdHJ1ZSxcbiAgICBmaXRWaWV3T25Jbml0OiBmYWxzZSxcbiAgICBmaXRWaWV3T25Jbml0RG9uZTogZmFsc2UsXG4gICAgZml0Vmlld09uSW5pdE9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgICBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgY29ubmVjdGlvblN0YXJ0SGFuZGxlOiBudWxsLFxuICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IG51bGwsXG4gICAgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwsXG4gICAgY29ubmVjdE9uQ2xpY2s6IHRydWUsXG4gICAgYXJpYUxpdmVNZXNzYWdlOiAnJyxcbiAgICBhdXRvUGFuT25Db25uZWN0OiB0cnVlLFxuICAgIGF1dG9QYW5Pbk5vZGVEcmFnOiB0cnVlLFxuICAgIGNvbm5lY3Rpb25SYWRpdXM6IDIwLFxuICAgIG9uRXJyb3I6IGRldldhcm4sXG4gICAgaXNWYWxpZENvbm5lY3Rpb246IHVuZGVmaW5lZCxcbn07XG5cbmNvbnN0IGNyZWF0ZVJGU3RvcmUgPSAoKSA9PiBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+ICh7XG4gICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgIHNldE5vZGVzOiAobm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlSW50ZXJuYWxzLCBub2RlT3JpZ2luLCBlbGV2YXRlTm9kZXNPblNlbGVjdCB9ID0gZ2V0KCk7XG4gICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IGNyZWF0ZU5vZGVJbnRlcm5hbHMobm9kZXMsIG5vZGVJbnRlcm5hbHMsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0KSB9KTtcbiAgICB9LFxuICAgIGdldE5vZGVzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGdldCgpLm5vZGVJbnRlcm5hbHMudmFsdWVzKCkpO1xuICAgIH0sXG4gICAgc2V0RWRnZXM6IChlZGdlcykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHt9IH0gPSBnZXQoKTtcbiAgICAgICAgc2V0KHsgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLCAuLi5lIH0pKSB9KTtcbiAgICB9LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHROb2RlcyA9IHR5cGVvZiBub2RlcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHRFZGdlcyA9IHR5cGVvZiBlZGdlcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IG5vZGVJbnRlcm5hbHMgPSBoYXNEZWZhdWx0Tm9kZXNcbiAgICAgICAgICAgID8gY3JlYXRlTm9kZUludGVybmFscyhub2RlcywgbmV3IE1hcCgpLCBnZXQoKS5ub2RlT3JpZ2luLCBnZXQoKS5lbGV2YXRlTm9kZXNPblNlbGVjdClcbiAgICAgICAgICAgIDogbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBuZXh0RWRnZXMgPSBoYXNEZWZhdWx0RWRnZXMgPyBlZGdlcyA6IFtdO1xuICAgICAgICBzZXQoeyBub2RlSW50ZXJuYWxzLCBlZGdlczogbmV4dEVkZ2VzLCBoYXNEZWZhdWx0Tm9kZXMsIGhhc0RlZmF1bHRFZGdlcyB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZU5vZGVEaW1lbnNpb25zOiAodXBkYXRlcykgPT4ge1xuICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2UsIG5vZGVJbnRlcm5hbHMsIGZpdFZpZXdPbkluaXQsIGZpdFZpZXdPbkluaXREb25lLCBmaXRWaWV3T25Jbml0T3B0aW9ucywgZG9tTm9kZSwgbm9kZU9yaWdpbiwgfSA9IGdldCgpO1xuICAgICAgICBjb25zdCB2aWV3cG9ydE5vZGUgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fdmlld3BvcnQnKTtcbiAgICAgICAgaWYgKCF2aWV3cG9ydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXdwb3J0Tm9kZSk7XG4gICAgICAgIGNvbnN0IHsgbTIyOiB6b29tIH0gPSBuZXcgd2luZG93LkRPTU1hdHJpeFJlYWRPbmx5KHN0eWxlLnRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB1cGRhdGVzLnJlZHVjZSgocmVzLCB1cGRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldCh1cGRhdGUuaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyh1cGRhdGUubm9kZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvVXBkYXRlID0gISEoZGltZW5zaW9ucy53aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICAobm9kZS53aWR0aCAhPT0gZGltZW5zaW9ucy53aWR0aCB8fCBub2RlLmhlaWdodCAhPT0gZGltZW5zaW9ucy5oZWlnaHQgfHwgdXBkYXRlLmZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbaW50ZXJuYWxzU3ltYm9sXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5vZGVbaW50ZXJuYWxzU3ltYm9sXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBnZXRIYW5kbGVCb3VuZHMoJy5zb3VyY2UnLCB1cGRhdGUubm9kZUVsZW1lbnQsIHpvb20sIG5vZGVPcmlnaW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGdldEhhbmRsZUJvdW5kcygnLnRhcmdldCcsIHVwZGF0ZS5ub2RlRWxlbWVudCwgem9vbSwgbm9kZU9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHVwZGF0ZUFic29sdXRlTm9kZVBvc2l0aW9ucyhub2RlSW50ZXJuYWxzLCBub2RlT3JpZ2luKTtcbiAgICAgICAgY29uc3QgbmV4dEZpdFZpZXdPbkluaXREb25lID0gZml0Vmlld09uSW5pdERvbmUgfHxcbiAgICAgICAgICAgIChmaXRWaWV3T25Jbml0ICYmICFmaXRWaWV3T25Jbml0RG9uZSAmJiBmaXRWaWV3KGdldCwgeyBpbml0aWFsOiB0cnVlLCAuLi5maXRWaWV3T25Jbml0T3B0aW9ucyB9KSk7XG4gICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IG5ldyBNYXAobm9kZUludGVybmFscyksIGZpdFZpZXdPbkluaXREb25lOiBuZXh0Rml0Vmlld09uSW5pdERvbmUgfSk7XG4gICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBwb3NpdGlvbkNoYW5nZWQgPSB0cnVlLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5vZGVEcmFnSXRlbXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnBvc2l0aW9uQWJzb2x1dGUgPSBub2RlLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfSxcbiAgICB0cmlnZ2VyTm9kZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25Ob2Rlc0NoYW5nZSwgbm9kZUludGVybmFscywgaGFzRGVmYXVsdE5vZGVzLCBub2RlT3JpZ2luLCBnZXROb2RlcywgZWxldmF0ZU5vZGVzT25TZWxlY3QgfSA9IGdldCgpO1xuICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIGdldE5vZGVzKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlSW50ZXJuYWxzID0gY3JlYXRlTm9kZUludGVybmFscyhub2Rlcywgbm9kZUludGVybmFscywgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QpO1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IG5leHROb2RlSW50ZXJuYWxzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZE5vZGVzOiAoc2VsZWN0ZWROb2RlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGxldCBjaGFuZ2VkTm9kZXM7XG4gICAgICAgIGxldCBjaGFuZ2VkRWRnZXMgPSBudWxsO1xuICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyA9IHNlbGVjdGVkTm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG5vZGVJZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlZE5vZGVzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhnZXROb2RlcygpLCBzZWxlY3RlZE5vZGVJZHMpO1xuICAgICAgICAgICAgY2hhbmdlZEVkZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlcywgW10pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGxldCBjaGFuZ2VkRWRnZXM7XG4gICAgICAgIGxldCBjaGFuZ2VkTm9kZXMgPSBudWxsO1xuICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyA9IHNlbGVjdGVkRWRnZUlkcy5tYXAoKGVkZ2VJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VJZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlZEVkZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlcywgc2VsZWN0ZWRFZGdlSWRzKTtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZ2V0Tm9kZXMoKSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXM6ICh7IG5vZGVzLCBlZGdlcyB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgeyBlZGdlczogc3RvcmVFZGdlcywgZ2V0Tm9kZXMgfSA9IGdldCgpO1xuICAgICAgICBjb25zdCBub2Rlc1RvVW5zZWxlY3QgPSBub2RlcyA/IG5vZGVzIDogZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXMgPyBlZGdlcyA6IHN0b3JlRWRnZXM7XG4gICAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IG5vZGVzVG9VbnNlbGVjdC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgIG4uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobi5pZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhbmdlZEVkZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRNaW5ab29tOiAobWluWm9vbSkgPT4ge1xuICAgICAgICBjb25zdCB7IGQzWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgIGQzWm9vbT8uc2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKTtcbiAgICAgICAgc2V0KHsgbWluWm9vbSB9KTtcbiAgICB9LFxuICAgIHNldE1heFpvb206IChtYXhab29tKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZDNab29tLCBtaW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgZDNab29tPy5zY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICBzZXQoeyBtYXhab29tIH0pO1xuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlRXh0ZW50OiAodHJhbnNsYXRlRXh0ZW50KSA9PiB7XG4gICAgICAgIGdldCgpLmQzWm9vbT8udHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIHNldCh7IHRyYW5zbGF0ZUV4dGVudCB9KTtcbiAgICB9LFxuICAgIHJlc2V0U2VsZWN0ZWRFbGVtZW50czogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1Vuc2VsZWN0ID0gbm9kZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IGUuc2VsZWN0ZWQpXG4gICAgICAgICAgICAubWFwKChuKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobi5pZCwgZmFsc2UpKTtcbiAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IGUuc2VsZWN0ZWQpXG4gICAgICAgICAgICAubWFwKChlKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZS5pZCwgZmFsc2UpKTtcbiAgICAgICAgdXBkYXRlTm9kZXNBbmRFZGdlc1NlbGVjdGlvbnMoe1xuICAgICAgICAgICAgY2hhbmdlZE5vZGVzOiBub2Rlc1RvVW5zZWxlY3QsXG4gICAgICAgICAgICBjaGFuZ2VkRWRnZXM6IGVkZ2VzVG9VbnNlbGVjdCxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXROb2RlRXh0ZW50OiAobm9kZUV4dGVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVJbnRlcm5hbHMgfSA9IGdldCgpO1xuICAgICAgICBub2RlSW50ZXJuYWxzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb24obm9kZS5wb3NpdGlvbiwgbm9kZUV4dGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXQoe1xuICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgIG5vZGVJbnRlcm5hbHM6IG5ldyBNYXAobm9kZUludGVybmFscyksXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgZDNab29tLCBkM1NlbGVjdGlvbiwgdHJhbnNsYXRlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKCFkM1pvb20gfHwgIWQzU2VsZWN0aW9uIHx8ICghZGVsdGEueCAmJiAhZGVsdGEueSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gem9vbUlkZW50aXR5XG4gICAgICAgICAgICAudHJhbnNsYXRlKHRyYW5zZm9ybVswXSArIGRlbHRhLngsIHRyYW5zZm9ybVsxXSArIGRlbHRhLnkpXG4gICAgICAgICAgICAuc2NhbGUodHJhbnNmb3JtWzJdKTtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gW1xuICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjb25zdHJhaW5lZFRyYW5zZm9ybSA9IGQzWm9vbT8uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICBkM1pvb20udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBjb25zdHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUNoYW5nZWQgPSB0cmFuc2Zvcm1bMF0gIT09IGNvbnN0cmFpbmVkVHJhbnNmb3JtLnggfHxcbiAgICAgICAgICAgIHRyYW5zZm9ybVsxXSAhPT0gY29uc3RyYWluZWRUcmFuc2Zvcm0ueSB8fFxuICAgICAgICAgICAgdHJhbnNmb3JtWzJdICE9PSBjb25zdHJhaW5lZFRyYW5zZm9ybS5rO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2hhbmdlZDtcbiAgICB9LFxuICAgIGNhbmNlbENvbm5lY3Rpb246ICgpID0+IHNldCh7XG4gICAgICAgIGNvbm5lY3Rpb25Ob2RlSWQ6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uTm9kZUlkLFxuICAgICAgICBjb25uZWN0aW9uSGFuZGxlSWQ6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uSGFuZGxlSWQsXG4gICAgICAgIGNvbm5lY3Rpb25IYW5kbGVUeXBlOiBpbml0aWFsU3RhdGUuY29ubmVjdGlvbkhhbmRsZVR5cGUsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uU3RhdHVzLFxuICAgICAgICBjb25uZWN0aW9uU3RhcnRIYW5kbGU6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uU3RhcnRIYW5kbGUsXG4gICAgICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uRW5kSGFuZGxlLFxuICAgIH0pLFxuICAgIHJlc2V0OiAoKSA9PiBzZXQoeyAuLi5pbml0aWFsU3RhdGUgfSksXG59KSwgT2JqZWN0LmlzKTtcblxuY29uc3QgUmVhY3RGbG93UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgY29uc3Qgc3RvcmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgaWYgKCFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVSRlN0b3JlKCk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlUmVmLmN1cnJlbnQgfSwgY2hpbGRyZW4pO1xufTtcblJlYWN0Rmxvd1Byb3ZpZGVyLmRpc3BsYXlOYW1lID0gJ1JlYWN0Rmxvd1Byb3ZpZGVyJztcblxuY29uc3QgV3JhcHBlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBpc1dyYXBwZWQgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKGlzV3JhcHBlZCkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgaXQgd2l0aCBhIGZyYWdtZW50IGJlY2F1c2UgaXQncyBub3QgYWxsb3dlZCBmb3IgY2hpbGRyZW4gdG8gYmUgYSBSZWFjdE5vZGVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvaXNzdWVzLzE4MDUxXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Rmxvd1Byb3ZpZGVyLCBudWxsLCBjaGlsZHJlbik7XG59O1xuV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdSZWFjdEZsb3dXcmFwcGVyJztcblxuY29uc3QgZGVmYXVsdE5vZGVUeXBlcyA9IHtcbiAgICBpbnB1dDogSW5wdXROb2RlJDEsXG4gICAgZGVmYXVsdDogRGVmYXVsdE5vZGUkMSxcbiAgICBvdXRwdXQ6IE91dHB1dE5vZGUkMSxcbiAgICBncm91cDogR3JvdXBOb2RlLFxufTtcbmNvbnN0IGRlZmF1bHRFZGdlVHlwZXMgPSB7XG4gICAgZGVmYXVsdDogQmV6aWVyRWRnZSxcbiAgICBzdHJhaWdodDogU3RyYWlnaHRFZGdlLFxuICAgIHN0ZXA6IFN0ZXBFZGdlLFxuICAgIHNtb290aHN0ZXA6IFNtb290aFN0ZXBFZGdlLFxuICAgIHNpbXBsZWJlemllcjogU2ltcGxlQmV6aWVyRWRnZSxcbn07XG5jb25zdCBpbml0Tm9kZU9yaWdpbiA9IFswLCAwXTtcbmNvbnN0IGluaXRTbmFwR3JpZCA9IFsxNSwgMTVdO1xuY29uc3QgaW5pdERlZmF1bHRWaWV3cG9ydCA9IHsgeDogMCwgeTogMCwgem9vbTogMSB9O1xuY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHpJbmRleDogMCxcbn07XG5jb25zdCBSZWFjdEZsb3cgPSBmb3J3YXJkUmVmKCh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGNsYXNzTmFtZSwgbm9kZVR5cGVzID0gZGVmYXVsdE5vZGVUeXBlcywgZWRnZVR5cGVzID0gZGVmYXVsdEVkZ2VUeXBlcywgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbkluaXQsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3AsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIG9uU2VsZWN0aW9uQ2hhbmdlLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgY29ubmVjdGlvbk1vZGUgPSBDb25uZWN0aW9uTW9kZS5TdHJpY3QsIGNvbm5lY3Rpb25MaW5lVHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBkZWxldGVLZXlDb2RlID0gJ0JhY2tzcGFjZScsIHNlbGVjdGlvbktleUNvZGUgPSAnU2hpZnQnLCBzZWxlY3Rpb25PbkRyYWcgPSBmYWxzZSwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuQWN0aXZhdGlvbktleUNvZGUgPSAnU3BhY2UnLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgc25hcFRvR3JpZCA9IGZhbHNlLCBzbmFwR3JpZCA9IGluaXRTbmFwR3JpZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50cyA9IGZhbHNlLCBzZWxlY3ROb2Rlc09uRHJhZyA9IHRydWUsIG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgbm9kZU9yaWdpbiA9IGluaXROb2RlT3JpZ2luLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZGVmYXVsdFZpZXdwb3J0ID0gaW5pdERlZmF1bHRWaWV3cG9ydCwgbWluWm9vbSA9IDAuNSwgbWF4Wm9vbSA9IDIsIHRyYW5zbGF0ZUV4dGVudCA9IGluZmluaXRlRXh0ZW50LCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgbm9kZUV4dGVudCwgZGVmYXVsdE1hcmtlckNvbG9yID0gJyNiMWIxYjcnLCB6b29tT25TY3JvbGwgPSB0cnVlLCB6b29tT25QaW5jaCA9IHRydWUsIHBhbk9uU2Nyb2xsID0gZmFsc2UsIHBhbk9uU2Nyb2xsU3BlZWQgPSAwLjUsIHBhbk9uU2Nyb2xsTW9kZSA9IFBhbk9uU2Nyb2xsTW9kZS5GcmVlLCB6b29tT25Eb3VibGVDbGljayA9IHRydWUsIHBhbk9uRHJhZyA9IHRydWUsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIGNoaWxkcmVuLCBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCBvbkVkZ2VVcGRhdGVTdGFydCwgb25FZGdlVXBkYXRlRW5kLCBlZGdlVXBkYXRlclJhZGl1cyA9IDEwLCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBub0RyYWdDbGFzc05hbWUgPSAnbm9kcmFnJywgbm9XaGVlbENsYXNzTmFtZSA9ICdub3doZWVsJywgbm9QYW5DbGFzc05hbWUgPSAnbm9wYW4nLCBmaXRWaWV3ID0gZmFsc2UsIGZpdFZpZXdPcHRpb25zLCBjb25uZWN0T25DbGljayA9IHRydWUsIGF0dHJpYnV0aW9uUG9zaXRpb24sIHByb09wdGlvbnMsIGRlZmF1bHRFZGdlT3B0aW9ucywgZWxldmF0ZU5vZGVzT25TZWxlY3QgPSB0cnVlLCBlbGV2YXRlRWRnZXNPblNlbGVjdCA9IGZhbHNlLCBkaXNhYmxlS2V5Ym9hcmRBMTF5ID0gZmFsc2UsIGF1dG9QYW5PbkNvbm5lY3QgPSB0cnVlLCBhdXRvUGFuT25Ob2RlRHJhZyA9IHRydWUsIGNvbm5lY3Rpb25SYWRpdXMgPSAyMCwgaXNWYWxpZENvbm5lY3Rpb24sIG9uRXJyb3IsIHN0eWxlLCBpZCwgbm9kZURyYWdUaHJlc2hvbGQsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgcmZJZCA9IGlkIHx8ICcxJztcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyAuLi5yZXN0LCBzdHlsZTogeyAuLi5zdHlsZSwgLi4ud3JhcHBlclN0eWxlIH0sIHJlZjogcmVmLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvdycsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX3dyYXBwZXJcIiwgaWQ6IGlkIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlciwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JhcGhWaWV3JDEsIHsgb25Jbml0OiBvbkluaXQsIG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBub2RlVHlwZXM6IG5vZGVUeXBlcywgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGNvbm5lY3Rpb25MaW5lVHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25FZGdlVXBkYXRlOiBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlVXBkYXRlU3RhcnQ6IG9uRWRnZVVwZGF0ZVN0YXJ0LCBvbkVkZ2VVcGRhdGVFbmQ6IG9uRWRnZVVwZGF0ZUVuZCwgZWRnZVVwZGF0ZXJSYWRpdXM6IGVkZ2VVcGRhdGVyUmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZWxldmF0ZUVkZ2VzT25TZWxlY3Q6IGVsZXZhdGVFZGdlc09uU2VsZWN0LCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50IH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGU6IGVkZ2VzVXBkYXRhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBvbk5vZGVzQ2hhbmdlOiBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlOiBvbkVkZ2VzQ2hhbmdlLCBzbmFwVG9HcmlkOiBzbmFwVG9HcmlkLCBzbmFwR3JpZDogc25hcEdyaWQsIGNvbm5lY3Rpb25Nb2RlOiBjb25uZWN0aW9uTW9kZSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIGNvbm5lY3RPbkNsaWNrOiBjb25uZWN0T25DbGljaywgZGVmYXVsdEVkZ2VPcHRpb25zOiBkZWZhdWx0RWRnZU9wdGlvbnMsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgb25Ob2Rlc0RlbGV0ZTogb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZTogb25FZGdlc0RlbGV0ZSwgb25Ob2RlRHJhZ1N0YXJ0OiBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWc6IG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wOiBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnOiBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0OiBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcDogb25TZWxlY3Rpb25EcmFnU3RvcCwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCByZklkOiByZklkLCBhdXRvUGFuT25Db25uZWN0OiBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZzogYXV0b1Bhbk9uTm9kZURyYWcsIG9uRXJyb3I6IG9uRXJyb3IsIGNvbm5lY3Rpb25SYWRpdXM6IGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiwgbm9kZURyYWdUaHJlc2hvbGQ6IG5vZGVEcmFnVGhyZXNob2xkIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyJDEsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEF0dHJpYnV0aW9uLCB7IHByb09wdGlvbnM6IHByb09wdGlvbnMsIHBvc2l0aW9uOiBhdHRyaWJ1dGlvblBvc2l0aW9uIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBMTF5RGVzY3JpcHRpb25zLCB7IHJmSWQ6IHJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSkpKSk7XG59KTtcblJlYWN0Rmxvdy5kaXNwbGF5TmFtZSA9ICdSZWFjdEZsb3cnO1xuXG5jb25zdCBzZWxlY3RvciQxID0gKHMpID0+IHMuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlcicpO1xuZnVuY3Rpb24gRWRnZUxhYmVsUmVuZGVyZXIoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgZWRnZUxhYmVsUmVuZGVyZXIgPSB1c2VTdG9yZShzZWxlY3RvciQxKTtcbiAgICBpZiAoIWVkZ2VMYWJlbFJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBlZGdlTGFiZWxSZW5kZXJlcik7XG59XG5cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoaWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkb21Ob2RlLCB1cGRhdGVOb2RlRGltZW5zaW9ucyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB1cGRhdGVJZHMucmVkdWNlKChyZXMsIHVwZGF0ZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlRWxlbWVudCA9IGRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoYC5yZWFjdC1mbG93X19ub2RlW2RhdGEtaWQ9XCIke3VwZGF0ZUlkfVwiXWApO1xuICAgICAgICAgICAgaWYgKG5vZGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goeyBpZDogdXBkYXRlSWQsIG5vZGVFbGVtZW50LCBmb3JjZVVwZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVEaW1lbnNpb25zKHVwZGF0ZXMpKTtcbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IG5vZGVzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmdldE5vZGVzKCk7XG5mdW5jdGlvbiB1c2VOb2RlcygpIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuY29uc3QgZWRnZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZWRnZXM7XG5mdW5jdGlvbiB1c2VFZGdlcygpIHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKGVkZ2VzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlcztcbn1cblxuY29uc3Qgdmlld3BvcnRTZWxlY3RvciA9IChzdGF0ZSkgPT4gKHtcbiAgICB4OiBzdGF0ZS50cmFuc2Zvcm1bMF0sXG4gICAgeTogc3RhdGUudHJhbnNmb3JtWzFdLFxuICAgIHpvb206IHN0YXRlLnRyYW5zZm9ybVsyXSxcbn0pO1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIGNyZWF0ZVVzZUl0ZW1zU3RhdGUoYXBwbHlDaGFuZ2VzKSB7XG4gICAgcmV0dXJuIChpbml0aWFsSXRlbXMpID0+IHtcbiAgICAgICAgY29uc3QgW2l0ZW1zLCBzZXRJdGVtc10gPSB1c2VTdGF0ZShpbml0aWFsSXRlbXMpO1xuICAgICAgICBjb25zdCBvbkl0ZW1zQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldEl0ZW1zKChpdGVtcykgPT4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGl0ZW1zKSksIFtdKTtcbiAgICAgICAgcmV0dXJuIFtpdGVtcywgc2V0SXRlbXMsIG9uSXRlbXNDaGFuZ2VdO1xuICAgIH07XG59XG5jb25zdCB1c2VOb2Rlc1N0YXRlID0gY3JlYXRlVXNlSXRlbXNTdGF0ZShhcHBseU5vZGVDaGFuZ2VzKTtcbmNvbnN0IHVzZUVkZ2VzU3RhdGUgPSBjcmVhdGVVc2VJdGVtc1N0YXRlKGFwcGx5RWRnZUNoYW5nZXMpO1xuXG5mdW5jdGlvbiB1c2VPblZpZXdwb3J0Q2hhbmdlKHsgb25TdGFydCwgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ6IG9uU3RhcnQgfSk7XG4gICAgfSwgW29uU3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2U6IG9uQ2hhbmdlIH0pO1xuICAgIH0sIFtvbkNoYW5nZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZUVuZDogb25FbmQgfSk7XG4gICAgfSwgW29uRW5kXSk7XG59XG5cbmZ1bmN0aW9uIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHsgb25DaGFuZ2UgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvbkNoYW5nZSB9KTtcbiAgICB9LCBbb25DaGFuZ2VdKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IgPSAob3B0aW9ucykgPT4gKHMpID0+IHtcbiAgICBpZiAocy5ub2RlSW50ZXJuYWxzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc1xuICAgICAgICAuZ2V0Tm9kZXMoKVxuICAgICAgICAuZmlsdGVyKChuKSA9PiAob3B0aW9ucy5pbmNsdWRlSGlkZGVuTm9kZXMgPyB0cnVlIDogIW4uaGlkZGVuKSlcbiAgICAgICAgLmV2ZXJ5KChuKSA9PiBuW2ludGVybmFsc1N5bWJvbF0/LmhhbmRsZUJvdW5kcyAhPT0gdW5kZWZpbmVkKTtcbn07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxufTtcbmZ1bmN0aW9uIHVzZU5vZGVzSW5pdGlhbGl6ZWQob3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvcihvcHRpb25zKSk7XG4gICAgcmV0dXJuIGluaXRpYWxpemVkO1xufVxuXG5leHBvcnQgeyBCYXNlRWRnZSwgQmV6aWVyRWRnZSwgQ29ubmVjdGlvbkxpbmVUeXBlLCBDb25uZWN0aW9uTW9kZSwgRWRnZUxhYmVsUmVuZGVyZXIsIEVkZ2VUZXh0JDEgYXMgRWRnZVRleHQsIEhhbmRsZSQxIGFzIEhhbmRsZSwgTWFya2VyVHlwZSwgUGFuT25TY3JvbGxNb2RlLCBQYW5lbCwgUG9zaXRpb24sIFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIFNlbGVjdGlvbk1vZGUsIFNpbXBsZUJlemllckVkZ2UsIFNtb290aFN0ZXBFZGdlLCBTdGVwRWRnZSwgU3RyYWlnaHRFZGdlLCBhZGRFZGdlLCBhcHBseUVkZ2VDaGFuZ2VzLCBhcHBseU5vZGVDaGFuZ2VzLCBib3hUb1JlY3QsIGNsYW1wLCBnZXRCZXppZXJQYXRoLCBnZXRCb3VuZHNPZlJlY3RzLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0SW5jb21lcnMsIGdldE1hcmtlckVuZCwgZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiwgZ2V0T3V0Z29lcnMsIGdldFJlY3RPZk5vZGVzLCBnZXRTaW1wbGVCZXppZXJQYXRoLCBnZXRTbW9vdGhTdGVwUGF0aCwgZ2V0U3RyYWlnaHRQYXRoLCBnZXRUcmFuc2Zvcm1Gb3JCb3VuZHMsIGhhbmRsZVBhcmVudEV4cGFuZCwgaW50ZXJuYWxzU3ltYm9sLCBpc0VkZ2UsIGlzTm9kZSwgcmVjdFRvQm94LCB1cGRhdGVFZGdlLCB1c2VFZGdlcywgdXNlRWRnZXNTdGF0ZSwgdXNlR2V0UG9pbnRlclBvc2l0aW9uLCB1c2VLZXlQcmVzcywgdXNlTm9kZUlkLCB1c2VOb2RlcywgdXNlTm9kZXNJbml0aWFsaXplZCwgdXNlTm9kZXNTdGF0ZSwgdXNlT25TZWxlY3Rpb25DaGFuZ2UsIHVzZU9uVmlld3BvcnRDaGFuZ2UsIHVzZVJlYWN0RmxvdywgdXNlU3RvcmUsIHVzZVN0b3JlQXBpLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzLCB1c2VWaWV3cG9ydCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@reactflow+core@11.9.3_@types+react@18.2.5_react-dom@18.2.0_react@18.2.0/node_modules/@reactflow/core/dist/esm/index.mjs\n");

/***/ })

};
;
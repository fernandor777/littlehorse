"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5";
exports.ids = ["vendor-chunks/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5/node_modules/@tisoap/react-flow-smart-edge/dist/index.js":
/*!*********************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5/node_modules/@tisoap/react-flow-smart-edge/dist/index.js ***!
  \*********************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-flow-smart-edge.cjs.development.js */ \"(ssr)/../../node_modules/.pnpm/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5/node_modules/@tisoap/react-flow-smart-edge/dist/react-flow-smart-edge.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0aXNvYXArcmVhY3QtZmxvdy1zbWFydC1lZGdlQDMuMC4wX3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wX3JlYWN0Zmxvd0AxMS45LjNfdHlwZXNjcmlwdEA0LjkuNS9ub2RlX21vZHVsZXMvQHRpc29hcC9yZWFjdC1mbG93LXNtYXJ0LWVkZ2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ1k7O0FBRVosSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHFUQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRpc29hcCtyZWFjdC1mbG93LXNtYXJ0LWVkZ2VAMy4wLjBfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjBfcmVhY3RmbG93QDExLjkuM190eXBlc2NyaXB0QDQuOS41L25vZGVfbW9kdWxlcy9AdGlzb2FwL3JlYWN0LWZsb3ctc21hcnQtZWRnZS9kaXN0L2luZGV4LmpzPzZhODEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWN0LWZsb3ctc21hcnQtZWRnZS5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWN0LWZsb3ctc21hcnQtZWRnZS5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5/node_modules/@tisoap/react-flow-smart-edge/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5/node_modules/@tisoap/react-flow-smart-edge/dist/react-flow-smart-edge.cjs.development.js":
/*!*****************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5/node_modules/@tisoap/react-flow-smart-edge/dist/react-flow-smart-edge.cjs.development.js ***!
  \*****************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@13.5.5_@babel+core@7.23.2_react-dom@18.2.0_react@18.2.0_sass@1.63.6/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar reactflow = __webpack_require__(/*! reactflow */ \"(ssr)/../../node_modules/.pnpm/reactflow@11.9.3_@types+react@18.2.5_react-dom@18.2.0_react@18.2.0/node_modules/reactflow/dist/umd/index.js\");\nvar pathfinding = __webpack_require__(/*! pathfinding */ \"(ssr)/../../node_modules/.pnpm/pathfinding@0.4.18/node_modules/pathfinding/index.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nvar getNextPointFromPosition = function getNextPointFromPosition(point, position) {\n  switch (position) {\n    case 'top':\n      return {\n        x: point.x,\n        y: point.y - 1\n      };\n    case 'bottom':\n      return {\n        x: point.x,\n        y: point.y + 1\n      };\n    case 'left':\n      return {\n        x: point.x - 1,\n        y: point.y\n      };\n    case 'right':\n      return {\n        x: point.x + 1,\n        y: point.y\n      };\n  }\n};\n/**\r\n * Guarantee that the path is walkable, even if the point is inside a non\r\n * walkable area, by adding a walkable path in the direction of the point's\r\n * Position.\r\n */\nvar guaranteeWalkablePath = function guaranteeWalkablePath(grid, point, position) {\n  var node = grid.getNodeAt(point.x, point.y);\n  while (!node.walkable) {\n    grid.setWalkableAt(node.x, node.y, true);\n    var next = getNextPointFromPosition(node, position);\n    node = grid.getNodeAt(next.x, next.y);\n  }\n};\n\n/**\r\n * Each bounding box is a collection of X/Y points in a graph, and we\r\n * need to convert them to \"occupied\" cells in a 2D grid representation.\r\n *\r\n * The top most position of the grid (grid[0][0]) needs to be equivalent\r\n * to the top most point in the graph (the graph.topLeft point).\r\n *\r\n * Since the top most point can have X/Y values different than zero,\r\n * and each cell in a grid represents a 10x10 pixel area in the grid (or a\r\n * gridRatio area), there's need to be a conversion between a point in a graph\r\n * to a point in the grid.\r\n *\r\n * We do this conversion by dividing a graph point X/Y values by the grid ratio,\r\n * and \"shifting\" their values up or down, depending on the values of the top\r\n * most point in the graph. The top most point in the graph will have the\r\n * smallest values for X and Y.\r\n *\r\n * We avoid setting nodes in the border of the grid (x=0 or y=0), so there's\r\n * always a \"walkable\" area around the grid.\r\n */\nvar graphToGridPoint = function graphToGridPoint(graphPoint, smallestX, smallestY, gridRatio) {\n  var x = graphPoint.x / gridRatio;\n  var y = graphPoint.y / gridRatio;\n  var referenceX = smallestX / gridRatio;\n  var referenceY = smallestY / gridRatio;\n  if (referenceX < 1) {\n    while (referenceX !== 1) {\n      referenceX++;\n      x++;\n    }\n  } else if (referenceX > 1) {\n    while (referenceX !== 1) {\n      referenceX--;\n      x--;\n    }\n  } else ;\n  if (referenceY < 1) {\n    while (referenceY !== 1) {\n      referenceY++;\n      y++;\n    }\n  } else if (referenceY > 1) {\n    while (referenceY !== 1) {\n      referenceY--;\n      y--;\n    }\n  } else ;\n  return {\n    x: x,\n    y: y\n  };\n};\n/**\r\n * Converts a grid point back to a graph point, using the reverse logic of\r\n * graphToGridPoint.\r\n */\nvar gridToGraphPoint = function gridToGraphPoint(gridPoint, smallestX, smallestY, gridRatio) {\n  var x = gridPoint.x * gridRatio;\n  var y = gridPoint.y * gridRatio;\n  var referenceX = smallestX;\n  var referenceY = smallestY;\n  if (referenceX < gridRatio) {\n    while (referenceX !== gridRatio) {\n      referenceX = referenceX + gridRatio;\n      x = x - gridRatio;\n    }\n  } else if (referenceX > gridRatio) {\n    while (referenceX !== gridRatio) {\n      referenceX = referenceX - gridRatio;\n      x = x + gridRatio;\n    }\n  } else ;\n  if (referenceY < gridRatio) {\n    while (referenceY !== gridRatio) {\n      referenceY = referenceY + gridRatio;\n      y = y - gridRatio;\n    }\n  } else if (referenceY > gridRatio) {\n    while (referenceY !== gridRatio) {\n      referenceY = referenceY - gridRatio;\n      y = y + gridRatio;\n    }\n  } else ;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar round = function round(x, multiple) {\n  if (multiple === void 0) {\n    multiple = 10;\n  }\n  return Math.round(x / multiple) * multiple;\n};\nvar roundDown = function roundDown(x, multiple) {\n  if (multiple === void 0) {\n    multiple = 10;\n  }\n  return Math.floor(x / multiple) * multiple;\n};\nvar roundUp = function roundUp(x, multiple) {\n  if (multiple === void 0) {\n    multiple = 10;\n  }\n  return Math.ceil(x / multiple) * multiple;\n};\nvar toInteger = function toInteger(value, min) {\n  if (min === void 0) {\n    min = 0;\n  }\n  var result = Math.max(Math.round(value), min);\n  result = Number.isInteger(result) ? result : min;\n  result = result >= min ? result : min;\n  return result;\n};\n\nvar createGrid = function createGrid(graph, nodes, source, target, gridRatio) {\n  if (gridRatio === void 0) {\n    gridRatio = 2;\n  }\n  var xMin = graph.xMin,\n    yMin = graph.yMin,\n    width = graph.width,\n    height = graph.height;\n  // Create a grid representation of the graph box, where each cell is\n  // equivalent to 10x10 pixels (or the grid ratio) on the graph. We'll use\n  // this simplified grid to do pathfinding.\n  var mapColumns = roundUp(width, gridRatio) / gridRatio + 1;\n  var mapRows = roundUp(height, gridRatio) / gridRatio + 1;\n  var grid = new pathfinding.Grid(mapColumns, mapRows);\n  // Update the grid representation with the space the nodes take up\n  nodes.forEach(function (node) {\n    var nodeStart = graphToGridPoint(node.topLeft, xMin, yMin, gridRatio);\n    var nodeEnd = graphToGridPoint(node.bottomRight, xMin, yMin, gridRatio);\n    for (var x = nodeStart.x; x < nodeEnd.x; x++) {\n      for (var y = nodeStart.y; y < nodeEnd.y; y++) {\n        grid.setWalkableAt(x, y, false);\n      }\n    }\n  });\n  // Convert the starting and ending graph points to grid points\n  var startGrid = graphToGridPoint({\n    x: round(source.x, gridRatio),\n    y: round(source.y, gridRatio)\n  }, xMin, yMin, gridRatio);\n  var endGrid = graphToGridPoint({\n    x: round(target.x, gridRatio),\n    y: round(target.y, gridRatio)\n  }, xMin, yMin, gridRatio);\n  // Guarantee a walkable path between the start and end points, even if the\n  // source or target where covered by another node or by padding\n  var startingNode = grid.getNodeAt(startGrid.x, startGrid.y);\n  guaranteeWalkablePath(grid, startingNode, source.position);\n  var endingNode = grid.getNodeAt(endGrid.x, endGrid.y);\n  guaranteeWalkablePath(grid, endingNode, target.position);\n  // Use the next closest points as the start and end points, so\n  // pathfinding does not start too close to the nodes\n  var start = getNextPointFromPosition(startingNode, source.position);\n  var end = getNextPointFromPosition(endingNode, target.position);\n  return {\n    grid: grid,\n    start: start,\n    end: end\n  };\n};\n\n/**\r\n * Draws a SVG path from a list of points, using straight lines.\r\n */\nvar svgDrawStraightLinePath = function svgDrawStraightLinePath(source, target, path) {\n  var svgPathString = \"M \" + source.x + \", \" + source.y + \" \";\n  path.forEach(function (point) {\n    var x = point[0],\n      y = point[1];\n    svgPathString += \"L \" + x + \", \" + y + \" \";\n  });\n  svgPathString += \"L \" + target.x + \", \" + target.y + \" \";\n  return svgPathString;\n};\n/**\r\n * Draws a SVG path from a list of points, using rounded lines.\r\n */\nvar svgDrawSmoothLinePath = function svgDrawSmoothLinePath(source, target, path) {\n  var points = [[source.x, source.y]].concat(path, [[target.x, target.y]]);\n  return quadraticBezierCurve(points);\n};\nvar quadraticBezierCurve = function quadraticBezierCurve(points) {\n  var X = 0;\n  var Y = 1;\n  var point = points[0];\n  var first = points[0];\n  var svgPath = \"M\" + first[X] + \",\" + first[Y] + \"M\";\n  for (var i = 0; i < points.length; i++) {\n    var next = points[i];\n    var midPoint = getMidPoint(point[X], point[Y], next[X], next[Y]);\n    svgPath += \" \" + midPoint[X] + \",\" + midPoint[Y];\n    svgPath += \"Q\" + next[X] + \",\" + next[Y];\n    point = next;\n  }\n  var last = points[points.length - 1];\n  svgPath += \" \" + last[0] + \",\" + last[1];\n  return svgPath;\n};\nvar getMidPoint = function getMidPoint(Ax, Ay, Bx, By) {\n  var Zx = (Ax - Bx) / 2 + Bx;\n  var Zy = (Ay - By) / 2 + By;\n  return [Zx, Zy];\n};\n\n// FIXME: The \"pathfinding\" module doe not have proper typings.\nvar pathfindingAStarDiagonal = function pathfindingAStarDiagonal(grid, start, end) {\n  try {\n    var finder = new pathfinding.AStarFinder({\n      diagonalMovement: pathfinding.DiagonalMovement.Always\n    });\n    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);\n    var smoothedPath = pathfinding.Util.smoothenPath(grid, fullPath);\n    if (fullPath.length === 0 || smoothedPath.length === 0) return null;\n    return {\n      fullPath: fullPath,\n      smoothedPath: smoothedPath\n    };\n  } catch (_unused) {\n    return null;\n  }\n};\nvar pathfindingAStarNoDiagonal = function pathfindingAStarNoDiagonal(grid, start, end) {\n  try {\n    var finder = new pathfinding.AStarFinder({\n      diagonalMovement: pathfinding.DiagonalMovement.Never\n    });\n    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);\n    var smoothedPath = pathfinding.Util.smoothenPath(grid, fullPath);\n    if (fullPath.length === 0 || smoothedPath.length === 0) return null;\n    return {\n      fullPath: fullPath,\n      smoothedPath: smoothedPath\n    };\n  } catch (_unused2) {\n    return null;\n  }\n};\nvar pathfindingJumpPointNoDiagonal = function pathfindingJumpPointNoDiagonal(grid, start, end) {\n  try {\n    // FIXME: The \"pathfinding\" module doe not have proper typings.\n    // @ts-ignore\n    var finder = new pathfinding.JumpPointFinder({\n      diagonalMovement: pathfinding.DiagonalMovement.Never\n    });\n    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);\n    var smoothedPath = fullPath;\n    if (fullPath.length === 0 || smoothedPath.length === 0) return null;\n    return {\n      fullPath: fullPath,\n      smoothedPath: smoothedPath\n    };\n  } catch (_unused3) {\n    return null;\n  }\n};\n\n/**\r\n * Get the bounding box of all nodes and the graph itself, as X/Y coordinates\r\n * of all corner points.\r\n *\r\n * @param nodes The node list\r\n * @param nodePadding Optional padding to add to the node's and graph bounding boxes\r\n * @param roundTo Everything will be rounded to this nearest integer\r\n * @returns Graph and nodes bounding boxes.\r\n */\nvar getBoundingBoxes = function getBoundingBoxes(nodes, nodePadding, roundTo) {\n  if (nodePadding === void 0) {\n    nodePadding = 2;\n  }\n  if (roundTo === void 0) {\n    roundTo = 2;\n  }\n  var xMax = Number.MIN_SAFE_INTEGER;\n  var yMax = Number.MIN_SAFE_INTEGER;\n  var xMin = Number.MAX_SAFE_INTEGER;\n  var yMin = Number.MAX_SAFE_INTEGER;\n  var nodeBoxes = nodes.map(function (node) {\n    var _node$positionAbsolut, _node$positionAbsolut2;\n    var width = Math.max(node.width || 0, 1);\n    var height = Math.max(node.height || 0, 1);\n    var position = {\n      x: ((_node$positionAbsolut = node.positionAbsolute) == null ? void 0 : _node$positionAbsolut.x) || 0,\n      y: ((_node$positionAbsolut2 = node.positionAbsolute) == null ? void 0 : _node$positionAbsolut2.y) || 0\n    };\n    var topLeft = {\n      x: position.x - nodePadding,\n      y: position.y - nodePadding\n    };\n    var bottomLeft = {\n      x: position.x - nodePadding,\n      y: position.y + height + nodePadding\n    };\n    var topRight = {\n      x: position.x + width + nodePadding,\n      y: position.y - nodePadding\n    };\n    var bottomRight = {\n      x: position.x + width + nodePadding,\n      y: position.y + height + nodePadding\n    };\n    if (roundTo > 0) {\n      topLeft.x = roundDown(topLeft.x, roundTo);\n      topLeft.y = roundDown(topLeft.y, roundTo);\n      bottomLeft.x = roundDown(bottomLeft.x, roundTo);\n      bottomLeft.y = roundUp(bottomLeft.y, roundTo);\n      topRight.x = roundUp(topRight.x, roundTo);\n      topRight.y = roundDown(topRight.y, roundTo);\n      bottomRight.x = roundUp(bottomRight.x, roundTo);\n      bottomRight.y = roundUp(bottomRight.y, roundTo);\n    }\n    if (topLeft.y < yMin) yMin = topLeft.y;\n    if (topLeft.x < xMin) xMin = topLeft.x;\n    if (bottomRight.y > yMax) yMax = bottomRight.y;\n    if (bottomRight.x > xMax) xMax = bottomRight.x;\n    return {\n      id: node.id,\n      width: width,\n      height: height,\n      topLeft: topLeft,\n      bottomLeft: bottomLeft,\n      topRight: topRight,\n      bottomRight: bottomRight\n    };\n  });\n  var graphPadding = nodePadding * 2;\n  xMax = roundUp(xMax + graphPadding, roundTo);\n  yMax = roundUp(yMax + graphPadding, roundTo);\n  xMin = roundDown(xMin - graphPadding, roundTo);\n  yMin = roundDown(yMin - graphPadding, roundTo);\n  var topLeft = {\n    x: xMin,\n    y: yMin\n  };\n  var bottomLeft = {\n    x: xMin,\n    y: yMax\n  };\n  var topRight = {\n    x: xMax,\n    y: yMin\n  };\n  var bottomRight = {\n    x: xMax,\n    y: yMax\n  };\n  var width = Math.abs(topLeft.x - topRight.x);\n  var height = Math.abs(topLeft.y - bottomLeft.y);\n  var graphBox = {\n    topLeft: topLeft,\n    bottomLeft: bottomLeft,\n    topRight: topRight,\n    bottomRight: bottomRight,\n    width: width,\n    height: height,\n    xMax: xMax,\n    yMax: yMax,\n    xMin: xMin,\n    yMin: yMin\n  };\n  return {\n    nodeBoxes: nodeBoxes,\n    graphBox: graphBox\n  };\n};\n\nvar getSmartEdge = function getSmartEdge(_ref) {\n  var _ref$options = _ref.options,\n    options = _ref$options === void 0 ? {} : _ref$options,\n    _ref$nodes = _ref.nodes,\n    nodes = _ref$nodes === void 0 ? [] : _ref$nodes,\n    sourceX = _ref.sourceX,\n    sourceY = _ref.sourceY,\n    targetX = _ref.targetX,\n    targetY = _ref.targetY,\n    sourcePosition = _ref.sourcePosition,\n    targetPosition = _ref.targetPosition;\n  try {\n    var _options$drawEdge = options.drawEdge,\n      drawEdge = _options$drawEdge === void 0 ? svgDrawSmoothLinePath : _options$drawEdge,\n      _options$generatePath = options.generatePath,\n      generatePath = _options$generatePath === void 0 ? pathfindingAStarDiagonal : _options$generatePath;\n    var _options$gridRatio = options.gridRatio,\n      gridRatio = _options$gridRatio === void 0 ? 10 : _options$gridRatio,\n      _options$nodePadding = options.nodePadding,\n      nodePadding = _options$nodePadding === void 0 ? 10 : _options$nodePadding;\n    gridRatio = toInteger(gridRatio);\n    nodePadding = toInteger(nodePadding);\n    // We use the node's information to generate bounding boxes for them\n    // and the graph\n    var _getBoundingBoxes = getBoundingBoxes(nodes, nodePadding, gridRatio),\n      graphBox = _getBoundingBoxes.graphBox,\n      nodeBoxes = _getBoundingBoxes.nodeBoxes;\n    var source = {\n      x: sourceX,\n      y: sourceY,\n      position: sourcePosition\n    };\n    var target = {\n      x: targetX,\n      y: targetY,\n      position: targetPosition\n    };\n    // With this information, we can create a 2D grid representation of\n    // our graph, that tells us where in the graph there is a \"free\" space or not\n    var _createGrid = createGrid(graphBox, nodeBoxes, source, target, gridRatio),\n      grid = _createGrid.grid,\n      start = _createGrid.start,\n      end = _createGrid.end;\n    // We then can use the grid representation to do pathfinding\n    var generatePathResult = generatePath(grid, start, end);\n    if (generatePathResult === null) {\n      return null;\n    }\n    var fullPath = generatePathResult.fullPath,\n      smoothedPath = generatePathResult.smoothedPath;\n    // Here we convert the grid path to a sequence of graph coordinates.\n    var graphPath = smoothedPath.map(function (gridPoint) {\n      var x = gridPoint[0],\n        y = gridPoint[1];\n      var graphPoint = gridToGraphPoint({\n        x: x,\n        y: y\n      }, graphBox.xMin, graphBox.yMin, gridRatio);\n      return [graphPoint.x, graphPoint.y];\n    });\n    // Finally, we can use the graph path to draw the edge\n    var svgPathString = drawEdge(source, target, graphPath);\n    // Compute the edge's middle point using the full path, so users can use\n    // it to position their custom labels\n    var index = Math.floor(fullPath.length / 2);\n    var middlePoint = fullPath[index];\n    var middleX = middlePoint[0],\n      middleY = middlePoint[1];\n    var _gridToGraphPoint = gridToGraphPoint({\n        x: middleX,\n        y: middleY\n      }, graphBox.xMin, graphBox.yMin, gridRatio),\n      edgeCenterX = _gridToGraphPoint.x,\n      edgeCenterY = _gridToGraphPoint.y;\n    return {\n      svgPathString: svgPathString,\n      edgeCenterX: edgeCenterX,\n      edgeCenterY: edgeCenterY\n    };\n  } catch (_unused) {\n    return null;\n  }\n};\n\nvar _excluded = [\"nodes\", \"options\"];\nfunction SmartEdge(_ref) {\n  var nodes = _ref.nodes,\n    options = _ref.options,\n    edgeProps = _objectWithoutPropertiesLoose(_ref, _excluded);\n  var sourceX = edgeProps.sourceX,\n    sourceY = edgeProps.sourceY,\n    sourcePosition = edgeProps.sourcePosition,\n    targetX = edgeProps.targetX,\n    targetY = edgeProps.targetY,\n    targetPosition = edgeProps.targetPosition,\n    style = edgeProps.style,\n    label = edgeProps.label,\n    labelStyle = edgeProps.labelStyle,\n    labelShowBg = edgeProps.labelShowBg,\n    labelBgStyle = edgeProps.labelBgStyle,\n    labelBgPadding = edgeProps.labelBgPadding,\n    labelBgBorderRadius = edgeProps.labelBgBorderRadius,\n    markerEnd = edgeProps.markerEnd,\n    markerStart = edgeProps.markerStart,\n    interactionWidth = edgeProps.interactionWidth;\n  var smartResponse = getSmartEdge({\n    sourcePosition: sourcePosition,\n    targetPosition: targetPosition,\n    sourceX: sourceX,\n    sourceY: sourceY,\n    targetX: targetX,\n    targetY: targetY,\n    options: options,\n    nodes: nodes\n  });\n  var FallbackEdge = options.fallback || reactflow.BezierEdge;\n  if (smartResponse === null) {\n    return React__default[\"default\"].createElement(FallbackEdge, _extends({}, edgeProps));\n  }\n  var edgeCenterX = smartResponse.edgeCenterX,\n    edgeCenterY = smartResponse.edgeCenterY,\n    svgPathString = smartResponse.svgPathString;\n  return React__default[\"default\"].createElement(reactflow.BaseEdge, {\n    path: svgPathString,\n    labelX: edgeCenterX,\n    labelY: edgeCenterY,\n    label: label,\n    labelStyle: labelStyle,\n    labelShowBg: labelShowBg,\n    labelBgStyle: labelBgStyle,\n    labelBgPadding: labelBgPadding,\n    labelBgBorderRadius: labelBgBorderRadius,\n    style: style,\n    markerStart: markerStart,\n    markerEnd: markerEnd,\n    interactionWidth: interactionWidth\n  });\n}\n\nvar BezierConfiguration = {\n  drawEdge: svgDrawSmoothLinePath,\n  generatePath: pathfindingAStarDiagonal,\n  fallback: reactflow.BezierEdge\n};\nfunction SmartBezierEdge(props) {\n  var nodes = reactflow.useNodes();\n  return React__default[\"default\"].createElement(SmartEdge, _extends({}, props, {\n    options: BezierConfiguration,\n    nodes: nodes\n  }));\n}\n\nvar StepConfiguration = {\n  drawEdge: svgDrawStraightLinePath,\n  generatePath: pathfindingJumpPointNoDiagonal,\n  fallback: reactflow.StepEdge\n};\nfunction SmartStepEdge(props) {\n  var nodes = reactflow.useNodes();\n  return React__default[\"default\"].createElement(SmartEdge, _extends({}, props, {\n    options: StepConfiguration,\n    nodes: nodes\n  }));\n}\n\nvar StraightConfiguration = {\n  drawEdge: svgDrawStraightLinePath,\n  generatePath: pathfindingAStarNoDiagonal,\n  fallback: reactflow.StraightEdge\n};\nfunction SmartStraightEdge(props) {\n  var nodes = reactflow.useNodes();\n  return React__default[\"default\"].createElement(SmartEdge, _extends({}, props, {\n    options: StraightConfiguration,\n    nodes: nodes\n  }));\n}\n\nexports.SmartBezierEdge = SmartBezierEdge;\nexports.SmartEdge = SmartEdge;\nexports.SmartStepEdge = SmartStepEdge;\nexports.SmartStraightEdge = SmartStraightEdge;\nexports[\"default\"] = SmartBezierEdge;\nexports.getSmartEdge = getSmartEdge;\nexports.pathfindingAStarDiagonal = pathfindingAStarDiagonal;\nexports.pathfindingAStarNoDiagonal = pathfindingAStarNoDiagonal;\nexports.pathfindingJumpPointNoDiagonal = pathfindingJumpPointNoDiagonal;\nexports.svgDrawSmoothLinePath = svgDrawSmoothLinePath;\nexports.svgDrawStraightLinePath = svgDrawStraightLinePath;\n//# sourceMappingURL=react-flow-smart-edge.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0aXNvYXArcmVhY3QtZmxvdy1zbWFydC1lZGdlQDMuMC4wX3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wX3JlYWN0Zmxvd0AxMS45LjNfdHlwZXNjcmlwdEA0LjkuNS9ub2RlX21vZHVsZXMvQHRpc29hcC9yZWFjdC1mbG93LXNtYXJ0LWVkZ2UvZGlzdC9yZWFjdC1mbG93LXNtYXJ0LWVkZ2UuY2pzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsWUFBWSxtQkFBTyxDQUFDLHdNQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDZKQUFXO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLHdHQUFhOztBQUV2QyxxQ0FBcUMsNERBQTREOztBQUVqRzs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx1QkFBdUI7QUFDdkIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLHNDQUFzQztBQUN0Qyw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGlzb2FwK3JlYWN0LWZsb3ctc21hcnQtZWRnZUAzLjAuMF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMF9yZWFjdGZsb3dAMTEuOS4zX3R5cGVzY3JpcHRANC45LjUvbm9kZV9tb2R1bGVzL0B0aXNvYXAvcmVhY3QtZmxvdy1zbWFydC1lZGdlL2Rpc3QvcmVhY3QtZmxvdy1zbWFydC1lZGdlLmNqcy5kZXZlbG9wbWVudC5qcz8yYTgwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciByZWFjdGZsb3cgPSByZXF1aXJlKCdyZWFjdGZsb3cnKTtcbnZhciBwYXRoZmluZGluZyA9IHJlcXVpcmUoJ3BhdGhmaW5kaW5nJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFJlYWN0KTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgZ2V0TmV4dFBvaW50RnJvbVBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0TmV4dFBvaW50RnJvbVBvc2l0aW9uKHBvaW50LCBwb3NpdGlvbikge1xuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgIHk6IHBvaW50LnkgLSAxXG4gICAgICB9O1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICB5OiBwb2ludC55ICsgMVxuICAgICAgfTtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50LnggLSAxLFxuICAgICAgICB5OiBwb2ludC55XG4gICAgICB9O1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50LnggKyAxLFxuICAgICAgICB5OiBwb2ludC55XG4gICAgICB9O1xuICB9XG59O1xuLyoqXHJcbiAqIEd1YXJhbnRlZSB0aGF0IHRoZSBwYXRoIGlzIHdhbGthYmxlLCBldmVuIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgYSBub25cclxuICogd2Fsa2FibGUgYXJlYSwgYnkgYWRkaW5nIGEgd2Fsa2FibGUgcGF0aCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBwb2ludCdzXHJcbiAqIFBvc2l0aW9uLlxyXG4gKi9cbnZhciBndWFyYW50ZWVXYWxrYWJsZVBhdGggPSBmdW5jdGlvbiBndWFyYW50ZWVXYWxrYWJsZVBhdGgoZ3JpZCwgcG9pbnQsIHBvc2l0aW9uKSB7XG4gIHZhciBub2RlID0gZ3JpZC5nZXROb2RlQXQocG9pbnQueCwgcG9pbnQueSk7XG4gIHdoaWxlICghbm9kZS53YWxrYWJsZSkge1xuICAgIGdyaWQuc2V0V2Fsa2FibGVBdChub2RlLngsIG5vZGUueSwgdHJ1ZSk7XG4gICAgdmFyIG5leHQgPSBnZXROZXh0UG9pbnRGcm9tUG9zaXRpb24obm9kZSwgcG9zaXRpb24pO1xuICAgIG5vZGUgPSBncmlkLmdldE5vZGVBdChuZXh0LngsIG5leHQueSk7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBFYWNoIGJvdW5kaW5nIGJveCBpcyBhIGNvbGxlY3Rpb24gb2YgWC9ZIHBvaW50cyBpbiBhIGdyYXBoLCBhbmQgd2VcclxuICogbmVlZCB0byBjb252ZXJ0IHRoZW0gdG8gXCJvY2N1cGllZFwiIGNlbGxzIGluIGEgMkQgZ3JpZCByZXByZXNlbnRhdGlvbi5cclxuICpcclxuICogVGhlIHRvcCBtb3N0IHBvc2l0aW9uIG9mIHRoZSBncmlkIChncmlkWzBdWzBdKSBuZWVkcyB0byBiZSBlcXVpdmFsZW50XHJcbiAqIHRvIHRoZSB0b3AgbW9zdCBwb2ludCBpbiB0aGUgZ3JhcGggKHRoZSBncmFwaC50b3BMZWZ0IHBvaW50KS5cclxuICpcclxuICogU2luY2UgdGhlIHRvcCBtb3N0IHBvaW50IGNhbiBoYXZlIFgvWSB2YWx1ZXMgZGlmZmVyZW50IHRoYW4gemVybyxcclxuICogYW5kIGVhY2ggY2VsbCBpbiBhIGdyaWQgcmVwcmVzZW50cyBhIDEweDEwIHBpeGVsIGFyZWEgaW4gdGhlIGdyaWQgKG9yIGFcclxuICogZ3JpZFJhdGlvIGFyZWEpLCB0aGVyZSdzIG5lZWQgdG8gYmUgYSBjb252ZXJzaW9uIGJldHdlZW4gYSBwb2ludCBpbiBhIGdyYXBoXHJcbiAqIHRvIGEgcG9pbnQgaW4gdGhlIGdyaWQuXHJcbiAqXHJcbiAqIFdlIGRvIHRoaXMgY29udmVyc2lvbiBieSBkaXZpZGluZyBhIGdyYXBoIHBvaW50IFgvWSB2YWx1ZXMgYnkgdGhlIGdyaWQgcmF0aW8sXHJcbiAqIGFuZCBcInNoaWZ0aW5nXCIgdGhlaXIgdmFsdWVzIHVwIG9yIGRvd24sIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSB0b3BcclxuICogbW9zdCBwb2ludCBpbiB0aGUgZ3JhcGguIFRoZSB0b3AgbW9zdCBwb2ludCBpbiB0aGUgZ3JhcGggd2lsbCBoYXZlIHRoZVxyXG4gKiBzbWFsbGVzdCB2YWx1ZXMgZm9yIFggYW5kIFkuXHJcbiAqXHJcbiAqIFdlIGF2b2lkIHNldHRpbmcgbm9kZXMgaW4gdGhlIGJvcmRlciBvZiB0aGUgZ3JpZCAoeD0wIG9yIHk9MCksIHNvIHRoZXJlJ3NcclxuICogYWx3YXlzIGEgXCJ3YWxrYWJsZVwiIGFyZWEgYXJvdW5kIHRoZSBncmlkLlxyXG4gKi9cbnZhciBncmFwaFRvR3JpZFBvaW50ID0gZnVuY3Rpb24gZ3JhcGhUb0dyaWRQb2ludChncmFwaFBvaW50LCBzbWFsbGVzdFgsIHNtYWxsZXN0WSwgZ3JpZFJhdGlvKSB7XG4gIHZhciB4ID0gZ3JhcGhQb2ludC54IC8gZ3JpZFJhdGlvO1xuICB2YXIgeSA9IGdyYXBoUG9pbnQueSAvIGdyaWRSYXRpbztcbiAgdmFyIHJlZmVyZW5jZVggPSBzbWFsbGVzdFggLyBncmlkUmF0aW87XG4gIHZhciByZWZlcmVuY2VZID0gc21hbGxlc3RZIC8gZ3JpZFJhdGlvO1xuICBpZiAocmVmZXJlbmNlWCA8IDEpIHtcbiAgICB3aGlsZSAocmVmZXJlbmNlWCAhPT0gMSkge1xuICAgICAgcmVmZXJlbmNlWCsrO1xuICAgICAgeCsrO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWZlcmVuY2VYID4gMSkge1xuICAgIHdoaWxlIChyZWZlcmVuY2VYICE9PSAxKSB7XG4gICAgICByZWZlcmVuY2VYLS07XG4gICAgICB4LS07XG4gICAgfVxuICB9IGVsc2UgO1xuICBpZiAocmVmZXJlbmNlWSA8IDEpIHtcbiAgICB3aGlsZSAocmVmZXJlbmNlWSAhPT0gMSkge1xuICAgICAgcmVmZXJlbmNlWSsrO1xuICAgICAgeSsrO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWZlcmVuY2VZID4gMSkge1xuICAgIHdoaWxlIChyZWZlcmVuY2VZICE9PSAxKSB7XG4gICAgICByZWZlcmVuY2VZLS07XG4gICAgICB5LS07XG4gICAgfVxuICB9IGVsc2UgO1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufTtcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGdyaWQgcG9pbnQgYmFjayB0byBhIGdyYXBoIHBvaW50LCB1c2luZyB0aGUgcmV2ZXJzZSBsb2dpYyBvZlxyXG4gKiBncmFwaFRvR3JpZFBvaW50LlxyXG4gKi9cbnZhciBncmlkVG9HcmFwaFBvaW50ID0gZnVuY3Rpb24gZ3JpZFRvR3JhcGhQb2ludChncmlkUG9pbnQsIHNtYWxsZXN0WCwgc21hbGxlc3RZLCBncmlkUmF0aW8pIHtcbiAgdmFyIHggPSBncmlkUG9pbnQueCAqIGdyaWRSYXRpbztcbiAgdmFyIHkgPSBncmlkUG9pbnQueSAqIGdyaWRSYXRpbztcbiAgdmFyIHJlZmVyZW5jZVggPSBzbWFsbGVzdFg7XG4gIHZhciByZWZlcmVuY2VZID0gc21hbGxlc3RZO1xuICBpZiAocmVmZXJlbmNlWCA8IGdyaWRSYXRpbykge1xuICAgIHdoaWxlIChyZWZlcmVuY2VYICE9PSBncmlkUmF0aW8pIHtcbiAgICAgIHJlZmVyZW5jZVggPSByZWZlcmVuY2VYICsgZ3JpZFJhdGlvO1xuICAgICAgeCA9IHggLSBncmlkUmF0aW87XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlZmVyZW5jZVggPiBncmlkUmF0aW8pIHtcbiAgICB3aGlsZSAocmVmZXJlbmNlWCAhPT0gZ3JpZFJhdGlvKSB7XG4gICAgICByZWZlcmVuY2VYID0gcmVmZXJlbmNlWCAtIGdyaWRSYXRpbztcbiAgICAgIHggPSB4ICsgZ3JpZFJhdGlvO1xuICAgIH1cbiAgfSBlbHNlIDtcbiAgaWYgKHJlZmVyZW5jZVkgPCBncmlkUmF0aW8pIHtcbiAgICB3aGlsZSAocmVmZXJlbmNlWSAhPT0gZ3JpZFJhdGlvKSB7XG4gICAgICByZWZlcmVuY2VZID0gcmVmZXJlbmNlWSArIGdyaWRSYXRpbztcbiAgICAgIHkgPSB5IC0gZ3JpZFJhdGlvO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWZlcmVuY2VZID4gZ3JpZFJhdGlvKSB7XG4gICAgd2hpbGUgKHJlZmVyZW5jZVkgIT09IGdyaWRSYXRpbykge1xuICAgICAgcmVmZXJlbmNlWSA9IHJlZmVyZW5jZVkgLSBncmlkUmF0aW87XG4gICAgICB5ID0geSArIGdyaWRSYXRpbztcbiAgICB9XG4gIH0gZWxzZSA7XG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59O1xuXG52YXIgcm91bmQgPSBmdW5jdGlvbiByb3VuZCh4LCBtdWx0aXBsZSkge1xuICBpZiAobXVsdGlwbGUgPT09IHZvaWQgMCkge1xuICAgIG11bHRpcGxlID0gMTA7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQoeCAvIG11bHRpcGxlKSAqIG11bHRpcGxlO1xufTtcbnZhciByb3VuZERvd24gPSBmdW5jdGlvbiByb3VuZERvd24oeCwgbXVsdGlwbGUpIHtcbiAgaWYgKG11bHRpcGxlID09PSB2b2lkIDApIHtcbiAgICBtdWx0aXBsZSA9IDEwO1xuICB9XG4gIHJldHVybiBNYXRoLmZsb29yKHggLyBtdWx0aXBsZSkgKiBtdWx0aXBsZTtcbn07XG52YXIgcm91bmRVcCA9IGZ1bmN0aW9uIHJvdW5kVXAoeCwgbXVsdGlwbGUpIHtcbiAgaWYgKG11bHRpcGxlID09PSB2b2lkIDApIHtcbiAgICBtdWx0aXBsZSA9IDEwO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwoeCAvIG11bHRpcGxlKSAqIG11bHRpcGxlO1xufTtcbnZhciB0b0ludGVnZXIgPSBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUsIG1pbikge1xuICBpZiAobWluID09PSB2b2lkIDApIHtcbiAgICBtaW4gPSAwO1xuICB9XG4gIHZhciByZXN1bHQgPSBNYXRoLm1heChNYXRoLnJvdW5kKHZhbHVlKSwgbWluKTtcbiAgcmVzdWx0ID0gTnVtYmVyLmlzSW50ZWdlcihyZXN1bHQpID8gcmVzdWx0IDogbWluO1xuICByZXN1bHQgPSByZXN1bHQgPj0gbWluID8gcmVzdWx0IDogbWluO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNyZWF0ZUdyaWQgPSBmdW5jdGlvbiBjcmVhdGVHcmlkKGdyYXBoLCBub2Rlcywgc291cmNlLCB0YXJnZXQsIGdyaWRSYXRpbykge1xuICBpZiAoZ3JpZFJhdGlvID09PSB2b2lkIDApIHtcbiAgICBncmlkUmF0aW8gPSAyO1xuICB9XG4gIHZhciB4TWluID0gZ3JhcGgueE1pbixcbiAgICB5TWluID0gZ3JhcGgueU1pbixcbiAgICB3aWR0aCA9IGdyYXBoLndpZHRoLFxuICAgIGhlaWdodCA9IGdyYXBoLmhlaWdodDtcbiAgLy8gQ3JlYXRlIGEgZ3JpZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGggYm94LCB3aGVyZSBlYWNoIGNlbGwgaXNcbiAgLy8gZXF1aXZhbGVudCB0byAxMHgxMCBwaXhlbHMgKG9yIHRoZSBncmlkIHJhdGlvKSBvbiB0aGUgZ3JhcGguIFdlJ2xsIHVzZVxuICAvLyB0aGlzIHNpbXBsaWZpZWQgZ3JpZCB0byBkbyBwYXRoZmluZGluZy5cbiAgdmFyIG1hcENvbHVtbnMgPSByb3VuZFVwKHdpZHRoLCBncmlkUmF0aW8pIC8gZ3JpZFJhdGlvICsgMTtcbiAgdmFyIG1hcFJvd3MgPSByb3VuZFVwKGhlaWdodCwgZ3JpZFJhdGlvKSAvIGdyaWRSYXRpbyArIDE7XG4gIHZhciBncmlkID0gbmV3IHBhdGhmaW5kaW5nLkdyaWQobWFwQ29sdW1ucywgbWFwUm93cyk7XG4gIC8vIFVwZGF0ZSB0aGUgZ3JpZCByZXByZXNlbnRhdGlvbiB3aXRoIHRoZSBzcGFjZSB0aGUgbm9kZXMgdGFrZSB1cFxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIG5vZGVTdGFydCA9IGdyYXBoVG9HcmlkUG9pbnQobm9kZS50b3BMZWZ0LCB4TWluLCB5TWluLCBncmlkUmF0aW8pO1xuICAgIHZhciBub2RlRW5kID0gZ3JhcGhUb0dyaWRQb2ludChub2RlLmJvdHRvbVJpZ2h0LCB4TWluLCB5TWluLCBncmlkUmF0aW8pO1xuICAgIGZvciAodmFyIHggPSBub2RlU3RhcnQueDsgeCA8IG5vZGVFbmQueDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gbm9kZVN0YXJ0Lnk7IHkgPCBub2RlRW5kLnk7IHkrKykge1xuICAgICAgICBncmlkLnNldFdhbGthYmxlQXQoeCwgeSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8vIENvbnZlcnQgdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgZ3JhcGggcG9pbnRzIHRvIGdyaWQgcG9pbnRzXG4gIHZhciBzdGFydEdyaWQgPSBncmFwaFRvR3JpZFBvaW50KHtcbiAgICB4OiByb3VuZChzb3VyY2UueCwgZ3JpZFJhdGlvKSxcbiAgICB5OiByb3VuZChzb3VyY2UueSwgZ3JpZFJhdGlvKVxuICB9LCB4TWluLCB5TWluLCBncmlkUmF0aW8pO1xuICB2YXIgZW5kR3JpZCA9IGdyYXBoVG9HcmlkUG9pbnQoe1xuICAgIHg6IHJvdW5kKHRhcmdldC54LCBncmlkUmF0aW8pLFxuICAgIHk6IHJvdW5kKHRhcmdldC55LCBncmlkUmF0aW8pXG4gIH0sIHhNaW4sIHlNaW4sIGdyaWRSYXRpbyk7XG4gIC8vIEd1YXJhbnRlZSBhIHdhbGthYmxlIHBhdGggYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMsIGV2ZW4gaWYgdGhlXG4gIC8vIHNvdXJjZSBvciB0YXJnZXQgd2hlcmUgY292ZXJlZCBieSBhbm90aGVyIG5vZGUgb3IgYnkgcGFkZGluZ1xuICB2YXIgc3RhcnRpbmdOb2RlID0gZ3JpZC5nZXROb2RlQXQoc3RhcnRHcmlkLngsIHN0YXJ0R3JpZC55KTtcbiAgZ3VhcmFudGVlV2Fsa2FibGVQYXRoKGdyaWQsIHN0YXJ0aW5nTm9kZSwgc291cmNlLnBvc2l0aW9uKTtcbiAgdmFyIGVuZGluZ05vZGUgPSBncmlkLmdldE5vZGVBdChlbmRHcmlkLngsIGVuZEdyaWQueSk7XG4gIGd1YXJhbnRlZVdhbGthYmxlUGF0aChncmlkLCBlbmRpbmdOb2RlLCB0YXJnZXQucG9zaXRpb24pO1xuICAvLyBVc2UgdGhlIG5leHQgY2xvc2VzdCBwb2ludHMgYXMgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLCBzb1xuICAvLyBwYXRoZmluZGluZyBkb2VzIG5vdCBzdGFydCB0b28gY2xvc2UgdG8gdGhlIG5vZGVzXG4gIHZhciBzdGFydCA9IGdldE5leHRQb2ludEZyb21Qb3NpdGlvbihzdGFydGluZ05vZGUsIHNvdXJjZS5wb3NpdGlvbik7XG4gIHZhciBlbmQgPSBnZXROZXh0UG9pbnRGcm9tUG9zaXRpb24oZW5kaW5nTm9kZSwgdGFyZ2V0LnBvc2l0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICBncmlkOiBncmlkLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufTtcblxuLyoqXHJcbiAqIERyYXdzIGEgU1ZHIHBhdGggZnJvbSBhIGxpc3Qgb2YgcG9pbnRzLCB1c2luZyBzdHJhaWdodCBsaW5lcy5cclxuICovXG52YXIgc3ZnRHJhd1N0cmFpZ2h0TGluZVBhdGggPSBmdW5jdGlvbiBzdmdEcmF3U3RyYWlnaHRMaW5lUGF0aChzb3VyY2UsIHRhcmdldCwgcGF0aCkge1xuICB2YXIgc3ZnUGF0aFN0cmluZyA9IFwiTSBcIiArIHNvdXJjZS54ICsgXCIsIFwiICsgc291cmNlLnkgKyBcIiBcIjtcbiAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciB4ID0gcG9pbnRbMF0sXG4gICAgICB5ID0gcG9pbnRbMV07XG4gICAgc3ZnUGF0aFN0cmluZyArPSBcIkwgXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiIFwiO1xuICB9KTtcbiAgc3ZnUGF0aFN0cmluZyArPSBcIkwgXCIgKyB0YXJnZXQueCArIFwiLCBcIiArIHRhcmdldC55ICsgXCIgXCI7XG4gIHJldHVybiBzdmdQYXRoU3RyaW5nO1xufTtcbi8qKlxyXG4gKiBEcmF3cyBhIFNWRyBwYXRoIGZyb20gYSBsaXN0IG9mIHBvaW50cywgdXNpbmcgcm91bmRlZCBsaW5lcy5cclxuICovXG52YXIgc3ZnRHJhd1Ntb290aExpbmVQYXRoID0gZnVuY3Rpb24gc3ZnRHJhd1Ntb290aExpbmVQYXRoKHNvdXJjZSwgdGFyZ2V0LCBwYXRoKSB7XG4gIHZhciBwb2ludHMgPSBbW3NvdXJjZS54LCBzb3VyY2UueV1dLmNvbmNhdChwYXRoLCBbW3RhcmdldC54LCB0YXJnZXQueV1dKTtcbiAgcmV0dXJuIHF1YWRyYXRpY0JlemllckN1cnZlKHBvaW50cyk7XG59O1xudmFyIHF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gcXVhZHJhdGljQmV6aWVyQ3VydmUocG9pbnRzKSB7XG4gIHZhciBYID0gMDtcbiAgdmFyIFkgPSAxO1xuICB2YXIgcG9pbnQgPSBwb2ludHNbMF07XG4gIHZhciBmaXJzdCA9IHBvaW50c1swXTtcbiAgdmFyIHN2Z1BhdGggPSBcIk1cIiArIGZpcnN0W1hdICsgXCIsXCIgKyBmaXJzdFtZXSArIFwiTVwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0ID0gcG9pbnRzW2ldO1xuICAgIHZhciBtaWRQb2ludCA9IGdldE1pZFBvaW50KHBvaW50W1hdLCBwb2ludFtZXSwgbmV4dFtYXSwgbmV4dFtZXSk7XG4gICAgc3ZnUGF0aCArPSBcIiBcIiArIG1pZFBvaW50W1hdICsgXCIsXCIgKyBtaWRQb2ludFtZXTtcbiAgICBzdmdQYXRoICs9IFwiUVwiICsgbmV4dFtYXSArIFwiLFwiICsgbmV4dFtZXTtcbiAgICBwb2ludCA9IG5leHQ7XG4gIH1cbiAgdmFyIGxhc3QgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICBzdmdQYXRoICs9IFwiIFwiICsgbGFzdFswXSArIFwiLFwiICsgbGFzdFsxXTtcbiAgcmV0dXJuIHN2Z1BhdGg7XG59O1xudmFyIGdldE1pZFBvaW50ID0gZnVuY3Rpb24gZ2V0TWlkUG9pbnQoQXgsIEF5LCBCeCwgQnkpIHtcbiAgdmFyIFp4ID0gKEF4IC0gQngpIC8gMiArIEJ4O1xuICB2YXIgWnkgPSAoQXkgLSBCeSkgLyAyICsgQnk7XG4gIHJldHVybiBbWngsIFp5XTtcbn07XG5cbi8vIEZJWE1FOiBUaGUgXCJwYXRoZmluZGluZ1wiIG1vZHVsZSBkb2Ugbm90IGhhdmUgcHJvcGVyIHR5cGluZ3MuXG52YXIgcGF0aGZpbmRpbmdBU3RhckRpYWdvbmFsID0gZnVuY3Rpb24gcGF0aGZpbmRpbmdBU3RhckRpYWdvbmFsKGdyaWQsIHN0YXJ0LCBlbmQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZmluZGVyID0gbmV3IHBhdGhmaW5kaW5nLkFTdGFyRmluZGVyKHtcbiAgICAgIGRpYWdvbmFsTW92ZW1lbnQ6IHBhdGhmaW5kaW5nLkRpYWdvbmFsTW92ZW1lbnQuQWx3YXlzXG4gICAgfSk7XG4gICAgdmFyIGZ1bGxQYXRoID0gZmluZGVyLmZpbmRQYXRoKHN0YXJ0LngsIHN0YXJ0LnksIGVuZC54LCBlbmQueSwgZ3JpZCk7XG4gICAgdmFyIHNtb290aGVkUGF0aCA9IHBhdGhmaW5kaW5nLlV0aWwuc21vb3RoZW5QYXRoKGdyaWQsIGZ1bGxQYXRoKTtcbiAgICBpZiAoZnVsbFBhdGgubGVuZ3RoID09PSAwIHx8IHNtb290aGVkUGF0aC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBmdWxsUGF0aDogZnVsbFBhdGgsXG4gICAgICBzbW9vdGhlZFBhdGg6IHNtb290aGVkUGF0aFxuICAgIH07XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbnZhciBwYXRoZmluZGluZ0FTdGFyTm9EaWFnb25hbCA9IGZ1bmN0aW9uIHBhdGhmaW5kaW5nQVN0YXJOb0RpYWdvbmFsKGdyaWQsIHN0YXJ0LCBlbmQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZmluZGVyID0gbmV3IHBhdGhmaW5kaW5nLkFTdGFyRmluZGVyKHtcbiAgICAgIGRpYWdvbmFsTW92ZW1lbnQ6IHBhdGhmaW5kaW5nLkRpYWdvbmFsTW92ZW1lbnQuTmV2ZXJcbiAgICB9KTtcbiAgICB2YXIgZnVsbFBhdGggPSBmaW5kZXIuZmluZFBhdGgoc3RhcnQueCwgc3RhcnQueSwgZW5kLngsIGVuZC55LCBncmlkKTtcbiAgICB2YXIgc21vb3RoZWRQYXRoID0gcGF0aGZpbmRpbmcuVXRpbC5zbW9vdGhlblBhdGgoZ3JpZCwgZnVsbFBhdGgpO1xuICAgIGlmIChmdWxsUGF0aC5sZW5ndGggPT09IDAgfHwgc21vb3RoZWRQYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZ1bGxQYXRoOiBmdWxsUGF0aCxcbiAgICAgIHNtb290aGVkUGF0aDogc21vb3RoZWRQYXRoXG4gICAgfTtcbiAgfSBjYXRjaCAoX3VudXNlZDIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbnZhciBwYXRoZmluZGluZ0p1bXBQb2ludE5vRGlhZ29uYWwgPSBmdW5jdGlvbiBwYXRoZmluZGluZ0p1bXBQb2ludE5vRGlhZ29uYWwoZ3JpZCwgc3RhcnQsIGVuZCkge1xuICB0cnkge1xuICAgIC8vIEZJWE1FOiBUaGUgXCJwYXRoZmluZGluZ1wiIG1vZHVsZSBkb2Ugbm90IGhhdmUgcHJvcGVyIHR5cGluZ3MuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBmaW5kZXIgPSBuZXcgcGF0aGZpbmRpbmcuSnVtcFBvaW50RmluZGVyKHtcbiAgICAgIGRpYWdvbmFsTW92ZW1lbnQ6IHBhdGhmaW5kaW5nLkRpYWdvbmFsTW92ZW1lbnQuTmV2ZXJcbiAgICB9KTtcbiAgICB2YXIgZnVsbFBhdGggPSBmaW5kZXIuZmluZFBhdGgoc3RhcnQueCwgc3RhcnQueSwgZW5kLngsIGVuZC55LCBncmlkKTtcbiAgICB2YXIgc21vb3RoZWRQYXRoID0gZnVsbFBhdGg7XG4gICAgaWYgKGZ1bGxQYXRoLmxlbmd0aCA9PT0gMCB8fCBzbW9vdGhlZFBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgZnVsbFBhdGg6IGZ1bGxQYXRoLFxuICAgICAgc21vb3RoZWRQYXRoOiBzbW9vdGhlZFBhdGhcbiAgICB9O1xuICB9IGNhdGNoIChfdW51c2VkMykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcclxuICogR2V0IHRoZSBib3VuZGluZyBib3ggb2YgYWxsIG5vZGVzIGFuZCB0aGUgZ3JhcGggaXRzZWxmLCBhcyBYL1kgY29vcmRpbmF0ZXNcclxuICogb2YgYWxsIGNvcm5lciBwb2ludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZSBsaXN0XHJcbiAqIEBwYXJhbSBub2RlUGFkZGluZyBPcHRpb25hbCBwYWRkaW5nIHRvIGFkZCB0byB0aGUgbm9kZSdzIGFuZCBncmFwaCBib3VuZGluZyBib3hlc1xyXG4gKiBAcGFyYW0gcm91bmRUbyBFdmVyeXRoaW5nIHdpbGwgYmUgcm91bmRlZCB0byB0aGlzIG5lYXJlc3QgaW50ZWdlclxyXG4gKiBAcmV0dXJucyBHcmFwaCBhbmQgbm9kZXMgYm91bmRpbmcgYm94ZXMuXHJcbiAqL1xudmFyIGdldEJvdW5kaW5nQm94ZXMgPSBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveGVzKG5vZGVzLCBub2RlUGFkZGluZywgcm91bmRUbykge1xuICBpZiAobm9kZVBhZGRpbmcgPT09IHZvaWQgMCkge1xuICAgIG5vZGVQYWRkaW5nID0gMjtcbiAgfVxuICBpZiAocm91bmRUbyA9PT0gdm9pZCAwKSB7XG4gICAgcm91bmRUbyA9IDI7XG4gIH1cbiAgdmFyIHhNYXggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgdmFyIHlNYXggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgdmFyIHhNaW4gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIHlNaW4gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIG5vZGVCb3hlcyA9IG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfbm9kZSRwb3NpdGlvbkFic29sdXQsIF9ub2RlJHBvc2l0aW9uQWJzb2x1dDI7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5tYXgobm9kZS53aWR0aCB8fCAwLCAxKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgobm9kZS5oZWlnaHQgfHwgMCwgMSk7XG4gICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgeDogKChfbm9kZSRwb3NpdGlvbkFic29sdXQgPSBub2RlLnBvc2l0aW9uQWJzb2x1dGUpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRwb3NpdGlvbkFic29sdXQueCkgfHwgMCxcbiAgICAgIHk6ICgoX25vZGUkcG9zaXRpb25BYnNvbHV0MiA9IG5vZGUucG9zaXRpb25BYnNvbHV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJHBvc2l0aW9uQWJzb2x1dDIueSkgfHwgMFxuICAgIH07XG4gICAgdmFyIHRvcExlZnQgPSB7XG4gICAgICB4OiBwb3NpdGlvbi54IC0gbm9kZVBhZGRpbmcsXG4gICAgICB5OiBwb3NpdGlvbi55IC0gbm9kZVBhZGRpbmdcbiAgICB9O1xuICAgIHZhciBib3R0b21MZWZ0ID0ge1xuICAgICAgeDogcG9zaXRpb24ueCAtIG5vZGVQYWRkaW5nLFxuICAgICAgeTogcG9zaXRpb24ueSArIGhlaWdodCArIG5vZGVQYWRkaW5nXG4gICAgfTtcbiAgICB2YXIgdG9wUmlnaHQgPSB7XG4gICAgICB4OiBwb3NpdGlvbi54ICsgd2lkdGggKyBub2RlUGFkZGluZyxcbiAgICAgIHk6IHBvc2l0aW9uLnkgLSBub2RlUGFkZGluZ1xuICAgIH07XG4gICAgdmFyIGJvdHRvbVJpZ2h0ID0ge1xuICAgICAgeDogcG9zaXRpb24ueCArIHdpZHRoICsgbm9kZVBhZGRpbmcsXG4gICAgICB5OiBwb3NpdGlvbi55ICsgaGVpZ2h0ICsgbm9kZVBhZGRpbmdcbiAgICB9O1xuICAgIGlmIChyb3VuZFRvID4gMCkge1xuICAgICAgdG9wTGVmdC54ID0gcm91bmREb3duKHRvcExlZnQueCwgcm91bmRUbyk7XG4gICAgICB0b3BMZWZ0LnkgPSByb3VuZERvd24odG9wTGVmdC55LCByb3VuZFRvKTtcbiAgICAgIGJvdHRvbUxlZnQueCA9IHJvdW5kRG93bihib3R0b21MZWZ0LngsIHJvdW5kVG8pO1xuICAgICAgYm90dG9tTGVmdC55ID0gcm91bmRVcChib3R0b21MZWZ0LnksIHJvdW5kVG8pO1xuICAgICAgdG9wUmlnaHQueCA9IHJvdW5kVXAodG9wUmlnaHQueCwgcm91bmRUbyk7XG4gICAgICB0b3BSaWdodC55ID0gcm91bmREb3duKHRvcFJpZ2h0LnksIHJvdW5kVG8pO1xuICAgICAgYm90dG9tUmlnaHQueCA9IHJvdW5kVXAoYm90dG9tUmlnaHQueCwgcm91bmRUbyk7XG4gICAgICBib3R0b21SaWdodC55ID0gcm91bmRVcChib3R0b21SaWdodC55LCByb3VuZFRvKTtcbiAgICB9XG4gICAgaWYgKHRvcExlZnQueSA8IHlNaW4pIHlNaW4gPSB0b3BMZWZ0Lnk7XG4gICAgaWYgKHRvcExlZnQueCA8IHhNaW4pIHhNaW4gPSB0b3BMZWZ0Lng7XG4gICAgaWYgKGJvdHRvbVJpZ2h0LnkgPiB5TWF4KSB5TWF4ID0gYm90dG9tUmlnaHQueTtcbiAgICBpZiAoYm90dG9tUmlnaHQueCA+IHhNYXgpIHhNYXggPSBib3R0b21SaWdodC54O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogbm9kZS5pZCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdG9wTGVmdDogdG9wTGVmdCxcbiAgICAgIGJvdHRvbUxlZnQ6IGJvdHRvbUxlZnQsXG4gICAgICB0b3BSaWdodDogdG9wUmlnaHQsXG4gICAgICBib3R0b21SaWdodDogYm90dG9tUmlnaHRcbiAgICB9O1xuICB9KTtcbiAgdmFyIGdyYXBoUGFkZGluZyA9IG5vZGVQYWRkaW5nICogMjtcbiAgeE1heCA9IHJvdW5kVXAoeE1heCArIGdyYXBoUGFkZGluZywgcm91bmRUbyk7XG4gIHlNYXggPSByb3VuZFVwKHlNYXggKyBncmFwaFBhZGRpbmcsIHJvdW5kVG8pO1xuICB4TWluID0gcm91bmREb3duKHhNaW4gLSBncmFwaFBhZGRpbmcsIHJvdW5kVG8pO1xuICB5TWluID0gcm91bmREb3duKHlNaW4gLSBncmFwaFBhZGRpbmcsIHJvdW5kVG8pO1xuICB2YXIgdG9wTGVmdCA9IHtcbiAgICB4OiB4TWluLFxuICAgIHk6IHlNaW5cbiAgfTtcbiAgdmFyIGJvdHRvbUxlZnQgPSB7XG4gICAgeDogeE1pbixcbiAgICB5OiB5TWF4XG4gIH07XG4gIHZhciB0b3BSaWdodCA9IHtcbiAgICB4OiB4TWF4LFxuICAgIHk6IHlNaW5cbiAgfTtcbiAgdmFyIGJvdHRvbVJpZ2h0ID0ge1xuICAgIHg6IHhNYXgsXG4gICAgeTogeU1heFxuICB9O1xuICB2YXIgd2lkdGggPSBNYXRoLmFicyh0b3BMZWZ0LnggLSB0b3BSaWdodC54KTtcbiAgdmFyIGhlaWdodCA9IE1hdGguYWJzKHRvcExlZnQueSAtIGJvdHRvbUxlZnQueSk7XG4gIHZhciBncmFwaEJveCA9IHtcbiAgICB0b3BMZWZ0OiB0b3BMZWZ0LFxuICAgIGJvdHRvbUxlZnQ6IGJvdHRvbUxlZnQsXG4gICAgdG9wUmlnaHQ6IHRvcFJpZ2h0LFxuICAgIGJvdHRvbVJpZ2h0OiBib3R0b21SaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeE1heDogeE1heCxcbiAgICB5TWF4OiB5TWF4LFxuICAgIHhNaW46IHhNaW4sXG4gICAgeU1pbjogeU1pblxuICB9O1xuICByZXR1cm4ge1xuICAgIG5vZGVCb3hlczogbm9kZUJveGVzLFxuICAgIGdyYXBoQm94OiBncmFwaEJveFxuICB9O1xufTtcblxudmFyIGdldFNtYXJ0RWRnZSA9IGZ1bmN0aW9uIGdldFNtYXJ0RWRnZShfcmVmKSB7XG4gIHZhciBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXG4gICAgX3JlZiRub2RlcyA9IF9yZWYubm9kZXMsXG4gICAgbm9kZXMgPSBfcmVmJG5vZGVzID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkbm9kZXMsXG4gICAgc291cmNlWCA9IF9yZWYuc291cmNlWCxcbiAgICBzb3VyY2VZID0gX3JlZi5zb3VyY2VZLFxuICAgIHRhcmdldFggPSBfcmVmLnRhcmdldFgsXG4gICAgdGFyZ2V0WSA9IF9yZWYudGFyZ2V0WSxcbiAgICBzb3VyY2VQb3NpdGlvbiA9IF9yZWYuc291cmNlUG9zaXRpb24sXG4gICAgdGFyZ2V0UG9zaXRpb24gPSBfcmVmLnRhcmdldFBvc2l0aW9uO1xuICB0cnkge1xuICAgIHZhciBfb3B0aW9ucyRkcmF3RWRnZSA9IG9wdGlvbnMuZHJhd0VkZ2UsXG4gICAgICBkcmF3RWRnZSA9IF9vcHRpb25zJGRyYXdFZGdlID09PSB2b2lkIDAgPyBzdmdEcmF3U21vb3RoTGluZVBhdGggOiBfb3B0aW9ucyRkcmF3RWRnZSxcbiAgICAgIF9vcHRpb25zJGdlbmVyYXRlUGF0aCA9IG9wdGlvbnMuZ2VuZXJhdGVQYXRoLFxuICAgICAgZ2VuZXJhdGVQYXRoID0gX29wdGlvbnMkZ2VuZXJhdGVQYXRoID09PSB2b2lkIDAgPyBwYXRoZmluZGluZ0FTdGFyRGlhZ29uYWwgOiBfb3B0aW9ucyRnZW5lcmF0ZVBhdGg7XG4gICAgdmFyIF9vcHRpb25zJGdyaWRSYXRpbyA9IG9wdGlvbnMuZ3JpZFJhdGlvLFxuICAgICAgZ3JpZFJhdGlvID0gX29wdGlvbnMkZ3JpZFJhdGlvID09PSB2b2lkIDAgPyAxMCA6IF9vcHRpb25zJGdyaWRSYXRpbyxcbiAgICAgIF9vcHRpb25zJG5vZGVQYWRkaW5nID0gb3B0aW9ucy5ub2RlUGFkZGluZyxcbiAgICAgIG5vZGVQYWRkaW5nID0gX29wdGlvbnMkbm9kZVBhZGRpbmcgPT09IHZvaWQgMCA/IDEwIDogX29wdGlvbnMkbm9kZVBhZGRpbmc7XG4gICAgZ3JpZFJhdGlvID0gdG9JbnRlZ2VyKGdyaWRSYXRpbyk7XG4gICAgbm9kZVBhZGRpbmcgPSB0b0ludGVnZXIobm9kZVBhZGRpbmcpO1xuICAgIC8vIFdlIHVzZSB0aGUgbm9kZSdzIGluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGJvdW5kaW5nIGJveGVzIGZvciB0aGVtXG4gICAgLy8gYW5kIHRoZSBncmFwaFxuICAgIHZhciBfZ2V0Qm91bmRpbmdCb3hlcyA9IGdldEJvdW5kaW5nQm94ZXMobm9kZXMsIG5vZGVQYWRkaW5nLCBncmlkUmF0aW8pLFxuICAgICAgZ3JhcGhCb3ggPSBfZ2V0Qm91bmRpbmdCb3hlcy5ncmFwaEJveCxcbiAgICAgIG5vZGVCb3hlcyA9IF9nZXRCb3VuZGluZ0JveGVzLm5vZGVCb3hlcztcbiAgICB2YXIgc291cmNlID0ge1xuICAgICAgeDogc291cmNlWCxcbiAgICAgIHk6IHNvdXJjZVksXG4gICAgICBwb3NpdGlvbjogc291cmNlUG9zaXRpb25cbiAgICB9O1xuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICB4OiB0YXJnZXRYLFxuICAgICAgeTogdGFyZ2V0WSxcbiAgICAgIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvblxuICAgIH07XG4gICAgLy8gV2l0aCB0aGlzIGluZm9ybWF0aW9uLCB3ZSBjYW4gY3JlYXRlIGEgMkQgZ3JpZCByZXByZXNlbnRhdGlvbiBvZlxuICAgIC8vIG91ciBncmFwaCwgdGhhdCB0ZWxscyB1cyB3aGVyZSBpbiB0aGUgZ3JhcGggdGhlcmUgaXMgYSBcImZyZWVcIiBzcGFjZSBvciBub3RcbiAgICB2YXIgX2NyZWF0ZUdyaWQgPSBjcmVhdGVHcmlkKGdyYXBoQm94LCBub2RlQm94ZXMsIHNvdXJjZSwgdGFyZ2V0LCBncmlkUmF0aW8pLFxuICAgICAgZ3JpZCA9IF9jcmVhdGVHcmlkLmdyaWQsXG4gICAgICBzdGFydCA9IF9jcmVhdGVHcmlkLnN0YXJ0LFxuICAgICAgZW5kID0gX2NyZWF0ZUdyaWQuZW5kO1xuICAgIC8vIFdlIHRoZW4gY2FuIHVzZSB0aGUgZ3JpZCByZXByZXNlbnRhdGlvbiB0byBkbyBwYXRoZmluZGluZ1xuICAgIHZhciBnZW5lcmF0ZVBhdGhSZXN1bHQgPSBnZW5lcmF0ZVBhdGgoZ3JpZCwgc3RhcnQsIGVuZCk7XG4gICAgaWYgKGdlbmVyYXRlUGF0aFJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBmdWxsUGF0aCA9IGdlbmVyYXRlUGF0aFJlc3VsdC5mdWxsUGF0aCxcbiAgICAgIHNtb290aGVkUGF0aCA9IGdlbmVyYXRlUGF0aFJlc3VsdC5zbW9vdGhlZFBhdGg7XG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBncmlkIHBhdGggdG8gYSBzZXF1ZW5jZSBvZiBncmFwaCBjb29yZGluYXRlcy5cbiAgICB2YXIgZ3JhcGhQYXRoID0gc21vb3RoZWRQYXRoLm1hcChmdW5jdGlvbiAoZ3JpZFBvaW50KSB7XG4gICAgICB2YXIgeCA9IGdyaWRQb2ludFswXSxcbiAgICAgICAgeSA9IGdyaWRQb2ludFsxXTtcbiAgICAgIHZhciBncmFwaFBvaW50ID0gZ3JpZFRvR3JhcGhQb2ludCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH0sIGdyYXBoQm94LnhNaW4sIGdyYXBoQm94LnlNaW4sIGdyaWRSYXRpbyk7XG4gICAgICByZXR1cm4gW2dyYXBoUG9pbnQueCwgZ3JhcGhQb2ludC55XTtcbiAgICB9KTtcbiAgICAvLyBGaW5hbGx5LCB3ZSBjYW4gdXNlIHRoZSBncmFwaCBwYXRoIHRvIGRyYXcgdGhlIGVkZ2VcbiAgICB2YXIgc3ZnUGF0aFN0cmluZyA9IGRyYXdFZGdlKHNvdXJjZSwgdGFyZ2V0LCBncmFwaFBhdGgpO1xuICAgIC8vIENvbXB1dGUgdGhlIGVkZ2UncyBtaWRkbGUgcG9pbnQgdXNpbmcgdGhlIGZ1bGwgcGF0aCwgc28gdXNlcnMgY2FuIHVzZVxuICAgIC8vIGl0IHRvIHBvc2l0aW9uIHRoZWlyIGN1c3RvbSBsYWJlbHNcbiAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKGZ1bGxQYXRoLmxlbmd0aCAvIDIpO1xuICAgIHZhciBtaWRkbGVQb2ludCA9IGZ1bGxQYXRoW2luZGV4XTtcbiAgICB2YXIgbWlkZGxlWCA9IG1pZGRsZVBvaW50WzBdLFxuICAgICAgbWlkZGxlWSA9IG1pZGRsZVBvaW50WzFdO1xuICAgIHZhciBfZ3JpZFRvR3JhcGhQb2ludCA9IGdyaWRUb0dyYXBoUG9pbnQoe1xuICAgICAgICB4OiBtaWRkbGVYLFxuICAgICAgICB5OiBtaWRkbGVZXG4gICAgICB9LCBncmFwaEJveC54TWluLCBncmFwaEJveC55TWluLCBncmlkUmF0aW8pLFxuICAgICAgZWRnZUNlbnRlclggPSBfZ3JpZFRvR3JhcGhQb2ludC54LFxuICAgICAgZWRnZUNlbnRlclkgPSBfZ3JpZFRvR3JhcGhQb2ludC55O1xuICAgIHJldHVybiB7XG4gICAgICBzdmdQYXRoU3RyaW5nOiBzdmdQYXRoU3RyaW5nLFxuICAgICAgZWRnZUNlbnRlclg6IGVkZ2VDZW50ZXJYLFxuICAgICAgZWRnZUNlbnRlclk6IGVkZ2VDZW50ZXJZXG4gICAgfTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wibm9kZXNcIiwgXCJvcHRpb25zXCJdO1xuZnVuY3Rpb24gU21hcnRFZGdlKF9yZWYpIHtcbiAgdmFyIG5vZGVzID0gX3JlZi5ub2RlcyxcbiAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgIGVkZ2VQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCk7XG4gIHZhciBzb3VyY2VYID0gZWRnZVByb3BzLnNvdXJjZVgsXG4gICAgc291cmNlWSA9IGVkZ2VQcm9wcy5zb3VyY2VZLFxuICAgIHNvdXJjZVBvc2l0aW9uID0gZWRnZVByb3BzLnNvdXJjZVBvc2l0aW9uLFxuICAgIHRhcmdldFggPSBlZGdlUHJvcHMudGFyZ2V0WCxcbiAgICB0YXJnZXRZID0gZWRnZVByb3BzLnRhcmdldFksXG4gICAgdGFyZ2V0UG9zaXRpb24gPSBlZGdlUHJvcHMudGFyZ2V0UG9zaXRpb24sXG4gICAgc3R5bGUgPSBlZGdlUHJvcHMuc3R5bGUsXG4gICAgbGFiZWwgPSBlZGdlUHJvcHMubGFiZWwsXG4gICAgbGFiZWxTdHlsZSA9IGVkZ2VQcm9wcy5sYWJlbFN0eWxlLFxuICAgIGxhYmVsU2hvd0JnID0gZWRnZVByb3BzLmxhYmVsU2hvd0JnLFxuICAgIGxhYmVsQmdTdHlsZSA9IGVkZ2VQcm9wcy5sYWJlbEJnU3R5bGUsXG4gICAgbGFiZWxCZ1BhZGRpbmcgPSBlZGdlUHJvcHMubGFiZWxCZ1BhZGRpbmcsXG4gICAgbGFiZWxCZ0JvcmRlclJhZGl1cyA9IGVkZ2VQcm9wcy5sYWJlbEJnQm9yZGVyUmFkaXVzLFxuICAgIG1hcmtlckVuZCA9IGVkZ2VQcm9wcy5tYXJrZXJFbmQsXG4gICAgbWFya2VyU3RhcnQgPSBlZGdlUHJvcHMubWFya2VyU3RhcnQsXG4gICAgaW50ZXJhY3Rpb25XaWR0aCA9IGVkZ2VQcm9wcy5pbnRlcmFjdGlvbldpZHRoO1xuICB2YXIgc21hcnRSZXNwb25zZSA9IGdldFNtYXJ0RWRnZSh7XG4gICAgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLFxuICAgIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbixcbiAgICBzb3VyY2VYOiBzb3VyY2VYLFxuICAgIHNvdXJjZVk6IHNvdXJjZVksXG4gICAgdGFyZ2V0WDogdGFyZ2V0WCxcbiAgICB0YXJnZXRZOiB0YXJnZXRZLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgbm9kZXM6IG5vZGVzXG4gIH0pO1xuICB2YXIgRmFsbGJhY2tFZGdlID0gb3B0aW9ucy5mYWxsYmFjayB8fCByZWFjdGZsb3cuQmV6aWVyRWRnZTtcbiAgaWYgKHNtYXJ0UmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRmFsbGJhY2tFZGdlLCBfZXh0ZW5kcyh7fSwgZWRnZVByb3BzKSk7XG4gIH1cbiAgdmFyIGVkZ2VDZW50ZXJYID0gc21hcnRSZXNwb25zZS5lZGdlQ2VudGVyWCxcbiAgICBlZGdlQ2VudGVyWSA9IHNtYXJ0UmVzcG9uc2UuZWRnZUNlbnRlclksXG4gICAgc3ZnUGF0aFN0cmluZyA9IHNtYXJ0UmVzcG9uc2Uuc3ZnUGF0aFN0cmluZztcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KHJlYWN0Zmxvdy5CYXNlRWRnZSwge1xuICAgIHBhdGg6IHN2Z1BhdGhTdHJpbmcsXG4gICAgbGFiZWxYOiBlZGdlQ2VudGVyWCxcbiAgICBsYWJlbFk6IGVkZ2VDZW50ZXJZLFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLFxuICAgIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZyxcbiAgICBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSxcbiAgICBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsXG4gICAgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cyxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LFxuICAgIG1hcmtlckVuZDogbWFya2VyRW5kLFxuICAgIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGhcbiAgfSk7XG59XG5cbnZhciBCZXppZXJDb25maWd1cmF0aW9uID0ge1xuICBkcmF3RWRnZTogc3ZnRHJhd1Ntb290aExpbmVQYXRoLFxuICBnZW5lcmF0ZVBhdGg6IHBhdGhmaW5kaW5nQVN0YXJEaWFnb25hbCxcbiAgZmFsbGJhY2s6IHJlYWN0Zmxvdy5CZXppZXJFZGdlXG59O1xuZnVuY3Rpb24gU21hcnRCZXppZXJFZGdlKHByb3BzKSB7XG4gIHZhciBub2RlcyA9IHJlYWN0Zmxvdy51c2VOb2RlcygpO1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoU21hcnRFZGdlLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBvcHRpb25zOiBCZXppZXJDb25maWd1cmF0aW9uLFxuICAgIG5vZGVzOiBub2Rlc1xuICB9KSk7XG59XG5cbnZhciBTdGVwQ29uZmlndXJhdGlvbiA9IHtcbiAgZHJhd0VkZ2U6IHN2Z0RyYXdTdHJhaWdodExpbmVQYXRoLFxuICBnZW5lcmF0ZVBhdGg6IHBhdGhmaW5kaW5nSnVtcFBvaW50Tm9EaWFnb25hbCxcbiAgZmFsbGJhY2s6IHJlYWN0Zmxvdy5TdGVwRWRnZVxufTtcbmZ1bmN0aW9uIFNtYXJ0U3RlcEVkZ2UocHJvcHMpIHtcbiAgdmFyIG5vZGVzID0gcmVhY3RmbG93LnVzZU5vZGVzKCk7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTbWFydEVkZ2UsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIG9wdGlvbnM6IFN0ZXBDb25maWd1cmF0aW9uLFxuICAgIG5vZGVzOiBub2Rlc1xuICB9KSk7XG59XG5cbnZhciBTdHJhaWdodENvbmZpZ3VyYXRpb24gPSB7XG4gIGRyYXdFZGdlOiBzdmdEcmF3U3RyYWlnaHRMaW5lUGF0aCxcbiAgZ2VuZXJhdGVQYXRoOiBwYXRoZmluZGluZ0FTdGFyTm9EaWFnb25hbCxcbiAgZmFsbGJhY2s6IHJlYWN0Zmxvdy5TdHJhaWdodEVkZ2Vcbn07XG5mdW5jdGlvbiBTbWFydFN0cmFpZ2h0RWRnZShwcm9wcykge1xuICB2YXIgbm9kZXMgPSByZWFjdGZsb3cudXNlTm9kZXMoKTtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFNtYXJ0RWRnZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgb3B0aW9uczogU3RyYWlnaHRDb25maWd1cmF0aW9uLFxuICAgIG5vZGVzOiBub2Rlc1xuICB9KSk7XG59XG5cbmV4cG9ydHMuU21hcnRCZXppZXJFZGdlID0gU21hcnRCZXppZXJFZGdlO1xuZXhwb3J0cy5TbWFydEVkZ2UgPSBTbWFydEVkZ2U7XG5leHBvcnRzLlNtYXJ0U3RlcEVkZ2UgPSBTbWFydFN0ZXBFZGdlO1xuZXhwb3J0cy5TbWFydFN0cmFpZ2h0RWRnZSA9IFNtYXJ0U3RyYWlnaHRFZGdlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTbWFydEJlemllckVkZ2U7XG5leHBvcnRzLmdldFNtYXJ0RWRnZSA9IGdldFNtYXJ0RWRnZTtcbmV4cG9ydHMucGF0aGZpbmRpbmdBU3RhckRpYWdvbmFsID0gcGF0aGZpbmRpbmdBU3RhckRpYWdvbmFsO1xuZXhwb3J0cy5wYXRoZmluZGluZ0FTdGFyTm9EaWFnb25hbCA9IHBhdGhmaW5kaW5nQVN0YXJOb0RpYWdvbmFsO1xuZXhwb3J0cy5wYXRoZmluZGluZ0p1bXBQb2ludE5vRGlhZ29uYWwgPSBwYXRoZmluZGluZ0p1bXBQb2ludE5vRGlhZ29uYWw7XG5leHBvcnRzLnN2Z0RyYXdTbW9vdGhMaW5lUGF0aCA9IHN2Z0RyYXdTbW9vdGhMaW5lUGF0aDtcbmV4cG9ydHMuc3ZnRHJhd1N0cmFpZ2h0TGluZVBhdGggPSBzdmdEcmF3U3RyYWlnaHRMaW5lUGF0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LWZsb3ctc21hcnQtZWRnZS5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@tisoap+react-flow-smart-edge@3.0.0_react-dom@18.2.0_react@18.2.0_reactflow@11.9.3_typescript@4.9.5/node_modules/@tisoap/react-flow-smart-edge/dist/react-flow-smart-edge.cjs.development.js\n");

/***/ })

};
;